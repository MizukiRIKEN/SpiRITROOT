In file included from input_line_12:1:
In file included from /mnt/spirit/analysis/user/tsangc/SpiRITROOT/ana/STMatchImQMDTask.cc:4:
/mnt/spirit/analysis/user/tsangc/SpiRITROOT/ana/STMatchImQMDTask.hh:21:10: fatal error: 'STData.hh' file not found
#include "STData.hh"
         ^~~~~~~~~~~
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module G__StackDict: '
#line 1 "G__StackDict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_Autoloading_Map;
class STStack;
class STMCTrack;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module G__STParDict: '
#line 1 "G__STParDict dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_Autoloading_Map;
class __attribute__((annotate(R"ATTRDUMP(Factory for all SPiRIT parameter containers)ATTRDUMP"))) STContFact;
class STGeoPar;
class STDigiPar;
class STParameters;
'
Error in <TInterpreter::AutoParse>: Error parsing payload code for class STDigiPar with content:

#line 1 "G__STParDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
#ifndef STCONTFACT_H
#define STCONTFACT_H

#include "FairContFact.h"

class FairContainer;

class STContFact : public FairContFact
{
  public:
    STContFact();
    ~STContFact();

    FairParSet* createContainer(FairContainer*);

  private:
    void setAllContainers();

  ClassDef(STContFact, 1) // Factory for all SPiRIT parameter containers
};

#endif
#ifndef STGEOPAR_H
#define STGEOPAR_H

#include "FairParGenericSet.h"

class TObjArray;
class FairParamList;

class STGeoPar       : public FairParGenericSet
{
  public:

    /** List of FairGeoNodes for sensitive  volumes */
    TObjArray*      fGeoSensNodes;

    /** List of FairGeoNodes for sensitive  volumes */
    TObjArray*      fGeoPassNodes;

    STGeoPar(const char* name="STGeoPar",
             const char* title="SPiRIT Geometry Parameters",
             const char* context="TestDefaultContext");
    ~STGeoPar(void);
    void clear(void);
    void putParams(FairParamList*);
    Bool_t getParams(FairParamList*);
    TObjArray* GetGeoSensitiveNodes() {return fGeoSensNodes;}
    TObjArray* GetGeoPassiveNodes()   {return fGeoPassNodes;}

  private:
    STGeoPar(const STGeoPar&);
    STGeoPar& operator=(const STGeoPar&);

    ClassDef(STGeoPar,1)
};

#endif
/**
* @brief Store parameters from ST.parameters.par for later use.
*/

#ifndef STDIGIPAR_HH
#define STDIGIPAR_HH

// FAIRROOT classes
#include "FairParGenericSet.h"
#include "FairParamList.h"
#include "FairLogger.h"

// ROOT classes
#include "TString.h"
#include "TSystem.h"

class STDigiPar : public FairParGenericSet
{
  public :
    STDigiPar(const Char_t *name, const Char_t *title, const Char_t *context);
    ~STDigiPar();

    virtual Bool_t getParams(FairParamList *paramList);
    virtual void putParams(FairParamList *paramList);
    TString GetFile(Int_t fileNum);

    Double_t GetPadPlaneX();
    Double_t GetPadPlaneZ();
    Double_t GetPadSizeX();
    Double_t GetPadSizeZ();
       Int_t GetPadRows();
       Int_t GetPadLayers();
    Double_t GetAnodeWirePlaneY();
    Double_t GetGroundWirePlaneY();
    Double_t GetGatingWirePlaneY();
    Double_t GetFPNPedestalRMS();
    Double_t GetEField();
    /// returns the number of time buckets that the data actually has
       Int_t GetNumTbs();
    /// returns the number of time buckets of the time window
       Int_t GetWindowNumTbs();
    /// returns the time bucket number of the starting point of time window
       Int_t GetWindowStartTb();
       Int_t GetSamplingRate();
    /// returns the drift length in mm
    Double_t GetDriftLength();
    /// returns the slice divider
       Int_t GetYDivider();
    Double_t GetEIonize();
    /// returns the drift velocity in cm/us.
    Double_t GetDriftVelocity();
    Double_t GetCoefDiffusionLong();
    Double_t GetCoefDiffusionTrans();
    Double_t GetCoefAttachment();
       Int_t GetGain();

     TString GetTrackingParFileName();
     TString GetUAMapFileName();
     TString GetAGETMapFileName();
     TString GetGainCalibrationDataFileName();

    Double_t GetGCConstant();
    Double_t GetGCLinear();
    Double_t GetGCQuadratic();

    /// returns the time duration of a time bucket in given sampling time in ns.
       Int_t GetTBTime();
    Bool_t IsEmbed();
    Double_t GetYDriftOffset();
    Double_t GetTotalADCWhenSat();
    void SetIsEmbed(Bool_t val);

  private :
    FairLogger *fLogger;
    Bool_t fInitialized;
    Bool_t fIsEmbed;

    Double_t fPadPlaneX;
    Double_t fPadPlaneZ;
    Double_t fPadSizeX;
    Double_t fPadSizeZ;
       Int_t fPadRows;
       Int_t fPadLayers;
    Double_t fAnodeWirePlaneY;
    Double_t fGroundWirePlaneY;
    Double_t fGatingWirePlaneY;
    Double_t fFPNPedestalRMS;
    Double_t fEField;
       Int_t fNumTbs;
       Int_t fWindowNumTbs;
       Int_t fWindowStartTb;
       Int_t fSamplingRate;
    Double_t fDriftLength;
       Int_t fYDivider;
    Double_t fEIonize;
    Double_t fDriftVelocity;
    Double_t fCoefDiffusionLong;
    Double_t fCoefDiffusionTrans;
    Double_t fCoefAttachment;
       Int_t fGain;

     TString fUAMapFileName;
       Int_t fUAMapFile;
     TString fTrackingParFileName;
       Int_t fTrackingParFile;
     TString fAGETMapFileName;
       Int_t fAGETMapFile;
     TString fGainCalibrationDataFileName;
       Int_t fGainCalibrationDataFile;

    Double_t fGCConstant;
    Double_t fGCLinear;
    Double_t fGCQuadratic;
    Double_t fYDriftOffset;
    Double_t fTotalADCWhenSat;

  ClassDef(STDigiPar, 1);
};

#endif
/**
 * @brief Parameter database
 */

#ifndef STPARAMETERS_HH
#define STPARAMETERS_HH

#include <map>

using std::map;

#include "TString.h"

class STParameters
{
  public:
    STParameters();
    STParameters(Int_t runID, TString systemDB, TString runDB);
    ~STParameters() {};

    void SetRunID(Int_t runID);
    void ReadSystemDB(TString inputName);
    void ReadRunDB(TString inputName);

    void CheckOk();

    Int_t GetSystemID();
    Int_t GetNumTotalEvents();
    Double_t GetSheetChargeDensity(); // ??
    Double_t GetBDCOffsetX(); // mm
    Double_t GetBDCOffsetY(); // mm
    Int_t GetGGRunID();

    Double_t GetYPedestal(); // mm
    Double_t GetDriftVelocity(); // cm/us
    Double_t GetFieldOffsetX(); // cm
    Double_t GetFieldOffsetY(); // cm
    Double_t GetFieldOffsetZ(); // cm
    Double_t GetTargetZ(); // mm
    const Char_t *GetParameterFile(); // mm

    Int_t fRunID = -9999;

    // Run-wise : Key = Run#
    Bool_t fIsRunDBSet = kFALSE;
    map<Int_t, Int_t> fSystem;
    map<Int_t, Int_t> fTotalEvents;
    map<Int_t, Double_t> fSheetChargeDensity;
    map<Int_t, Double_t> fBDCOffsetX;
    map<Int_t, Double_t> fBDCOffsetY;
    map<Int_t, Int_t> fGGRun;

    // System-wise : Key = SystemID (132124, 124112, 112124, 108112)
    Bool_t fIsSystemDBSet = kFALSE;
    map<Int_t, Double_t> fYPedestal;
    map<Int_t, Double_t> fDriftVelocity;
    map<Int_t, Double_t> fFieldOffsetX;
    map<Int_t, Double_t> fFieldOffsetY;
    map<Int_t, Double_t> fFieldOffsetZ;
    map<Int_t, Double_t> fTargetZ;
    map<Int_t, TString> fParameterFile;

  ClassDef(STParameters, 1)
};

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

/mnt/spirit/analysis/user/tsangc/SpiRITROOT/ana/STMatchImQMDTask.hh:53:5: error: unknown type name 'STDigiPar'
    STDigiPar* fPar = nullptr;
    ^
In file included from input_line_12:1:
/mnt/spirit/analysis/user/tsangc/SpiRITROOT/ana/STMatchImQMDTask.cc:5:10: fatal error: 'STVectorVec.hh' file not found
#include "STVectorVec.hh"
         ^~~~~~~~~~~~~~~~
G__BaseDict dictionary payload:1366:27: error: base class has incomplete type
class FairRunAna : public FairRun
                   ~~~~~~~^~~~~~~
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairRun.h:31:7: note: definition of 'FairRun' is not complete until the closing '}'
class FairRun : public TNamed
      ^
G__BaseDict dictionary payload:1404:56: error: use of undeclared identifier 'fRootManager'
    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }
                                                       ^
G__BaseDict dictionary payload:1461:14: error: use of undeclared identifier 'fRunId'
      return fRunId;
             ^
G__BaseDict dictionary payload:1693:27: error: base class has incomplete type
class FairRunSim : public FairRun
                   ~~~~~~~^~~~~~~
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairRun.h:31:7: note: definition of 'FairRun' is not complete until the closing '}'
class FairRun : public TNamed
      ^
In file included from G__BaseDict dictionary payload:3074:
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairModule.h:169:28: error: no member named 'Instance' in 'FairRun'
  FairRun* fRun = FairRun::Instance();
                  ~~~~~~~~~^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairModule.h:170:33: error: no member named 'Instance' in 'FairRun'
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();
                       ~~~~~~~~~^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairModule.h:197:30: error: member access into incomplete type 'FairRun'
    par->setInputVersion(fRun->GetRunId(),1);
                             ^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairRun.h:31:7: note: definition of 'FairRun' is not complete until the closing '}'
class FairRun : public TNamed
      ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRun with content:

#line 1 "G__BaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef BUILD_MBS
  #define BUILD_MBS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "TSelector.h"                  // for TSelector

#include "FairLogger.h"                 // for FairLogger, MESSAGE_ORIGIN

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TSelectorList.h"              // for TSelectorList
#include "TString.h"                    // for TString
#include "TTree.h"                      // for TTree

#include <stddef.h>                     // for NULL

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;
class TString;

class FairAnaSelector : public TSelector
{
  public :
    TProofOutputFile*     fProofFile;
    TFile*                fFile;
    TTree*                fChain;   //!pointer to the analyzed TTree or TChain
    FairRunAnaProof*      fRunAna;

    FairAnaSelector(TTree* /*tree*/ =0) : fProofFile(0), fFile(0), fChain(0), fRunAna(NULL), fLogger(FairLogger::GetLogger()), fProofSource(0), fCurrentDirectory("") { }

    virtual ~FairAnaSelector() { }
    virtual Int_t   Version() const {
      return 1;
    }
    virtual void    Begin(TTree* tree);
    virtual void    SlaveBegin(TTree* tree);
    virtual void    Init(TTree* tree);
    virtual Bool_t  Notify();
    virtual Bool_t  Process(Long64_t entry);
    virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) {
      return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    virtual void    SetOption(const char* option) {
      fOption = option;
    }
    virtual void    SetObject(TObject* obj) {
      fObject = obj;
    }
    virtual void    SetInputList(TList* input) {
      fInput = input;
    }
    virtual TList*  GetOutputList() const {
      return fOutput;
    }
    virtual void    SlaveTerminate();
    virtual void    Terminate();

    void SetFairRunAnaProof(FairRunAnaProof* runAna) {
      fRunAna = runAna;
    }

  protected:
    /** Fair Logger */
    FairLogger*             fLogger;//!

  private:

    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDef(FairAnaSelector,0);
};

#endif //FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1


#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TObjArray.h"                  // for TObjArray

#include <iostream>                     // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;


/**
 * @class FairRadGridManager
 */


class FairRadGridManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     * The pointer to this object can be reached via FairRadGridManager::Instance().
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager,1);


  private:

    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;              //!
    /**track length */
    Double_t       fLength;            //!
    /** energy loss */
    Double_t       fELoss;             //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;

    static Double_t fLtmp;
  public:

    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList ( TObjArray* list ) {
      std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
      fMeshList = list;
    }
    Bool_t  IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t  IsTrackEntering(TLorentzVector& vec1,TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     */
    static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1


#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;

/**
 * @class FairRadLenManager
 */


class FairRadLenManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     * The pointer to this object can be reached via FairRadLenManager::Instance().
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager,1);


  private:

    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /** energy loss */
    Double_t       fELoss;               //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;

  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     */
    static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;
class TMap;

/**
 * @class FairRadMapManager
 */


class FairRadMapManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     * The pointer to this object can be reached via FairRadMapManager::Instance().
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager,1);


  private:

    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /** pid */
    Int_t          fPdg;                //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /**track setp */
    Double_t       fStep;
    /** energy loss */
    Double_t       fELoss;               //!
    /**dose */
    Double_t        fDose;
    Double_t       fDoseSL;
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /** radiation length*/
    Float_t        fRadl;
    /**  density */
    Float_t        fDensity;
    /**absorption length */
    Float_t        fAbsl;
    //**volume, mass */
    Double_t       fActVol;
    Double_t       fActMass;

    TMap* fMassMap;


  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     */
    static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_


#include "TObject.h"                    // for TObject

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for FairRingSorter::Class, etc

#include <iostream>                     // for operator<<, ostream, etc
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
      : TObject(), fRingBuffer(size), fOutputData(), fLowerBoundPointer(0,0),
        fCellWidth(width), fVerbose(0) {
    }

    virtual ~FairRingSorter() {};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);       ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);          ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() {
      WriteOutElements(fLowerBoundPointer.first);
    }
    virtual double GetBufferSize() {return fCellWidth * fRingBuffer.size();}
    virtual std::vector<FairTimeStamp*> GetOutputData() {
      return fOutputData;
    }

    virtual void DeleteOutputData() {fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout) {
      out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << std::endl;
      out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second << std::endl;
      out << "| ";
      for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
        out << fRingBuffer[i].size() << " |";
      }
      out << std::endl;
    }


  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*> > fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter,1)

};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairTask.h"                   // for FairTask, InitStatus

#include "FairRingSorter.h"             // for FairRingSorter

#include "Rtypes.h"                     // for Bool_t, Int_t, kTRUE, etc
#include "TString.h"                    // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:

    /** Default constructor **/
    FairRingSorterTask():
      FairTask("SorterTask"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name):
      FairTask(name),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells, Double_t widthOfCells, TString inputBranch, TString outputBranch, TString folderName):
      FairTask("Sorter"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(numberOfCells),
      fWidthOfCells(widthOfCells),
      fInputBranch(inputBranch),
      fInputArray(0),
      fOutputBranch(outputBranch),
      fFolder(folderName),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Destructor **/
    virtual ~FairRingSorterTask() {
      delete fSorter;
    }

    /** Virtual method Init **/
    virtual InitStatus Init();
    virtual InitStatus ReInit();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);
    virtual void FinishEvent();
    virtual void FinishTask();

    virtual void SetParContainers() {};

    void SetPersistance(Bool_t p = kTRUE) {fPersistance=p;};
    Bool_t GetPersistance() {return fPersistance;};

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:

    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells; // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDef(FairRingSorterTask,2);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include "TChain.h"                     // for TChain
#include "TFile.h"                      // for TFile
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator<
#include "TMCtls.h"                     // for multi-threading

#include <stddef.h>                     // for NULL
#include <list>                         // for list
#include <map>                          // for map, multimap, etc
#include <queue>                        // for queue
#include "FairSource.h"
#include <typeinfo>
#include <typeindex>
#include <vector>
#include <memory>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairGeoNode;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TArrayI;
class TBranch;
class TClonesArray;
class TCollection;
class TF1;
class TFolder;
class TList;
class TNamed;
class TTree;
class TRefArray;
class TIterator;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

//_____________________________________________________________________

class FairRootManager : public TObject
{
  public:
      /**dtor*/
    virtual ~FairRootManager();
     Bool_t             AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t               CheckBranch(const char* BrName);

    
    void                CloseOutFile() { if(fOutFile) { fOutFile->Close(); }}
    /**Create a new file and save the current TGeoManager object to it*/
    void                CreateGeometryFile(const char* geofile);
    void                Fill();
    void                LastFill();
    TClonesArray*       GetEmptyTClonesArray(TString branchName);
    TClonesArray*       GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void                UpdateBranches();

    /**Return branch name by Id*/
    TString             GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t               GetBranchId(TString const &BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList*              GetBranchNameList() {return fBranchNameList;}
    /**Return the vector of branch names that were requested by tasks as input*/
    const std::vector<std::string>& GetReqBranchNames() const {return fReqBrNames;}

      /** Return a pointer to the output Tree of type TTree */
    TTree*              GetOutTree() {return fOutTree;}
    /** Return a pointer to the output File of type TFile */
    TFile*              GetOutFile() {return  fOutFile;}
    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject*            GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t            GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject*      GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* startFunction, Double_t startParameter, BinaryFunctor* stopFunction, Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer) {fTSBufferMap[branchName] = functionalBuffer;}
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional*   GetTSBuffer(TString branchName) {return fTSBufferMap[branchName];}

    /** static access method */
    static FairRootManager* Instance();

    TFile*            OpenOutFile(const char* fname="cbmsim.root");
    TFile*            OpenOutFile(TFile* f);
    /**Read a single entry from background chain*/
    Int_t             ReadEvent(Int_t i=0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t             ReadNonTimeBasedEventFromBranches(Int_t i=0);
    /**Read the tree entry on one branch**/
    void              ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void              ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t             GetRunId();

    Bool_t            ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
    *@param name            Name of the branch to create
    *@param Foldername      Folder name containing this branch (e.g Detector name)
    *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
    *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name,const char* Foldername ,TCollection* obj, Bool_t toFile);

    
    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T* &obj, Bool_t toFile);
    /// for branches which are not managed by folders, we need a special function
    /// to trigger persistent branch creation
    /// return true if successful; false if problem
    bool CreatePersistentBranchesAny();    

    void                RegisterInputObject(const char* name, TObject* obj);

    TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void                UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries*/
    void                RunWithTimeStamps() {fTimeStamps = kTRUE;}

    /**Set the branch name list*/
    void                SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList *list);
  
    void                FillEventHeader(FairEventHeader* feh) { if ( fSource ) fSource->FillEventHeader(feh); } 
   
    /**Set the output tree pointer*/
    void                SetOutTree(TTree* fTree) { fOutTree=fTree;}

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void        SetLastFill(Bool_t val = kTRUE) { fFillLastData=val;}
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TBranch* b, TString ffn);
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TTree* fTree, const char* folderName);

    Int_t               Write(const char* name=0, Int_t option=0, Int_t bufsize=0);
    /** Write the current TGeoManager to file*/
    void                WriteGeometry();
    /**Write the file header object to the output file*/
    void                WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void                WriteFolder() ;

    /**Check the maximum event number we can run to*/
    Int_t  CheckMaxEventNo(Int_t EvtEnd=0);


    void        StoreWriteoutBufferData(Double_t eventTime);
    void        StoreAllWriteoutBufferData();
    void    DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() {return fEntryNr;}
    void SetEntryNr(Int_t val) {fEntryNr = val;}

    void SetUseFairLinks(Bool_t val) {fUseFairLinks = val;};
    Bool_t GetUseFairLinks() const {return fUseFairLinks;};

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */
   
    
    /** These methods have been moved to the FairFileSource */
    void   SetSource(FairSource* tempSource) { fSource = tempSource; }    
    FairSource* GetSource() { return fSource;}
    Bool_t InitSource();
    
    void                SetListOfFolders(TObjArray* ta){ fListFolder=ta; }
    TChain*             GetInChain ()                  { return fSourceChain;}
    TChain*             GetSignalChainNo(UInt_t i)     { return fSignalChainList[i]; }
    TTree*              GetInTree  ()                  { if ( fSourceChain ) return fSourceChain->GetTree(); return 0; }
    const TFile*        GetRootFile()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    TFile*              GetInFile  ()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    void                SetInChain (TChain* tempChain, Int_t ident=-1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE){ fFinishRun = val;}
    Bool_t FinishRun() {return fFinishRun;}

    static char* GetTreeName();
  private:

    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair {
    TypeAddressPair(const std::type_info &oi, const std::type_info &pi, void* a) : origtypeinfo(oi), persistenttypeinfo(pi), ptraddr(a) {}
      const std::type_info &origtypeinfo; // type_info of type addr points to 
      const std::type_info &persistenttypeinfo; // type_info of ROOT persistent branch (drops pointers)
      void *ptraddr; // address of a pointer (pointing to origtypeinfo);
    };
    
    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject*            ActivateBranch(const char* BrName);
    void                AddFriends( );
    /**Add a branch to memory, it will not be written to the output files*/
    void                AddMemoryBranch(const char*, TObject* );

    template<typename T>
    void AddMemoryBranchAny(const char *name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t               CheckBranchSt(const char* BrName);
        /**Create the Map for the branch persistency status  */
    void                CreatePerMap();
    TObject*            GetMemoryBranch( const char* );
 //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char *typen1, const char *typen2) const;

    Int_t       fOldEntryNr;
//_____________________________________________________________________
    /**private Members*/
    /**folder structure of output*/
    TFolder*                            fOutFolder;
    /**folder structure of input*/
    TFolder*                            fRootFolder;
    /** current time in ns*/
    Double_t                            fCurrentTime;
    /**Output file */
    TFile*                              fOutFile;
    /**Output tree */
    TTree*                              fOutTree;
    TObject**                           fObj2; //!
    /** Counter for the number of branches activiated */
    Int_t                               fNObj;//!
    /** A list which hold the pointer to the branch 
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map < TString , TObject* >     fMap;  //!

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap; //!
    /// keeps track of branches which are supposed to be persistified
    std::vector<std::string> fPersistentBranchesAny;
    
    /**Branch id for this run */
    Int_t                                fBranchSeqId;
    /**List of branch names as TObjString*/
    TList*                               fBranchNameList; //!
    /**Vector of (not necessarily unique) branch names requested per GetObject / InitObjectAs */
    std::vector<std::string>             fReqBrNames; //!
    
    /**The branch ID for the special (required) MCTrack branch**/
    Int_t                                fMCTrackBranchId; //!

    /**List of Time based branchs names as TObjString*/
    TList*                               fTimeBasedBranchNameList; //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap; //!
    std::map<TString, FairWriteoutBuffer* > fWriteoutBufferMap; //!
    std::map<Int_t, TBranch*> fInputBranchMap; //!    //Map of input branch ID with TBranch pointer
    /**if kTRUE Read data according to time and not entries*/
    Bool_t                              fTimeStamps;
    /**Flag for creation of Map for branch persistency list  */
    Bool_t                              fBranchPerMap;
    /** Map for branch persistency list */
    std::map < TString , Int_t >        fBrPerMap; //!
    /**Iterator for the fBrPerMap  Map*/
    std::map < TString, Int_t>::iterator     fBrPerMapIter;
 
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    Bool_t  fFillLastData; //!
    Int_t fEntryNr; //!

    TObjArray                           *fListFolder; //!

    FairSource                          *fSource;

    TChain                              *fSourceChain;
    std::map<UInt_t, TChain*>            fSignalChainList;//!

    FairEventHeader                     *fEventHeader;
    
    Bool_t fUseFairLinks; //!
    Bool_t fFinishRun; //!
    /** List of branches from input Chain or Tree*/
    TObjArray* fListOfBranchesFromInput; //!
    /** Iterator for the list of branches from input Chain or Tree */
    TIterator* fListOfBranchesFromInputIter;//!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray* fListOfNonTimebasedBranches; //!
    /** Iterator for the list of branches used with no-time stamp in time-based session */
    TIterator* fListOfNonTimebasedBranchesIter; //!

    ClassDef(FairRootManager,12) // Root IO manager
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj) {
  if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
    auto& ot = typeid(T*);
    auto& pt = typeid(T);
    fAnyBranchMap[brname]=std::unique_ptr<TypeAddressPair const> (new TypeAddressPair(ot, pt,(void*)obj));
  }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const {
  static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer"); 
  using P = typename std::remove_pointer<T>::type;
  auto iter = fAnyBranchMap.find(brname);
  if(iter != fAnyBranchMap.end()) {
    // verify type consistency
    if(typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
      EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
      return nullptr;
    }
    return static_cast<T>(iter->second->ptraddr);
  }
  return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T *& obj, bool persistence) {
  AddBranchToList(brname);
  if (persistence) {
    fPersistentBranchesAny.push_back(brname);
  }
  // we are taking the address of the passed pointer
  AddMemoryBranchAny<T>(brname, &obj);
}

// this function serves as a factory (or lookup) for memory managed 
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname) {
  static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer"); 
  using X = typename std::remove_pointer<TPtr>::type;
  static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
  using T = typename std::remove_const<X>::type;
  
  // is there already an object associated to the branch in memory?? 
  // then just return
  T** obj = GetMemoryBranchAny<T**>(brname);
  // obj is some address/instance holding TPtr instances
  if(obj!=nullptr) return *obj;

  // it does not seem to be the case, let us create the pointer which will be initialized
  // with the data (pointer to T)
  T** addr = new T*;
  // init the pointee to a default obj which we can return
  (*addr) = new T;
  // try to find and activate in the source
  auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

  if(!succeeded) {
    delete (*addr);
    delete addr;
    return nullptr;
  }
  // add into branch list
  AddMemoryBranchAny<T>(brname, addr);
  // register as a **requested** branch
  // (duplications are explicitely allowed)
  fReqBrNames.emplace_back(brname);
  
  // NOTE: ideally we would do proper resource management for addr and *addr
  // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
  // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
  // container which we cannot know a priori; Some solutions we could think of in the future are
  // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
  // b) investigate if boost::any could be of help here
  // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
  // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
  return *addr;
}

#endif //FAIR_ROOT_MANAGER_H

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TMCtls.h"                     // for multi-threading

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairTask;
class TFile;
class FairField;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
    * default dtor
    */
    virtual ~FairRun();
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void       AddTask(FairTask* t);
    virtual void       SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void    Init()=0;
    /*
     * Get the magnetic field *
     */
    virtual FairField*  GetField()=0;
    /**
      * run the analysis or simulation
     */
    virtual void    Run(Int_t NStart =0,Int_t NStop=0)=0;
    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void        SetEventHeader(FairEventHeader* EvHeader)  {
      fEvtHeader=EvHeader;
    }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb(void) {
      return fRtdb;
    }
    /**
     * Set the  output file name without creating the file
     */
    void SetOutputFileName(const TString& name) {
      fOutname = name;
    }
    /**
     * return a pointer to the output file
     */
    TFile* GetOutputFile() {
      return fOutFile;
    }
    /**
     * return a pointer to the output file
     */
    TString GetOutputFileName() {
      return fOutname;
    }
    /**
     * return the run ID for the actul run
     */
    Int_t  GetRunId() {
      return (static_cast<Int_t>(fRunId));
    }

	/** 
     * Set the Run ID
	 */
    void SetRunId(UInt_t runId)
	{
	  fRunId = runId; 
    }    

    /**Get the detector specific run header*/
    FairEventHeader*  GetEventHeader();
    /**
    * return true for Anaylsis session
    */
    Bool_t            IsAna() {
      return fAna;
    }
    /**
    *Get task by name
    */

    FairTask* GetTask(const char* taskName);
    /**
    *Get Main Task
    */
    FairTask* GetMainTask() {
      return fTask;
    }
    /**
    * Return the number of Tasks added to this Run
    */
    Int_t     GetNTasks() {
      return fNTasks;
    }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    //** Set if RunInfo file should be written */
    void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write;}

    //** Get info if RunInfo file is written */
    Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo;}

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster;}

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }


  private:
    FairRun(const FairRun& M);
    FairRun& operator= (const  FairRun&) {
      return *this;
    }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /** Tasks used*/
    FairTask*                fTask;
    /**Output file name*/
    TString                  fOutname;
    /**IO manager */
    FairRootManager*         fRootManager;
    /**Output file*/
    TFile*                   fOutFile;
    /**Run Id*/
    UInt_t                   fRunId;//!
    /** true for Anaylsis session*/
    Bool_t                   fAna;  //!
    /** MC Event Header */
    FairEventHeader*         fEvtHeader; //!
    /** File  Header */
    FairFileHeader*          fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t                   fGenerateRunInfo;  //!
    /** true if on master*/
    Bool_t                   fIsMaster;  //!

    Bool_t                   fMarkFill; //!

    ClassDef(FairRun ,4)
};
#endif //FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H


/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"                    // for FairRun

#include "FairRootManager.h"            // for FairRootManager
#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Bool_t, Double_t, UInt_t, etc
#include "TString.h"                    // for TString

class FairField;
class TF1;
class TFile;
class TTree;

class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:

    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void        Init();
    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void        Run(Double_t delta_t);
    /**Run for the given single entry*/
    void        Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void        RunEventReco(Int_t NStart ,Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void        RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void        DummyRun(Int_t NStart ,Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
      * it read a certain event and call the task exec, but no output is written
      * @param entry : entry number in the tree
      */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void        RunOnLmdFiles(UInt_t NStart=0, UInt_t NStop=0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void        TerminateRun();
    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */

    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }

    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource
    /**Set the input file by name*/
    void        SetInputFile(TString fname);
    /**Add a file to input chain */
    void        AddFile(TString name);
    /** Add a friend file (input) by name)*/
    void        AddFriend(TString fName);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairMixedSource
    void        SetSignalFile(TString name, UInt_t identifier );
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void        AddSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void        SetBackgroundFile(TString name);
    /**Add input background file by name*/
    void        AddBackgroundFile(TString name);
    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);
    /**
     * This method will simply forward the call to the FairRootManager,
     * if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
    */
    //    void SetMixAllInputs(Bool_t Status);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource and FairMixedSource
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the time intervall the beam is interacting and the gap in ns */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    // ********************************************************* //

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag){
        fStoreEventHeader=flag;
    }

    void        Reinit(UInt_t runId);
    UInt_t      getRunId() {
      return fRunId;
    }
    /** Get the magnetic field **/
    FairField*  GetField() {
      return fField;
    }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield ) {
      fField=ffield ;
    }
    /** Set external geometry file */
    void        SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile*      GetGeoFile() {
      return fInputGeoFile;
    }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };
    void        RunWithTimeStamps();
    Bool_t      IsTimeStamp() {
      return fTimeStamps;
    }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD( void ) {
      fFinishProcessingLMDFile = kTRUE;
    }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus( void ) {
      return fFinishProcessingLMDFile;
    }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
    **/
    virtual void Fill();

  private:

    FairRunAna(const FairRunAna& M);
    FairRunAna& operator= (const  FairRunAna&) {
      return *this;
    }

    FairRunInfo fRunInfo;//!

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    TFile*                                  fInputGeoFile;
    static FairRunAna*                      fgRinstance;
    Bool_t                                  fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;
    Bool_t                                  fTimeStamps;
    Bool_t                                  fInFileIsOpen;//!
    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** Flag for proccessing lmd-files*/
    Bool_t                                  fFinishProcessingLMDFile;  //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource*                         fFileSource;  //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource*                        fMixedSource; //!
    /** Flag for Event Header Persistency */
    Bool_t  fStoreEventHeader; //!


    ClassDef(FairRunAna ,6)

};

#endif //FAIRRUNANA_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairRunAna.h"

#include "FairFileSource.h" // FairRunAnaProof can only accept FairFileSource as source
#include "TProof.h"

class FairRunAnaProof : public FairRunAna
{

  public:

    static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName="");

    /**initialize the run manager*/
    void        Init();

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();

    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);

    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run for one event, used on PROOF nodes*/
    void        RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void        RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() {
      return fProof;
    }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) {
      fRunOnProofWorker = tb;
    }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) {
      fProofParName = parName;
    }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) {
      fOutputDirectory = dirName;
    }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) {
      fProofOutputStatus = outStat;
    }

    virtual void   SetSource(FairSource* tempSource);

  protected:
    static FairRunAnaProof*                 fRAPInstance;

    /** PROOF **/
    TProof*                                 fProof;
    /** executing on PROOF worker*/
    Bool_t                                  fRunOnProofWorker; //!
    /** PROOF server name*/
    TString                                 fProofServerName; //!
    /** PROOF ARchive (PAR) file name*/
    TString                                 fProofParName; //!
    /** Output directory*/
    TString                                 fOutputDirectory; //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString                                  fProofOutputStatus;

  private:
  
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;
    
    ClassDef(FairRunAnaProof ,1)

};

#endif //FAIRRUNANAPROOF_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairRun.h"                    // for FairRun

#include "FairIon.h"                    // for FairIon
#include "FairMCApplication.h"          // for FairMCApplication
#include "FairParticle.h"               // for FairParticle

#include "Rtypes.h"                     // for Bool_t, Double_t, Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TMCtls.h"                     // for multi-threading

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * Configure the Simulation session
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    virtual ~FairRunSim();
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
    */
    void        AddModule  (FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewIon(FairIon* ion) {fIons->Add(ion);}
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewParticle(FairParticle* Particle) {fParticles->Add(Particle);}
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefParticles();

    /**
    *       Initialize the Simulation
    */
    virtual void        Init();
    /**
    *       run the  simulation
    */
    virtual void    Run(Int_t NEvents =0, Int_t NotUsed=0);
    /**
    *       Set the magnetic that has to be used for simulation field
    */
    void        SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
    */
    void        SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void  SetMCEventHeader(FairMCEventHeader* McHeader) {fMCEvHead=McHeader;}

    /** Set the material file name to be used */
    void    SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj=kTRUE) {fStoreTraj = storeTraj;}

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode( Bool_t set ) { if (fApp) { fApp->SetTrackingDebugMode( set ); } }

    /**Set geometry builder*/
    void SetGeoModel( char* name );

    /**return the geometry loader used in this session*/
    TString* GetGeoModel () { return fLoaderName; }

    /**Get the field used in simulation*/
    FairField*  GetField() { return fField;}

    /**Get the detector specific event header*/
    FairMCEventHeader*  GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray*        GetListOfModules() { return ListOfModules;}

    /**Get the used primary generator*/
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen;}

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer = decayer;}

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config );

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) {fUserDecay = decay;}

    /**Flag for external decayer*/
    Bool_t  IsExtDecayer() {return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t  IsUserDecay() {return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) {fRadLength= value;}

    void SetRadMapRegister(Bool_t value) { fRadMap=value; }

    void SetRadGridRegister(Bool_t value) {fRadGrid= value;}

    void AddMesh (FairMesh* Mesh);

    void SetUserConfig(const TString& Config) {fUserConfig = Config;}

    void SetUserCuts(const TString& Cuts) {fUserCuts= Cuts;}

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom) {  fBeamMom= BeamMom; fUseBeamMom=kTRUE;}

    /** Get the Beam energy */
    Double_t GetBeamMom() {return fBeamMom;}

    /**Get beam energy flag */
    Bool_t UseBeamMom() {return fUseBeamMom;}
    void SetFieldContainer();
  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator= (const  FairRunSim&) {return *this;}
    void SetMCConfig();
    void CheckFlukaExec();
  protected:

    Int_t                  count;//!                               /** Internal counter*/
    FairMCApplication*     fApp;  //!                              /** Main VMC application */
    Double_t               fBeamMom; //!                           /** Beam Energy in GeV/c  */
    Bool_t                 fUseBeamMom; //!                        /** flag for use Beam Energy  */
    FairPrimaryGenerator*  fGen; //!                               /** Primary Event Generator */
    FairMCEventHeader*     fMCEvHead; //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim*  fginstance;//!              /** Singleton Instance */
    FairField*             fField;                                 /** Magnetic Field */
    const char*            fMapName; //!                           /** Input file name map*/
    TObjArray*             fIons; //!                              /** Array of user defined ions */
    TObjArray*             fParticles; //!                         /** Array of user defined particles*/
    TObjArray*             ListOfModules;//!                       /** Array of used modules */
    TString                MatFname; //!                           /** Material file name */
    Bool_t                 fStoreTraj;   //!                       /** Trajectory store flags */
    TString*               fLoaderName;  //!                       /** Geometry Model (TGeo or G3)*/
    Bool_t                 fPythiaDecayer;  //!                    /** flag for using Pythia decayer*/
    TString                fPythiaDecayerConfig; //!               /** Macro for Pythia decay configuration*/
    Bool_t                 fUserDecay;                             /** flag for setting user decay */
    TString                fUserDecayConfig; //!                   /** Macro for decay configuration*/
    Bool_t                 fRadLength;   //!                       /** flag for registring radiation length*/
    Bool_t                 fRadMap; //!                            /** flag for RadiationMapManager
    Bool_t                 fRadGrid;  //!
    TObjArray*             fMeshList; //!                          /** radiation grid scoring
    TString                fUserConfig; //!                        /** Macro for geant configuration*/
    TString                fUserCuts; //!                          /** Macro for geant cuts*/


    ClassDef(FairRunSim ,2)

};

#endif //FAIRRUNSIM_H





/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"              // for FairTimeStamp

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TObject.h"                    // for TObject
#include "TString.h"                    // for TString

#include <functional>                   // for binary_function
#include <iostream>                     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;


/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor : public std::binary_function<FairTimeStamp* ,double, bool>
{
  public :
    virtual bool operator() (FairTimeStamp* a, double b) {return Call(a,b);};
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() {return false;}
    virtual void ResetTimeOut() {};

    virtual ~BinaryFunctor() {};

};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public :
    StopTime():fRequestTime(-1), fOldTime(-1), fSameTimeRequestCounter(0) {};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) {
      fRequestTime = b;
      //std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
      return a->GetTimeStamp() > b;
    };

    bool TimeOut() {
      if (fRequestTime != fOldTime) {
        fOldTime = fRequestTime;
        fSameTimeRequestCounter = 0;
        //std::cout << "RequestedTime: " << fRequestTime << std::endl;
        return false;
      } else if (fRequestTime == fOldTime) {
        std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime << std::endl;
        fSameTimeRequestCounter++;
      } else {
        std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime << " smaller than old time " << fOldTime << std::endl;
        return true;
      }
      if (fSameTimeRequestCounter > 9) {
        return true;
      } else { return false; }
    }

    void ResetTimeOut() {fSameTimeRequestCounter = 0;}

  private :
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};



/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap():fOldTime(-1.) {};


    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) {
      double aTime = a->GetTimeStamp();

      if (fOldTime < 0) {
        fOldTime = aTime;
        return false;
      }
      if (aTime - fOldTime > b) {
        fOldTime = aTime;
        return true;
      } else {
        fOldTime = aTime;
        return false;
      }
    };


  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already exists.
 * To extract the data one has to call GetData with a parameter which fits to the selected functor.
 * GetData returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot request data which is older than the
 * data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only works if you request a fixed time
 * via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{

  public:
    FairTSBufferFunctional(TString branchName, TTree* sourceTree, BinaryFunctor* stopFunction, BinaryFunctor* startFunction = 0);

    virtual ~FairTSBufferFunctional() {};
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() {return fBranchIndex;}

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function;}
    void SetStopFunction(BinaryFunctor* function)  { fStopFunction  = function;}
    Bool_t AllDataProcessed();
    void Terminate(){ fTerminate = kTRUE; }

    Bool_t TimeOut() {
      Bool_t stopTimeOut = fStopFunction->TimeOut();
      Bool_t startTimeOut = kTRUE;
      if (fStartFunction != 0) {
        startTimeOut = fStartFunction->TimeOut();
//        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
//          fStartFunction->ResetTimeOut();
//        }
//        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
//          fStopFunction->ResetTimeOut();
//        }
      }
      return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);


  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray(); //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDef(FairTSBufferFunctional,0);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------


/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include "TTask.h"                      // for TTask

#include "FairRootManager.h"            // for FairRootManager

#include "Rtypes.h"                     // for Int_t, FairTask::Class, etc
#include "TString.h"                    // for TString

#include <map>

class FairLogger;

enum InitStatus {kSUCCESS, kERROR, kFATAL};

class FairTask : public TTask
{

  public:

    /** Default constructor **/
    FairTask();


    /** Standard constructor
    *@param name        Name of task
    *@param iVerbose    Verbosity level
    **/
    FairTask(const char* name, Int_t iVerbose = 1);


    /** Destructor **/
    virtual ~FairTask();


    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();


    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();


    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();


    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

    void SetInputPersistance(Bool_t val) {fInputPersistance = val;}

    void CheckInputPersistance(TString branchName) {
      FairRootManager* ioman = FairRootManager::Instance();
      fInputPersistance = ioman->CheckBranch(branchName);
    }

    virtual void  ExecuteTask(Option_t *option="0");  // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
    **/   
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
    **/  
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val=kTRUE) {fStreamProcessing=val;}

  protected:

    Int_t        fVerbose;  //  Verbosity level
    Int_t        fInputPersistance; ///< Indicates if input branch is persistant
    FairLogger*  fLogger; //!
    Bool_t       fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus Init() { return kSUCCESS; };


    /** Reinitialisation. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus ReInit() { return kSUCCESS; };


    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers() { };


    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish() { };


    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    virtual void  ExecuteTasks(Option_t *option);

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:

    std::map<TString, Bool_t> fOutputPersistance;

    FairTask(const FairTask&);
    FairTask& operator=(const FairTask&);

    ClassDef(FairTask,4);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TGeoTrack.h"                  // IWYU pragma: keep needed by cint
#include "TMath.h"                      // for Pi, TwoPi
#include "TString.h"                    // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */


class FairTrajFilter
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter,1);


  private:

    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t    fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* GetCurrentTrk() {return fCurrentTrk;}

    void Init(TString brName="GeoTracks", TString folderName="MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin=-2000., Double_t vyMin=-2000., Double_t vzMin=-2000.,
                      Double_t vxMax= 2000., Double_t vyMax= 2000., Double_t vzMax= 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin=  0., Double_t thetaMin=0., Double_t phiMin=0.,
                         Double_t pMax=1e10, Double_t thetaMax=TMath::Pi(),
                         Double_t phiMax=TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin=-1e10, Double_t pyMin=-1e10, Double_t pzMin=-1e10,
                         Double_t pxMax= 1e10, Double_t pyMax= 1e10, Double_t pzMax= 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin=0., Double_t ptMax=1e10,
                          Double_t rapidityMin=-1e10, Double_t rapidityMax=1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin=0., Double_t etotMax=1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim=kTRUE) {fStorePrim = storePrim;};

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec=kTRUE) {fStoreSec = storeSec;};

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin=0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin, Double_t& vyMin, Double_t& vzMin,
                      Double_t& vxMax, Double_t& vyMax, Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin, Double_t& thetaMin, Double_t& phiMin,
                         Double_t& pMax, Double_t& thetaMax, Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin, Double_t& pyMin, Double_t& pzMin,
                         Double_t& pxMax, Double_t& pyMax, Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax,
                          Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const {return fStorePrim;};

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const {return fStoreSec;};

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "TObject.h"                    // for TObject

#include "FairLogger.h"                 // for FairLogger
#include "FairRootManager.h"            // for FairRootManager
#include "FairTimeStamp.h"              // for FairTimeStamp

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TClonesArray.h"               // for TClonesArray
#include "TString.h"                    // for TString

#include <iostream>                     // for cout, ostream
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairWriteoutBuffer: public TObject
{
  public:
    FairWriteoutBuffer() : TObject(), fStartTime_map(), fDeadTime_map(), fBranchName(), fClassName(),
      fTreeSave(false), fActivateBuffering(kFALSE), fVerbose(0), fLogger(FairLogger::GetLogger()) {};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    virtual ~FairWriteoutBuffer() {};

    virtual void SaveDataToTree(Bool_t val = kTRUE) {
      fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE) {
      fActivateBuffering=val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the data is directly stored in the given TClonesArray.
    }

   Bool_t IsBufferingActivated(){ return fActivateBuffering;}
  
/// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later data, activeTime gives the time how long the data can influence later data.
/// Both time data has to be given as an absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() {
      return fDeadTime_map.size();
    }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();


    virtual void SetVerbose(Int_t val) {
      fVerbose = val;
    }

    virtual void DeleteOldData() {
      if ( fBranchName.Length() > 0 ) {
        TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
        myArray->Delete();
      }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data) = 0; ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to cast it to your type of data)
    virtual double FindTimeForData(FairTimeStamp* data) = 0;  ///< if the same data object (like a pad or a pixel) is already present in the buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0; ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(FairTimeStamp* data) = 0; ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    ///Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters are the old data with the active time, the new data with an active time.
    ///Modify returns than a vector with the new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*> > Modify(std::pair<double, FairTimeStamp*> oldData, std::pair<double, FairTimeStamp*>) {
      std::vector<std::pair<double, FairTimeStamp*> > result;
      result.push_back(oldData);
      return result;
    }


    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data) {
      std::cout << data->GetTimeStamp();
    }; ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*> > fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;  //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDef(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNONLINE_H
#define FAIRRUNONLINE_H


/**
 * Configure and manage the Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"
#include "FairRootManager.h"

#include "TString.h"
#include <iostream>

class FairRuntimeDb;
class FairField;
class TFile;
class TF1;
class TTree;
class FairSource;
class TFolder;
class THttpServer;

class FairRunOnline : public FairRun
{

  public:
    static FairRunOnline* Instance();
    virtual ~FairRunOnline();
    FairRunOnline();
    FairRunOnline(FairSource* source);

    /**initialize the run manager*/
    void        Init();
    /**Run for the given number of events*/
    void        Run(Int_t Ev_start, Int_t Ev_end);
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField*  GetField() { return fField; }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield) { fField = ffield; }

    /** Set if the run should be closed automatically after executing the
        run functuion
    **/
    void        SetAutoFinish(Bool_t val) { fAutomaticFinish = val; }
    /** Set the source which should be used **/
    void        SetSource(FairSource* source) { fRootManager->SetSource(source); }
    /** Return pointer to source **/
    FairSource*  GetSource() { return fRootManager->GetSource(); }


    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();
    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };

    /** Add histogram to be displayed using THttpServer.*/
    void AddObject(TObject* object);

    /** Activate http server on defined host port. To be called before Init.
     * @param refreshRate an interval in number of events for server update.
     * @param httpPort the port which is used by the http server
     */
    void ActivateHttpServer(Int_t refreshRate = 10000, Int_t httpPort=8080);

    /** Register a command on the http server.
     * @param name a command name starting with /
     * @param command a call to method "/object_name/->Method()"
     */
    void RegisterHttpCommand(TString name, TString command);


    /** Get direct access to the http server. */
    THttpServer* GetHttpServer() { return fServer; }

    /** Write last data to file, close input and output **/
    void Finish();

  private:

    Bool_t fAutomaticFinish;

    FairRunOnline(const FairRunOnline& M);
    FairRunOnline& operator= (const  FairRunOnline&) { return *this; }

    /** Main Event loop **/
    Int_t EventLoop();

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    static FairRunOnline*                   fgRinstance;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;

    Int_t       fNevents;      //!
    THttpServer* fServer;             //!
    Int_t        fServerRefreshRate;  //!

    virtual void Fill();

    ClassDef(FairRunOnline, 0)
};

#endif //FAIRRUNONLINE_H
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include "TObject.h"                    // for TObject
#include "TMCtls.h"                     // for multi-threading

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include <set>							// for set of branch types to ignore


class FairLogger;

//_____________________________________________________________________

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();


    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);		///< Adds a BranchId (Type) to which links are not included in the link list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);	///< Adds a BranchId (Type) to which links are included in the link list. Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const {return fIgnoreTypes;}


  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

//_____________________________________________________________________
    /**private Members*/

    std::set<Int_t> fIgnoreTypes; //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger*                         fLogger;//!


    ClassDef(FairLinkManager,1) // Root IO manager
};

#endif //FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"               // for FairContFact, etc

#include "Rtypes.h"                     // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  private:
    void setAllContainers();
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*);
    ClassDef( FairBaseContFact,0)
};

#endif  /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet

#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairBaseParSet(const char* name="FairBaseParSet",
                   const char* title="Class for base parameter io",
                   const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) {fDetList=array;}
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) {fPriGen=gen;}
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t  BMom) {fBeamMom = BMom;}
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) {fContNameList= list;}
   /**
    * Set the random seed used in a run
    * @param RndSeed: Random Seed
    */
    void SetRndSeed(UInt_t RndSeed) {fRandomSeed= RndSeed;}
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray*             GetDetList() {return fDetList;}
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator*   GetPriGen() {return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t          GetBeamMom() {return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray*             GetContList() {return fContNameList;}
   /**
    *  Get the Random Seed used in this run
    */
    UInt_t  GetRndSeed() {return fRandomSeed;}
   

  protected:

    /// Detectors used in the simulation
    TObjArray*              fDetList;
    ///Generator used for simulation
    FairPrimaryGenerator*   fPriGen;
    ///Beam momentum (GeV/c)
    Double_t              fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray*              fContNameList;
    /// Random Seed from gRandom
    UInt_t                 fRandomSeed;

    ClassDef(FairBaseParSet,6)

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator= (const FairBaseParSet&) {return *this;}



};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet
#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairGeoParSet(const char* name="FairGeoParSet",
                  const char* title="Class for base parameter io",
                  const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) {fGeoNodes=array;}
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) {fGeom=Geom;}
    /**
    *  Get the Geometry Nodes list used in the simulation
    */
    TObjArray*             GetGeoNodes() {return fGeoNodes;}
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager*           GetGeometry() {return fGeom;}

  protected:

    /// List of FairGeoNodes for sensitive volumes
    TObjArray*              fGeoNodes; //!
    /// Full Geometry
    TGeoManager*            fGeom;
    ClassDef(FairGeoParSet,1)

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator= (const FairGeoParSet&) {return *this;}



};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"                 // for FairModule

#include "Rtypes.h"                     // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{

  public:

    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId=0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void   Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits( FairVolume* v=0)=0;
    /**
      this is called at the end of an event
    */
    virtual void   EndOfEvent() {
      ;
    }
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void   Register()=0;

    /** Gets the produced collections **/
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;

    /**
      has to be called after each event to reset the containers
    */
    virtual void   Reset()=0;

    virtual void   CopyClones( TClonesArray*,  TClonesArray*, Int_t) {
      ;
    }

    virtual void   FinishPrimary() {
      ;
    }
    virtual void   FinishRun() {
      ;
    }
    virtual void   BeginPrimary() {
      ;
    }
    virtual void   PostTrack() {
      ;
    }
    virtual void   PreTrack() {
      ;
    }
    virtual void   BeginEvent() {
      ;
    }
    virtual void   FinishEvent() {
      ;
    }
    virtual void   SetSpecialPhysicsCuts() {
      ;
    }
    void SaveGeoParams();
    Int_t  GetDetId() {
      return fDetId;
    }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator= (const FairDetector&);

    Int_t fDetId; // Detector Id has to be set from ctr.
    FairLogger* fLogger;  //! /// FairLogger

    ClassDef(FairDetector,1)

};
#endif //FAIRDETECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "Rtypes.h"                     // for Bool_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
    *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    virtual ~FairGeaneApplication();
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /**
    * Set the magnetic field for simulation or Geane
    * @param field: magnetic field
    */
    void                   SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void          GeaneStepping();                           // MC Application
    void ConstructGeometry();
    /** Singelton instance
     */
    static FairGeaneApplication* Instance();

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() {;}
    void GeneratePrimaries() {;}
    void BeginEvent() {;}
    void BeginPrimary() {;}
    void PreTrack() {;}
    void PostTrack() {;}
    void FinishPrimary() {;}
    void FinishEvent() {;}
    void Stepping() {;}
    void StopRun() {;}


  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Debug flag*/
    Bool_t               fDebug;//!
    TLorentzVector fTrkPos; //!

    ClassDef(FairGeaneApplication,1)  //Interface to MonteCarlo application
  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

// inline functions

inline FairGeaneApplication* FairGeaneApplication::Instance()
{ return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------


/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/


#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, etc

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{

  public:

    /** Default constructor. **/
    FairGenerator();


    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title="FAIR Generator");


    /** Destructor. **/
    virtual ~FairGenerator();


    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;


    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE;}

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator= (const FairGenerator&);

    ClassDef(FairGenerator,1);
};

#endif


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------


/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/


#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include "TClonesArray.h" 
#include "TVirtualMCStack.h"            // for TVirtualMCStack

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TMCProcess.h"                 // for TMCProcess

#include <stddef.h>                     // for NULL

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;


class FairGenericStack : public TVirtualMCStack
{

  public:

    /** Default constructor  **/
    FairGenericStack();


    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);


    /** Destructor  **/
    virtual ~FairGenericStack();


    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is, Int_t secondparentID) = 0;


    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}


    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* detArray=0) {}


    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger*  fLogger;//!

    /** List of detectors registering hits in the simulation */
    TRefArray*  fDetList;  //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    ClassDef(FairGenericStack,1)
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/


#ifndef FAIRION_H
#define FAIRION_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, etc

class FairLogger;

class FairIon: public TNamed
{
  public:

    /** Default constructor **/
    FairIon();


    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e=0., Double_t m=0.);
    void SetParams( const char* name, Int_t z, Int_t a,
                    Int_t q, Double_t e=0., Double_t m=0.) {
      SetName(name);
      fZ=z;
      fA=a;
      fQ=q;
      fExcEnergy=e;
      fMass=m;
    }
    /** Destructor **/
    virtual ~FairIon();


    /** Accessors **/
    /**
    * Return the atomic number
    */
    Int_t GetZ()            const { return fZ; }
    /**
     * Return the atomic mass
    */
    Int_t GetA()            const { return fA; }
    /**
     * Return the charge
    */
    Int_t GetQ()            const { return fQ; }
    /**
    * Return the  excitation energy
    */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
    * Return the mass in GeV
    */
    Double_t GetMass()      const { return fMass; }

    /** Modifiers **/
    /**
    * Set the  excitation energy
    */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
    * Set the mass in GeV
    */
    void SetMass(Double_t mass)      { fMass = mass*amu; }


  private:

    /** Data members **/

    static Int_t fgNIon;  //! /// Number of ions instantiated. One per generator.
    Int_t    fZ;          /// Atomic number
    Int_t    fA;          /// Atomic mass
    Int_t    fQ;          /// Electric charge
    Double_t fExcEnergy;  /// Excitation energy [GeV]
    Double_t fMass;       /// Mass [GeV]
    FairLogger* fLogger;  //! /// FairLogger
    static const Double_t amu; ///  .931494028 Gev/c**2

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon,2);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TString.h"                    // for TString

#include <map>                           // for map, multimap, etc
#include <list>                           // for list

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadGridManager;
class FairRadLenManager;
class FairRadMapManager;
class FairGenericRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;
/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
    *@param name      name
    *@param title     title
    *@param ModList  a TObjArray containing all detectors and modules used in this simulation
    *@param MatName  material file name
    */
    FairMCApplication(const char* name,   const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
    */
    FairMCApplication();
    /** default destructor
    */
    virtual ~FairMCApplication();
    /** Singelton instance
    */
    static FairMCApplication* Instance();
    virtual void          AddDecayModes();
    /**  Add user defined particles (optional) */
    virtual void          AddParticles();                                   // MC Application
    /** Add user defined ions (optional) */
    virtual void          AddIons();                                        // MC Application
    /**
    *Add user defined Tasks to be executed after each event (optional)
    * @param fTask: Task that has to be excuted during simulation
    */
    void                  AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    virtual void          BeginEvent();                                     // MC Application
    /** Define actions at the beginning of primary track */
    virtual void          BeginPrimary();                                   // MC Application
    /** Construct user geometry */
    virtual void          ConstructGeometry();                              // MC Application
    /** Define parameters for optical processes (optional) */
    virtual void          ConstructOpGeometry();                            // MC Application
    /** Define actions at the end of event */
    virtual void          FinishEvent();                                    // MC Application
    /** Define actions at the end of primary track */
    virtual void          FinishPrimary();                                  // MC Application
    /** Define actions at the end of run */
    void                  FinishRun();
    /** Generate primary particles */
    virtual void          GeneratePrimaries();                              // MC Application
    /** Return detector by name  */
    FairDetector*          GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /**Return primary generator*/
    FairPrimaryGenerator*  GetGenerator();
    /**Return list of tasks*/
    TTask*                GetListOfTasks();
    FairGenericStack*      GetStack();
    TChain*               GetChain();
    /** Initialize geometry */
    virtual void          InitGeometry();                                   // MC Application
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /** Initialize Tasks if any*/
    void                  InitTasks();
    /**Define actions at the end of each track */
    virtual void          PostTrack();                                      // MC Application
    /** Define actions at the beginning of each track*/
    virtual void          PreTrack();                                       // MC Application

    /** Clone for worker (used in MT mode only) */
    virtual TVirtualMCApplication* CloneForWorker() const;

    /** Init application on worker (used in MT mode only) */
    virtual void InitOnWorker();

    /** Finish run on worker (used in MT mode only) */
    virtual void FinishRunOnWorker();

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void                  RunMC(Int_t nofEvents);
    /**
    * Set the magnetic field for simulation
    * @param field: magnetic field
    */
    void                  SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void                  SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void                  SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see SetPythiaDecayerConfig)
     */
    void                  SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer=decayer;}
    /**
    * set the decay configuration macro to be used by Pythia
    */
    void                  SetPythiaDecayerConfig(const TString decayerConf) {fPythiaDecayerConfig=decayerConf;}
    /**
    * Switch for using the radiation length manager
    */
    void                  SetRadiationLengthReg(Bool_t RadLen);
    /**
    * Switch for using the radiation map manager
    */
    void                  SetRadiationMapReg(Bool_t RadMap);
    /**
    * Switch for debuging the tracking
    */
    void                  SetTrackingDebugMode( Bool_t set ) {fDebug = set;}
    /**
    * Switch for using 2 or 3 body phase-space decay
    * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config macro (see SetUserDecayConfig)
    */
    void                  SetUserDecay(Bool_t decay) {fUserDecay= decay;}
    /**
    * set the decay configuration macro to be used by user decay
    */
    void                  SetUserDecayConfig(const TString decayerConf) {fUserDecayConfig= decayerConf;}
    /** Define action at each step, dispatch the action to the corresponding detectors */
    virtual void          Stepping();                                       // MC Application
    /** Stop the run*/
    virtual void          StopRun();
    /**Define maximum radius for tracking (optional) */
    virtual Double_t      TrackingRmax() const;                             // MC Application
    /** Define maximum z for tracking (optional) */
    virtual Double_t      TrackingZmax() const;                              // MC Application

    void AddMeshList ( TObjArray* meshList );

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

    // data members
    /**List of active detector */
    TRefArray*           fActiveDetectors;
    /**List of FairTask*/
    FairTask*             fFairTaskList;//!
    /**detector list (Passive and Active)*/
    TRefArray*           fDetectors;
    /**Map used for dispatcher*/
    TRefArray*           fDetMap;
    /**Iterator for Module list*/
    TIterator*           fModIter; //!
    /**Module list in simulation*/
    TObjArray*           fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t                fNoSenVolumes; //!
    /**flag for using Pythia as external decayer */
    Bool_t               fPythiaDecayer;
    /** Pythia decay config macro*/
    TString               fPythiaDecayerConfig; //!
    /** Simulation Stack  */
    FairGenericStack*     fStack; //!
    /**Pointer to thr I/O Manager */
    FairGenericRootManager*  fRootManager; //!
    /**List of sensetive volumes in all detectors*/
    TRefArray*           fSenVolumes; //!
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Track visualization manager */
    FairTrajFilter*       fTrajFilter; //!
    /**Flag for accepted tracks for visualization*/
    Bool_t               fTrajAccepted; //!
    /**Flag for using user decay*/
    Bool_t               fUserDecay;
    /**User decay config macro*/
    TString               fUserDecayConfig; //!
    /** Debug flag*/
    Bool_t               fDebug;//!
    /**dispatcher internal use */
    FairVolume*          fDisVol;
    /**dispatcher internal use */
    FairDetector*         fDisDet;
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* > fVolMap;//!
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* >::iterator fVolIter; //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map <Int_t, Int_t > fModVolMap;//!
    /**dispatcher internal use RadLen*/
    std::map <Int_t, Int_t >::iterator fModVolIter; //!
    TLorentzVector fTrkPos; //!
    /** Flag for Radiation length register mode  */
    Bool_t   fRadLength;  //!

    /**Radiation length Manager*/
    FairRadLenManager*  fRadLenMan; //!
    /** Flag for Radiation map register mode  */
    Bool_t   fRadMap;     //!
    /**Radiation Map Manager*/
    FairRadMapManager*  fRadMapMan; //!
    /**Radiation map Grid Manager*/
    FairRadGridManager* fRadGridMan; //!

    FairEventHeader*    fEventHeader; //!

    FairMCEventHeader*  fMCEventHeader; //!
    /** list of senstive detectors used in the simuation session*/
    std::list <FairDetector *> listActiveDetectors; //!
    /** list of all detectors used in the simuation session*/
    std::list <FairDetector *> listDetectors;  //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC*  fMC;
    /** Pointer to FairRunSim //! */
    FairRunSim*  fRun;
    
    ClassDef(FairMCApplication,4)  //Interface to MonteCarlo application

  private:
    /** Protected copy constructor */
    FairMCApplication(const FairMCApplication&);
    /** Protected assignment operator */
    FairMCApplication& operator=(const FairMCApplication&);

    FairRunInfo fRunInfo;//!
    Bool_t      fGeometryIsInitialized;

    static FairMCApplication* fgMasterInstance;
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{ return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoInterface.h"           // for FairGeoInterface
#include "FairGeoLoader.h"              // for FairGeoLoader
#include "FairGeoNode.h"                // for FairGeoNode
#include "FairGeoVolume.h"              // for FairGeoVolume
#include "FairLogger.h"                 // for FairLogLevel::INFO, etc
#include "FairRun.h"                    // for FairRun
#include "FairRuntimeDb.h"              // for FairRuntimeDb

#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TList.h"                      // for TList (ptr only), TListIter
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator!=

#include <stddef.h>                     // for NULL
#include <string>                       // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TGeoMedium;
class TRefArray;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule:  public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active=kFALSE);
    /**default dtor*/
    virtual  ~FairModule();
    /**Print method should be implemented in detector or module*/
    virtual void        Print(Option_t*) const {;}
    /**Set the geometry file name o be used*/
    virtual void        SetGeometryFileName(TString fname, TString geoVer="0");
    /**Get the Geometry file name*/
    virtual TString     GetGeometryFileName() {return  fgeoName ;}
    /**Get the geometry file version if used*/
    virtual TString     GetGeometryFileVer() {return   fgeoVer ;}
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void        ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void        ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void        ConstructRootGeometry();
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void        ConstructASCIIGeometry();
    /** Modify the geometry for the simulation run using methods of the Root geometry package */
    virtual void        ModifyGeometry() {;}
    /**construct geometry from GDML files*/
    virtual void        ConstructGDMLGeometry(TGeoMatrix*);
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const {;}
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const {;}

    /**template function to construct geometry. to be used in derived classes.*/
    template<class T, class U>
    void ConstructASCIIGeometry(T dataType1, TString containerName="", U datatype2 = NULL);

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for detectors
     * which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t      CheckIfSensitive(std::string name);
    /**called from ConstructRootGeometry()*/
    virtual void        ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void        ExpandNodeForGDML(TGeoNode*);
    /**return the MC id of a volume named vname*/
    virtual Int_t       getVolId( const TString& ) const {return 0;}
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t               GetModId() {return fModId;}
    /**Set the verbose level in this detector*/
    void                SetVerboseLevel(Int_t level) {fVerboseLevel=level;}
    /**return the detector status */
    Bool_t              IsActive() {return fActive;}
    /**set the detector/module id*/
    void                SetModId(Int_t id) {fModId=id;}
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void                SetMotherVolume(TString volName) {fMotherVolumeName=volName;}
    /**called from ConstuctASCIIGeometry*/
    void   ProcessNodes ( TList* aList );
    /**Set the parameter containers*/
    virtual  void       SetParContainers() {;}
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual  void       InitParContainers() {;}
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar;}

    /**list of volumes in a simulation session*/
    static              FairVolumeList*   vList; //!
    /**total number of volumes in a simulaion session*/
    static Int_t        fNbOfVolumes;  //!
    /**list of all sensitive volumes in  a simulaion session*/
    static TRefArray*   svList;   //!

    static TArrayI*     volNumber; //!
    TString             fMotherVolumeName; //!
    FairVolume*   getFairVolume(FairGeoNode* fNode);
    void    AddSensitiveVolume(TGeoVolume* v);
  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);  // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString             fgeoVer;
    TString             fgeoName;
    Int_t               fModId;
    Bool_t              fActive;
    Int_t               fNbOfSensitiveVol; //!
    Int_t               fVerboseLevel;
    TList*              flGeoPar; //!  list of Detector Geometry parameters
    Bool_t              kGeoSaved; //! flag for initialisation

    ClassDef( FairModule,4)
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T dataType1, TString containerName, U)
{
  FairGeoLoader* loader=FairGeoLoader::Instance();
  FairGeoInterface* GeoInterface =loader->getGeoInterface();
  T* MGeo=new T();
  MGeo->print();
  MGeo->setGeomFile(GetGeometryFileName());
  GeoInterface->addGeoModule(MGeo);
  Bool_t rc = GeoInterface->readSet(MGeo);
  if ( rc ) { MGeo->create(loader->getGeoBuilder()); }

  TList* volList = MGeo->getListOfVolumes();
  // store geo parameter
  FairRun* fRun = FairRun::Instance();
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();

  dataType1 = *MGeo;

  if ( "" != containerName) {
    LOG(INFO) << "Add GeoNodes for "<< MGeo->getDescription()
              << " to container " << containerName << FairLogger::endl;

    //    U par=(U)(rtdb->getContainer(containerName));
    U*      par=static_cast<U*>(rtdb->getContainer(containerName));
    TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
    TObjArray* fPassNodes = par->GetGeoPassiveNodes();

    TListIter iter(volList);
    FairGeoNode* node   = NULL;
    FairGeoVolume* aVol=NULL;

    while( (node = static_cast<FairGeoNode*>(iter.Next())) ) {
      aVol = dynamic_cast<FairGeoVolume*> ( node );
      if ( node->isSensitive()  ) {
        fSensNodes->AddLast( aVol );
      } else {
        fPassNodes->AddLast( aVol );
      }
    }
    ProcessNodes( volList );
    par->setChanged();
    par->setInputVersion(fRun->GetRunId(),1);

  }
}


#endif //FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, Double_t, Bool_t, etc
#include "TMCParticleType.h"            // for TMCParticleType
#include "TRef.h"                       // for TRef
#include "TRefArray.h"                  // for TRefArray
#include "TString.h"                    // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name, Int_t z, Int_t a, Int_t s,Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle( Int_t pdg , const TString name, TMCParticleType mcType, Double_t mass, Double_t charge,
                  Double_t lifetime, const TString pType="Ion",  Double_t width=0, Int_t iSpin=0, Int_t iParity=0,
                  Int_t iConjugation=0, Int_t iIsospin=0, Int_t iIsospinZ=0, Int_t gParity=0, Int_t lepton=0,
                  Int_t baryon=0,Bool_t stable=kFALSE);

    FairParticle();

    virtual ~FairParticle();

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    virtual void  Print(Option_t* option = "") const;
    void PrintDaughters() const;

    // get methods
    Int_t            GetPDG() const;
    TParticle*       GetParticle() const;
    FairParticle*     GetMother() const;
    Int_t            GetNofDaughters() const;
    FairParticle*     GetDaughter(Int_t i) const;
    virtual const char* GetName() const {return fname.Data();}
    TMCParticleType  GetMCType()  {return fmcType;}
    Double_t         GetMass()          {return fmass;}
    Double_t         GetCharge()        {return fcharge;}
    Double_t         GetDecayTime()     {return fDecayTime;}
    const TString&   GetPType()         {return fpType;}
    Double_t         GetWidth()         {return fwidth;}
    Int_t            GetSpin()          {return fiSpin;}
    Int_t            GetiParity()        {return fiParity;}
    Int_t            GetConjugation()   {return fiConjugation;}
    Int_t            GetIsospin()       {return fiIsospin;}
    Int_t            GetIsospinZ()      {return fiIsospinZ;}
    Int_t            GetgParity()        {return fgParity;}
    Int_t            GetLepton()        {return flepton;}
    Int_t            GetBaryon()        {return fbaryon;}
    Bool_t           IsStable()         {return fstable;}

  private:

    FairParticle(const FairParticle& P);
    FairParticle& operator= (const  FairParticle&) {return *this;}
    // data members
    Int_t     fpdg;
    TParticle*    fParticle;
    TRef          fMother;
    TRefArray     fDaughters;
    const TString            fname;
    TMCParticleType   fmcType;
    Double_t    fmass;
    Double_t    fcharge;
    Double_t    fDecayTime;
    const TString   fpType;
    Double_t    fwidth;
    Int_t     fiSpin;
    Int_t     fiParity;
    Int_t     fiConjugation;
    Int_t     fiIsospin;
    Int_t     fiIsospinZ;
    Int_t     fgParity;
    Int_t     flepton;
    Int_t     fbaryon;
    Bool_t    fstable;

    ClassDef(FairParticle,3) // Extended TParticle
};

#endif //FAIR_PARTICLE_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3, *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "TNamed.h" // for TNamed

#include "FairGenerator.h" // for FairGenerator

#include <iosfwd>      // for ostream
#include "Rtypes.h"    // for Double_t, Bool_t, Int_t, etc
#include "TObjArray.h" // for TObjArray
#include "TVector3.h"  // for TVector3
#include "TMCProcess.h"

#include <iostream> // for operator<<, basic_ostream, etc

class FairGenericStack;
class FairMCEventHeader;
class TF1;
class TIterator;

class FairPrimaryGenerator : public TNamed {

public:
  /** Default constructor. **/
  FairPrimaryGenerator();

  /** Constructor with name and title **/
  FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

  /** Destructor. **/
  virtual ~FairPrimaryGenerator();

  /** Initialize the generater (if needed!)*/
  virtual Bool_t Init();

  /** Register a generator derived from FairGenerator.  **/
  void AddGenerator(FairGenerator *generator) {
    if (!fGenList) {
      std::cout << "Empty fGenList pointer ! " << std::endl;
      return;
    }
    fGenList->Add(generator);
  }

  /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
  virtual Bool_t GenerateEvent(FairGenericStack *pStack);

  /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
  virtual void AddTrack(Int_t pdgid, Double_t px, Double_t py, Double_t pz,
                        Double_t vx, Double_t vy, Double_t vz,
                        Int_t parent = -1, Bool_t wanttracking = true,
                        Double_t e = -9e9, Double_t tof = 0.,
                        Double_t weight = 0., TMCProcess proc = kPPrimary);

  /** Clone this object (used in MT mode only) */
  virtual FairPrimaryGenerator* ClonePrimaryGenerator() const;

  /** Set beam position and widths.
   *@param beamX0      mean x position of beam at target
   *@param beamY0      mean y position of beam at target
   *@param beamSigmaX  Gaussian beam width in x
   *@param beamSigmaY  Gaussian beam width in y
   **/
  void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX,
               Double_t beamSigmaY);

  /** Set nominal beam angle and angle widths.
   *@param beamAngleX0      mean x angle of beam at target
   *@param beamAngleY0      mean y angle of beam at target
   *@param beamAngleSigmaX  Gaussian beam angle width in x
   *@param beamAngleSigmaY  Gaussian beam angle width in y
   **/
  void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0,
                    Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

  /** Public method SetEventPlane
   **@param phiMin   Lower limit for event plane angle [rad]
   **@param phiMax   Upper limit for event plane angle [rad]
   **If set, an event plane angle will be generated with flat
   **distrtibution between phiMin and phiMax.
   **/
  void SetEventPlane(Double_t phiMin, Double_t phiMax);

  /** Set target position and thickness.
   *@param targetZ   z position of target center
   *@param targetDz  full target thickness
   **/
  void SetTarget(Double_t targetZ, Double_t targetDz);

  /** Set target position for multiple tagets. The thickness
   * is the same for all targets.
   *@param nroftargets   number of targets
   *@param *targetZ      z positions of target center
   *@param targetDz      full target thickness
   **/
  void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

  /** Enable vertex smearing in z and/or xy direction **/
  void SmearVertexZ(Bool_t flag);
  void SmearGausVertexZ(Bool_t flag);
  void SmearVertexXY(Bool_t flag);
  void SmearGausVertexXY(Bool_t flag);

  TObjArray *GetListOfGenerators() { return fGenList; }

  /** Set the pointer to the MCEvent **/
  void SetEvent(FairMCEventHeader *event) {
    fEvent = event;
  };

  /** Accessor to the MCEvent **/
  FairMCEventHeader *GetEvent() {
    return fEvent;
  };

  /** Swich on/off the tracking of a particle*/

  void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

  Int_t GetTotPrimary() { return fTotPrim; }

protected:
  /**  Copy constructor */
  FairPrimaryGenerator(const FairPrimaryGenerator&);
  /**  Assignment operator */
  FairPrimaryGenerator &operator=(const FairPrimaryGenerator&);

  /**  Nominal beam position at target in x [cm] */
  Double_t fBeamX0;
  /** Nominal beam position at target in y [cm]*/
  Double_t fBeamY0;
  /** Beam width (Gaussian) in x [cm]*/
  Double_t fBeamSigmaX;
  /**  Beam width (Gaussian) in y [cm]*/
  Double_t fBeamSigmaY;

  /**  Nominal beam angle at target in x [rad] */
  Double_t fBeamAngleX0;
  /**  Nominal beam angle at target in y [rad] */
  Double_t fBeamAngleY0;
  /**  Actual beam angle at target in x [rad] */
  Double_t fBeamAngleX;
  /**  Actual beam angle at target in y [rad] */
  Double_t fBeamAngleY;
  /** Beam angle width (Gaussian) in x [rad]*/
  Double_t fBeamAngleSigmaX;
  /** Beam angle width (Gaussian) in y [rad]*/
  Double_t fBeamAngleSigmaY;
  /** Actual beam direction at the vertex */
  TVector3 fBeamDirection;

  /** Lower limit for the event plane rotation angle [rad] */
  Double_t fPhiMin;
  /** Upper limit for the event plane rotation angle [rad] */
  Double_t fPhiMax;
  /** Actual event plane rotation angle [rad] */
  Double_t fPhi;

  /**  Nominal z position of center of targets [cm]*/
  Double_t *fTargetZ; //!
  /**  Number of targets;*/
  Int_t fNrTargets;
  /**  Full target thickness [cm]*/
  Double_t fTargetDz;

  /** Vertex position of current event [cm]*/
  TVector3 fVertex;

  /** Number of primary tracks in current event*/
  Int_t fNTracks;

  /**  Flag for uniform vertex smearing in z*/
  Bool_t fSmearVertexZ;
  /**  Flag for gaus vertex smearing in z*/
  Bool_t fSmearGausVertexZ;
  /**  Flag for vertex smearing in xy*/
  Bool_t fSmearVertexXY;
  /**  Flag for gaus vertex smearing in xy*/
  Bool_t fSmearGausVertexXY;
  /**  Flag for beam gradient calculation*/
  Bool_t fBeamAngle;
  /**  Flag for event plane rotation*/
  Bool_t fEventPlane;

  /**  Pointer to MC stack*/
  FairGenericStack *fStack; //!
  /**  List of registered generators */
  TObjArray *fGenList;
  /**  Iterator over generator list */
  TIterator *fListIter; //!
  /**  Pointer to MCEventHeader */
  FairMCEventHeader *fEvent; //!
  /** go to tracking  */
  Bool_t fdoTracking; //!
  /** Number of MC tracks before a Generator is called, needed for MC index
   * update */
  Int_t fMCIndexOffset; //!
  /** Number of all primaries of this run*/
  static Int_t fTotPrim; //!
  /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
  Int_t fEventNr;

  /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
  void MakeVertex();

  /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
  void MakeBeamAngle();

  /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
  void MakeEventPlane();

  ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairGenericRootManager.h
/// \brief Definition of the FairGenericRootManager class
///
/// TVirtualMCRootManager class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairGenericRootManager
#define ROOT_FairGenericRootManager

#include "TObject.h"
#include "TMCtls.h"

class FairWriteoutBuffer;
class FairRootManager;
class TClonesArray; 

/// \brief The interface to the Root IO manager for FairRoot multi-threaded applications.
///
/// Implemented according to TVirtualMCRootManager from Geant4 VMC.

class FairGenericRootManager : public TObject
{
  public:
    FairGenericRootManager();
    virtual ~FairGenericRootManager();     
  
    // static access method
    static FairGenericRootManager* Instance(); 
    
    // static method for activating debug mode
    static void SetDebug(Bool_t debug); 
    static Bool_t GetDebug();

    // methods
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile) = 0;
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile) = 0;
    virtual void                RegisterInputObject(const char* name, TObject* obj) = 0;
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile) = 0;
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer) = 0;

    virtual void  Fill() = 0;
    virtual void  Write() = 0;
    virtual void  CloseOutFile() = 0;
    // virtual void  WriteAndClose() = 0;

    virtual Int_t               GetBranchId(TString const &BrName) = 0;


    // access to the implementation class
    virtual FairRootManager*    GetFairRootManager() const = 0;
    virtual Int_t  GetId() const = 0;
    
    // static data members
    static  Bool_t  fgDebug; // Option to activate debug printings

  private:
    // not implemented
    FairGenericRootManager(const FairGenericRootManager& rhs);
    FairGenericRootManager& operator=(const FairGenericRootManager& rhs);
    
#if !defined(__CINT__)
    static  TMCThreadLocal FairGenericRootManager* fgInstance; // singleton instance
#else
    static                 FairGenericRootManager* fgInstance; // singleton instance
#endif 
};

// inline functions

inline void FairGenericRootManager::SetDebug(Bool_t debug) {
  fgDebug = debug;
}  
  
inline Bool_t FairGenericRootManager::GetDebug() {
  return fgDebug;
}  

#endif //ROOT_FairGenericRootManager
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairRootManagerSim.h
/// \brief Definition of the FairRootManagerSim class
///
/// TMCRootManager class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairRootManagerSim
#define ROOT_FairRootManagerSim

#include "FairGenericRootManager.h"

#include <vector>

class FairRootManager;
class FairWriteoutBuffer;
class TClonesArray; 

/// \brief The Root IO manager for FairRoot multi-threaded applications.
///
/// Implemented according to TMCRootManager from Geant4 VMC.
/// It implements the FairGenericRootManager interface.

class FairRootManagerSim : public FairGenericRootManager
{
  public:
    FairRootManagerSim();
    virtual ~FairRootManagerSim();     
  
    // methods
    // virtual void  Register(const char* name, const char* className, void* objAddress);
    // virtual void  Register(const char* name, const char* className, const void* objAddress);
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile);
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile);
    virtual void                RegisterInputObject(const char* name, TObject* obj);
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);

    virtual void  Fill();
    virtual void  Write();
    virtual void  CloseOutFile();

    virtual Int_t GetBranchId(TString const &BrName);

    virtual FairRootManager*    GetFairRootManager() const { return fRootManager; }
    virtual Int_t  GetId() const { return 0; }

  private:
    // not implemented
    FairRootManagerSim(const FairRootManagerSim& rhs);
    FairRootManagerSim& operator=(const FairRootManagerSim& rhs);

    // data members 
    FairRootManager*  fRootManager;  // The Root manager
};

#endif //ROOT_FairRootManagerSim
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairRootManagerSimMT.h
/// \brief Definition of the FairRootManagerSimMT class
///
/// TMCRootManagerMT class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairRootManagerSimMT
#define ROOT_FairRootManagerSimMT

#include "FairGenericRootManager.h"

#include <vector>

class FairRootManager;
class FairWriteoutBuffer;
class TClonesArray; 

/// \brief The Root IO manager for VMC examples for multi-threaded applications.
///
/// Implemented according to TMCRootManager from Geant4 VMC.
/// It implements the FairGenericRootManager interface.

class FairRootManagerSimMT : public FairGenericRootManager
{
  public:
    FairRootManagerSimMT();
    virtual ~FairRootManagerSimMT();     
  
    // methods
    // virtual void  Register(const char* name, const char* className, void* objAddress);
    // virtual void  Register(const char* name, const char* className, const void* objAddress);
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile);
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile);
    virtual void                RegisterInputObject(const char* name, TObject* obj);
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);

    virtual void  Fill();
    virtual void  Write();
    virtual void  CloseOutFile();

    virtual Int_t GetBranchId(TString const &BrName);

    virtual FairRootManager*    GetFairRootManager() const { return fRootManager; }
    virtual Int_t  GetId() const { return fId; }

  private:
    // not implemented
    FairRootManagerSimMT(const FairRootManagerSimMT& rhs);
    FairRootManagerSimMT& operator=(const FairRootManagerSimMT& rhs);
    
    // methods
    void  LogMessage(const TString& message);
    void  FillWithLock();
    void  FillWithTmpLock();
    void  FillWithoutLock();

    // global static data members
    static  Int_t    fgCounter;         // The counter of instances
    static  Bool_t   fgIsFillLock;      // The if the Fill should be locked 
    static  std::vector<Bool_t>* fgIsFillLocks; // The info per thread if the Fill should be locked

    // data members 
    Int_t             fId;           // This manager ID 
    FairRootManager*  fRootManager;  // The Root manager
};

#endif //ROOT_FairRootManagerSimMT
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>               // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char      uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned char      uuid_t[16];

class FairRunIdGenerator
{
    struct uuid {
      uint32_t time_low;
      uint16_t time_mid;
      uint16_t time_hi_and_version;
      uint16_t clock_seq;
      uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);
  public:
    struct timespec getTimeSpec() {return fTimeSpec;}
    struct timespec getTimeSpecFromTID( unsigned  int ms);
    unsigned  int getTID();

  public:
    FairRunIdGenerator() : fTimeSpec() {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);



};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairVolume::Class, etc
#include "TString.h"                    // for TString
#include "FairModule.h"
#include "FairDetector.h"
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */


class FairVolume : public TNamed
{

  public:

    FairVolume();
    FairVolume(TString name, Int_t id=0, Int_t detid=0,FairModule* fMod=0);
    virtual ~FairVolume();

    //    const char*  GetName() { return fName.Data();}
    //    TString getName() { return fName;}

    void setRealName( TString name ) { fRealName = name;}
    const char* getRealName() { return fRealName.Data();}
    Int_t getVolumeId() { return fVolumeId;}
    Int_t getModId() { return  fModId;}
    void  setModId(Int_t id) { fModId=id;}
    void  setCopyNo(Int_t id) { fCopyNo=id;}
    void  setVolumeId ( Int_t id ) {fVolumeId= id;}
    void  setGeoNode(FairGeoNode* d) {fNode=d;}
    void  setMotherId(Int_t fM) {fMotherId=fM;}
    void  setMotherCopyNo(Int_t CopyNo) {fMotherCopyNo=CopyNo;}

    FairModule*   GetModule()     {return fModule;}
    FairDetector* GetDetector() { return fDetector;}
    void SetModule(FairModule* mod) {
        fModule=mod;
        if (mod->InheritsFrom("FairDetector")){
           fDetector=dynamic_cast<FairDetector *>(mod);
        }
    }

    Int_t getMCid() {return fMCid;}
    Int_t getCopyNo() { return fCopyNo;}
    void  setMCid(Int_t id) {fMCid=id;}
    FairGeoNode* getGeoNode() {return fNode;}
    Int_t getMotherId() { return fMotherId;}
    Int_t getMotherCopyNo() {return fMotherCopyNo;}


  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    //    TString fName;   /**Volume Name in MC*/
    TString fRealName; /**Volume Name in ASCII file*/
    Int_t fVolumeId;       /**Volume Id in GeoManager*/
    Int_t fModId;          /**Module Id in which this volume exist*/
    Int_t fMCid;   /**Volume Id in MC*/
    Int_t fCopyNo;         /**Volume Copy No*/
    Int_t fMotherId; /**Mother Volume Id*/
    Int_t fMotherCopyNo;   /**Mother Volume Copy No*/
    FairDetector* fDetector; /** The Detector which will proccess the hits for this volume*/
    FairModule*   fModule;    /**The Module in which the volume is */
    FairGeoNode*  fNode;     /**Node corresponding to this volume*/
    

    ClassDef(FairVolume,2) // Volume Definition

};

#endif //
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "TObject.h"                    // for TObject

#include "FairVolume.h"

#include "Rtypes.h"                     // for Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

//class FairVolume;

/**
* This Object is only used for internal book keeping!
* @author M. Al-Turany, D. Bertini
* @version 0.1
* @since 12.01.04
*/

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume( TString* name );
    Int_t getVolumeId( TString* name );

    FairVolume* findObject( TString name );
    void addVolume( FairVolume* elem);

    Int_t getEntries () { return fData->GetEntries();}
    FairVolume* At(Int_t pos ) { return ( dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList,1) // Volume List
};

#endif //FAIR_VOLUMELIST_H


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/


#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairWriteoutBuffer.h"
#include "FairRecoEventHeader.h"

#include "TStopwatch.h"
#include "TString.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;
//class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{


  public :

    /** Default constructor **/
    FairEventBuilder();


    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);


    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*> > FindEvents() = 0;
    virtual void          StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void  SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }
    Int_t GetIdentifier() {
      return fIdentifier;
    }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t *option="") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() {
      return fMaxAllowedEventCreationTime;
    };
    void SetMaxAllowedTime(Double_t td) {
      fMaxAllowedEventCreationTime = td;
    };

    void    SetBuilderName(const char* name) {
      fBuilderName=name;
    }
    TString GetBuilderName() {
      return fBuilderName;
    }

  private:

    TString    fBuilderName;

    TStopwatch fTimer;
    Double_t   fExecTime;

    Int_t      fIdentifier;
    Double_t   fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/


#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairTask.h"
#include "FairEventBuilder.h"

#include "TStopwatch.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{


  public :

    /** Default constructor **/
    FairEventBuilderManager();


    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose=1);


    /** Destructor **/
    virtual ~FairEventBuilderManager();


    /** Execution **/
    virtual void Exec(Option_t* opt);


    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:

    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double,FairRecoEventHeader*> > >  fPossibleEvents;


    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();


    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;


    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:

    /** Get parameter containers **/
    virtual void SetParContainers();


    /** Intialisation **/
    virtual InitStatus Init();


    /** Reinitialisation **/
    virtual InitStatus ReInit();


    /** Finish at the end of each event **/
    virtual void Finish();


    ClassDef(FairEventBuilderManager,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, UInt_t, etc

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Get the MC time for this event*/
    Double_t GetEventTime() {return fEventTime;}

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() {return fInputFileId;}

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() {return fMCEntryNo;}

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) {fEventTime=time;}

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) {fInputFileId=id;}

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) {fMCEntryNo=id;}

    /**
     * Destructor
     */
    virtual ~FairEventHeader();
    virtual void Register(Bool_t Persistance = kTRUE);
  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Event Time **/
    Double_t  fEventTime;
    /** Input file identifier, the file description is in the File header*/
    Int_t     fInputFileId;
    /**MC entry number from input chain*/
    Int_t     fMCEntryNo;


    ClassDef(FairEventHeader,3)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, etc
#include "TString.h"                    // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
   **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{

  public:

    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
       * @param runid : unique run id
       */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Return the list of tasks class names */
    TList* GetListOfTasks() {return fTaskList;}

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();


    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);




  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);


    ClassDef(FairFileHeader,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, FairFileInfo::Class, etc
#include "TString.h"                    // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:

    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id,  UInt_t ChId);
    virtual  ~FairFileInfo();


    TString     GetPath()          {return fPath;}
    UInt_t      GetSize()          {return fSize;}
    UInt_t      GetIdentifier()    {return fIdentifier;}
    UInt_t      GetOrderInChain()  {return fInChainId;}

    void        Print(Option_t* option="") const;

    void        SetPath(TString path) {fPath = path;}
    void        SetSize(UInt_t  size) {fSize =size;}
    void        SetIdentifier(UInt_t  id) {fIdentifier =id;}
    void        SetOrderInChain(UInt_t id) {fInChainId =id;}



  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t  fSize;
    /** Signal file identifier used*/
    UInt_t  fIdentifier;
    /** file order in the chain*/
    UInt_t  fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo,1)
};

#endif //FAIRFILEINFO_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Rtypes.h"                     // for Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                   // for TVector3

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
  **@author V.Friese <v.friese@gsi.de>
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{

  public:

    /** Default constructor **/
    FairHit();


    /** Constructor with hit parameters **/
    FairHit(Int_t detID, TVector3& pos, TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();


    /** Accessors **/
    Double_t GetDx()            const { return fDx;                     };
    Double_t GetDy()            const { return fDy;                     };
    Double_t GetDz()            const { return fDz;                     };
    Int_t    GetRefIndex()      const { return fRefIndex;               };
    void PositionError(TVector3& dpos) const;
    Int_t    GetDetectorID()    const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos)       const;



    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index)   { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /*** Output to screen */
    virtual void Print(const Option_t*) const {;}

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& boost::serialization::base_object<FairTimeStamp>(*this);
        ar& fDetectorID;
        ar& fRefIndex;
        ar& fX;
        ar& fY;
        ar& fZ;
        ar& fDx;
        ar& fDy;
        ar& fDz;
    }

  protected:
    friend class boost::serialization::access;

    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t      fRefIndex;       ///< Index of FairMCPoint for this hit
    Int_t      fDetectorID;     ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit,3);
};


inline void FairHit::PositionError(TVector3& dpos) const
{
  dpos.SetXYZ(fDx, fDy, fDz);
}


inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
  fDx = dx;
  fDy = dy;
  fDz = dz;
}


inline void FairHit::SetPositionError(const TVector3& dpos)
{
  fDx = dpos.X();
  fDy = dpos.Y();
  fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const
{
  pos.SetXYZ(fX, fY, fZ);
}


inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairHit::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include "TObject.h"                    // for TObject; ClassDefNV

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Float_t, etc

#include <iostream>                     // for ostream, cout

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink() {};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.) {
      SetFile(file);
      SetEntry(entry);
      SetType(type);
      SetIndex(index);
      SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.) {
      SetFile(-1);
      SetEntry(-1);
      SetType(type);
      SetIndex(index);
      SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const {return fEntry;}
    int GetType() const;
    int GetIndex() const {return fIndex;}
    float GetWeight() const {return fWeight;}

    void SetFile(int file);
    void SetEntry(int entry){fEntry = entry;};
    void SetType(int type);
    void SetIndex(int index){fIndex = index;};

    void SetWeight(Float_t weight) {fWeight = weight;}
    void AddWeight(Float_t weight) {fWeight += weight;}


    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const {
      if ((GetFile() == link.GetFile() || link.GetFile() == -1) &&
		  (GetEntry() == link.GetEntry() || link.GetEntry() == -1) &&
			  GetType() == link.GetType() && GetIndex() == link.GetIndex()) {
        return true;
      } else {
        return false;
      }
    }

    bool operator<(const FairLink& link) const {
		if (GetFile() != -1 && link.GetFile() != -1){
			if (GetFile() < link.GetFile()) 		return true;
			else if (link.GetFile() < GetFile()) 	return false;
		}
		if (GetEntry() != -1 && link.GetEntry() != -1){
			if(GetEntry() < link.GetEntry())		return true;
			else if (link.GetEntry() < GetEntry())	return false;
		}
		if (GetType() < link.GetType())				return true;
		else if (link.GetType() < GetType())		return false;
		if (GetIndex() < link.GetIndex())			return true;
		else if (link.GetIndex() < GetIndex())		return false;

		return false;
    }

    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
      link.PrintLinkInfo(out);
      return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
        void serialize(Archive& ar, const unsigned int)
        {
            ar& fFile;
            ar& fType;
            ar& fEntry;
            ar& fIndex;
            ar& fWeight;
        }


  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;


};

inline FairLink::FairLink() :
   fFile(0),
   fType(0),
   fEntry(-1),
   fIndex(-1),
   fWeight(1.0)
{
}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
  :fFile(0),
   fType(0),
   fEntry(-1),
   fIndex(index),
   fWeight(weight)
{
	SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
  :fFile(0),
   fType(0),
   fEntry(entry),
   fIndex(index),
   fWeight(weight)
{
	SetFile(file);
	SetType(type);
}

inline void FairLink::SetType(int type)
{
	if (type < -1) return;
	fType = type + 1;
}

inline int FairLink::GetType() const
{
	int type = fType;
	return type - 1;
}

inline void FairLink::SetFile(int file)
{
	if (file < -1) return;
	fFile = file + 1;
}

inline int FairLink::GetFile() const
{
	int file = fFile;
	return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/


#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Double_t, UInt_t, etc
#include "TVector3.h"                   // for TVector3

class FairMCEventHeader : public TNamed
{

  public:

    /** Default constructor **/
    FairMCEventHeader();


    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(Int_t iEvent, Double_t x, Double_t y, Double_t z,
                      Double_t t, Double_t b, Int_t nPrim);


    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);


    /** Destructor **/
    virtual ~FairMCEventHeader();


    /** Accessors **/
    UInt_t GetRunID()   const { return fRunId; }     /// run identifier
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Double_t GetX()     const { return fX; }         /// vertex x [cm]
    Double_t GetY()     const { return fY; }         /// vertex y [cm]
    Double_t GetZ()     const { return fZ; }         /// vertex z [cm]
    Double_t GetT()     const { return fT; }         /// event time [ns]
    Double_t GetB()     const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim()    const { return fNPrim; }     /// number of input tracks
    Bool_t IsSet()      const { return fIsSet; }     /// Flag
    Double_t GetRotX()     const { return fRotX; } /// rot. around x-axis [rad]
    Double_t GetRotY()     const { return fRotY; } /// rot. around y-axis [rad]
    Double_t GetRotZ()     const { return fRotZ; } /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }


    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t)       { fT = t; }
    void SetB(Double_t b)          { fB = b; }
    void SetNPrim(Int_t nPrim)     { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet)     { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:


    UInt_t     fRunId;       ///  Run identifier
    UInt_t     fEventId;     ///  Event identifier
    Double32_t fX;           ///  Primary vertex x [cm]
    Double32_t fY;           ///  Primary vertex y [cm]
    Double32_t fZ;           ///  Primary vertex z [cm]
    Double32_t fT;           ///  Event time [s]
    Double32_t fB;           ///  Impact parameter [fm] (if relevant)
    Int_t      fNPrim;       ///  Number of input tracks
    Bool_t     fIsSet;       ///  Flag whether variables are filled
    Double32_t fRotX;        ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;        ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;        ///  Rotation around z-axis (event plane) [rad]


    ClassDef(FairMCEventHeader,2);

};


inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y,
    Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
  fX = vertex.X();
  fY = vertex.Y();
  fZ = vertex.Z();
}


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/



#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TVector3.h"                   // for TVector3


#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class FairMCPoint : public FairMultiLinkedData_Interface
{

  public:

    /** Default constructor **/
    FairMCPoint();


    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                Double_t tof, Double_t length, Double_t eLoss, UInt_t EventId=0);
    
    /** Destructor **/
    virtual ~FairMCPoint();


    /** Accessors */
    UInt_t   GetEventID()    const { return fEventId; }        /// event identifier
    Int_t    GetTrackID()    const { return fTrackID; }
    Double_t GetPx()         const { return fPx; }
    Double_t GetPy()         const { return fPy; }
    Double_t GetPz()         const { return fPz; }
    Double_t GetTime()       const { return fTime; }
    Double_t GetLength()     const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t    GetDetectorID()   const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }




    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id;}
    void SetTime(Double_t time)        { fTime = time; }
    void SetLength(Double_t length)    { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;


    
    template<class Archive>
    void serialize(Archive & ar, const unsigned int) 
    {
        //ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar & fTrackID;
        ar & fEventId;
        ar & fDetectorID; 
        ar & fX;
        ar & fY;
        ar & fZ;
        ar & fPx;
        ar & fPy;
        ar & fPz; 
        ar & fTime; 
        ar & fLength; 
        ar & fELoss; 
    }

  protected:

    friend class boost::serialization::access;

    Int_t fTrackID;               ///< Track index
    UInt_t fEventId;              ///< MC Event id
    Double32_t fPx, fPy, fPz;     ///< Momentum components [GeV]
    Double32_t fTime;             ///< Time since event start [ns]
    Double32_t fLength;           ///< Track length since creation [cm]
    Double32_t fELoss;            ///< Energy loss at this point [GeV]
    Int_t      fDetectorID;       ///< Detector unique identifier
    Double32_t fX, fY, fZ;        ///< Position of hit [cm]


    ClassDef(FairMCPoint,5)

};


inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
  fPx = mom.Px();
  fPy = mom.Py();
  fPz = mom.Pz();
}


inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCPoint::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TH2.h"                        // for TH2D
#include "TString.h"                    // for TString

/**
 * Abstract base class for Mesh Objects.
  **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{

  public:

    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);


    /** Destructor **/
    virtual ~FairMesh();


    /** Accessors **/
    Double_t GetXmin()  const { return fXmin;  };
    Double_t GetYmin()  const { return fYmin;  };
    Double_t GetZmin()  const { return fZmin;  };

    Double_t GetXmax()  const { return fXmax;  };
    Double_t GetYmax()  const { return fYmax;  };
    Double_t GetZmax()  const { return fZmax;  };


    /** Modifiers **/
    void SetX(Double_t xmin,Double_t xmax, Int_t nbin ) {
      fXmin = xmin;
      fXmax = xmax;
      NXbin = nbin;
    }
    void SetY(Double_t ymin,Double_t ymax, Int_t nbin ) {
      fYmin = ymin;
      fYmax = ymax;
      NYbin = nbin;
    }
    void SetZ(Double_t zmin,Double_t zmax, Int_t nbin ) {
      fZmin = zmin;
      fZmax = zmax;
      NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
// virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x , Double_t y , Double_t we ) {
      fMeshTid->Fill(x,y,we);
    }
    void fillFluence(Double_t x , Double_t y , Double_t we ) {
      fMeshFlu->Fill(x,y,we);

    }
    void fillSEU(Double_t x , Double_t y , Double_t we ) {
      fMeshSEU->Fill(x,y,we);

    }
    void Scale(Double_t fac ) {
      fMeshTid->Scale(fac);
      fMeshFlu->Scale(fac);
      fMeshSEU->Scale(fac);
    }

    void calculate();


    void print();
  protected:

    Double_t  fXmin, fYmin, fZmin;
    Double_t  fXmax, fYmax, fZmax;
    Int_t     NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid; // !mesh
    TH2D* fMeshFlu; // !mesh
    TH2D* fMeshSEU; // !mesh
    TString fhname; // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector

class FairMultiLinkedData : public  TObject
{
  public:
    FairMultiLinkedData();///< Default constructor
    FairMultiLinkedData(std::set<FairLink> links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor

    virtual ~FairMultiLinkedData() {};

    virtual std::set<FairLink>    GetLinks() const {    return fLinks;}           ///< returns stored links as FairLinks
    virtual FairLink		GetEntryNr() const { return fEntryNr;}				///< gives back the entryNr
    virtual Int_t           GetNLinks() const { return fLinks.size(); }       ///< returns the number of stored links
    virtual FairLink        GetLink(Int_t pos) const;                 ///< returns the FairLink at the given position
    virtual FairMultiLinkedData   GetLinksWithType(Int_t type) const;             ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink> GetSortedMCTracks();				///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject*         GetData(FairLink& myLink);                  ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType;}
    Bool_t              GetPersistanceCheck() {return fPersistanceCheck;}     ///< Returns the value of PersistanceCheck
    Int_t             GetVerbose() {return fVerbose;}             ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) {  fDefaultType = type;}
    virtual void SetPersistanceCheck(Bool_t check) {fPersistanceCheck = check;}       ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) {fVerbose = level;}                ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val){ fInsertHistory = val;}		///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const {return fInsertHistory;}

    virtual void SetEntryNr(FairLink entry){ fEntryNr = entry;}
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);                         ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(FairLink link);                      ///< Adds the FairLinks of the inserted link to the set of links of this object


    virtual void AddAllWeights(Double_t weight);                        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);                        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);                   ///<Multiplies all Links with weight


    virtual Bool_t IsLinkInList(FairLink link)    {return IsLinkInList(link.GetType(), link.GetIndex());}   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(Int_t type, Int_t index);                             ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)  {return LinkPosInList(link.GetType(), link.GetIndex());}    ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);                             ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)    {DeleteLink(link.GetType(), link.GetIndex());}          ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);                               ///< Deletes a link ouf of fLinks

    virtual void Reset() {ResetLinks();}
    virtual void ResetLinks() {fLinks.clear();}                                    ///< Clears fLinks


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
      out << GetEntryNr() << " -> [";
      for (Int_t i = 0; i < GetNLinks(); i++) {
        GetLink(i).PrintLinkInfo(out);
        out << " ";
      }
      out << "]";
      return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck; //!
    Bool_t fInsertHistory; //!
    Int_t fVerbose; //!

    virtual void SimpleAddLinks(Int_t fileId, Int_t evtId, Int_t dataType, std::vector<Int_t> links, Bool_t, Float_t) {
      for (UInt_t i = 0; i < links.size(); i++) {
        fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
      }
    }
    Int_t fDefaultType;


    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FAIRMULTILinkedData_H_ */
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink
#include "FairMultiLinkedData.h"
#include "FairRootManager.h"

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString
#include "TRef.h"

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector


class FairMultiLinkedData_Interface : public  TObject
{
  public:
    FairMultiLinkedData_Interface();///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData_Interface(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    virtual ~FairMultiLinkedData_Interface() {
    	delete(fLink);
    };

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    virtual std::set<FairLink>  GetLinks() const;           		///< returns stored links as FairLinks
    virtual Int_t           	GetNLinks() const;                	///< returns the number of stored links
    virtual FairLink        	GetLink(Int_t pos) const;         	///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(Int_t type) const; ///< returns all FairLinks with the corresponding type
    virtual FairLink            GetEntryNr() const;
    FairMultiLinkedData* 	GetPointerToLinks() const { return fLink;}

    virtual std::vector<FairLink> GetSortedMCTracks();

    virtual void SetLinks(FairMultiLinkedData links);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link);      					///< Sets the Links with a single FairLink
    virtual void SetInsertHistory(Bool_t val);
    virtual void SetEntryNr(FairLink val);
    virtual void SetPointerToLinks(FairMultiLinkedData* links) {fLink = links;}

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);		///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    virtual void AddLink(FairLink link);      									///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise
    virtual void AddInterfaceData(FairMultiLinkedData_Interface* data);



    virtual void ResetLinks();


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const {

		if (GetPointerToLinks() != 0)
			GetPointerToLinks()->PrintLinkInfo(out);
		return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    FairMultiLinkedData* fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();

    ClassDef(FairMultiLinkedData_Interface, 5);
};

inline
FairMultiLinkedData_Interface::FairMultiLinkedData_Interface()
  :TObject(), fLink(NULL)
{
}


/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------


/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadLenPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss, TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Float_t  fRadLen);


    /** Destructor **/
    virtual ~FairRadLenPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()              { return fZmat; }
    Float_t GetRadLength()      { return fRadLen;}
    Float_t GetDensity()        { return fDensity ; }


    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)              { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }


  protected:

    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Float_t        fRadLen;     // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadLenPoint,1)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------


/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadMapPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss,
                    TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Double_t fVolMass,
                    Double_t fStep, Double_t fDose, Double_t fDoseSL, Int_t fPdg );


    /** Destructor **/
    virtual ~FairRadMapPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()             { return fZmat; }
    Float_t GetMass()           { return fVolMass;}
    Float_t GetDensity()        { return fDensity ; }

    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)             { fZmat = Z; }
    void SetMass(Double_t vmass)       { fVolMass = vmass;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg;};

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose;}
    Double_t GetDoseSL() const { return fDoseSL;}

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }



  protected:

    //  Int_t          detID;       // detector ID or volume ID
    Int_t          fPdg;        // track PID
    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Double_t       fVolMass;     // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadMapPoint,3)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H


#include "TNamed.h"

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
  **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const {
      return fRunId;
    }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const {
      return fEventTime;
    }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const {
      return fEventTimeError;
    }

    /** Get identifier*/
    Int_t GetIdentifier() const {
      return fIdentifier;
    }

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {
      fRunId=runid;
    }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr) {
      fEventTime=time;
      fEventTimeError=terr;
    }

    /** Set the run ID for this run
    * @param ident : identifier
    */
    void SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const {
      if (fEventTime < tempObj.GetEventTime()) { return true; }
      else if (fEventTime > tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const {
      if (fEventTime > tempObj.GetEventTime()) { return true; }
      else if (fEventTime < tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const {
      if   (fEventTime == tempObj.GetEventTime() ) {
        return true;
      }
      return false;
    }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t     fIdentifier;
    /** Event Time **/
    Double_t  fEventTime;
    /** Event Time Error **/
    Double_t  fEventTimeError;

    ClassDef(FairRecoEventHeader,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Long_t, etc
#include "TSystem.h"                    // for CpuInfo_t, MemInfo_t, etc
#include "TTimeStamp.h"                 // for TTimeStamp

#include <vector>                       // for vector

class FairLogger;
class TList;

class FairRunInfo : public TObject
{

  public:

    FairRunInfo();

    ~FairRunInfo();

    void StoreInfo();

    void WriteInfo();

    void Reset();

  private:

    TTimeStamp  fTimeStamp;//!
    CpuInfo_t   fCpuInfo;//!
    MemInfo_t   fMemInfo;//!
    ProcInfo_t  fProcInfo;//!
    std::vector<Double_t> fTimeDiff;//!
    std::vector<Double_t> fTime;//!
    std::vector<Long_t> fResidentMemory;//!
    std::vector<Long_t> fVirtualMemory;//!

    void CalculateTimeDifference();

    void PrintInfo();

    void GetInfo();

    void CreateAndFillHistograms(TList* histoList);

    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "FairLink.h"                   // for FairLink

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Double_t, etc

#include <iostream>                     // for ostream, cout

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp()             const { return fTimeStamp; }
    Double_t GetTimeStampError()     const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) {fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const {
      if (this == obj) { return 0; }
      FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
      Double_t ts = tsobj->GetTimeStamp();
      Double_t tserror = tsobj->GetTimeStampError();
      if (fTimeStamp < ts) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError < tserror) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError == tserror) { return 0; }
      else { return 1; }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE;};

    virtual bool equal(FairTimeStamp* data) {
      return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
      link.PrintTimeInfo(out);
      return out;
    }

    virtual bool operator< (const FairTimeStamp* rValue) const {
    	if (GetTimeStamp() < rValue->GetTimeStamp())
    		return true;
    	else
    		return false;
    }

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        // ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar& fTimeStamp;
        ar& fTimeStampError;
    }

  protected:
    friend class boost::serialization::access;

    Double_t fTimeStamp;        /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError;     /** Error on time stamp */

    ClassDef(FairTimeStamp,4);
};

// -----   Default constructor   -------------------------------------------
inline
FairTimeStamp::FairTimeStamp()
  : FairMultiLinkedData_Interface(),
    fTimeStamp(-1),
    fTimeStampError(-1)
{
}

// -----   Standard constructor   ------------------------------------------
inline
FairTimeStamp::FairTimeStamp(Double_t time)
  : FairMultiLinkedData_Interface(),
    fTimeStamp(time),
    fTimeStampError(-1)
{
}

inline
FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
  : FairMultiLinkedData_Interface(),
    fTimeStamp(time),
    fTimeStampError(timeerror)
{
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------


/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/


#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TMatrixFSymfwd.h"             // for TMatrixFSym
#include "TVector3.h"                   // for TVector3

class FairTrackParam : public TObject
{

  public:

    /** Constructor **/
    FairTrackParam();


    /** Constructor with all variables **/
    FairTrackParam(Double_t x,  Double_t y,  Double_t z,
                   Double_t tx, Double_t ty, Double_t qp,
                   const TMatrixFSym& covMat);


    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);


    /** Destructor **/
    virtual ~FairTrackParam();


    /** Output to screen **/
    void  Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX()  const { return fX; };
    Double_t GetY()  const { return fY; };
    Double_t GetZ()  const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;


    /** Modifiers **/
    void SetX(Double_t x)   { fX  = x;  };
    void SetY(Double_t y)   { fY  = y;  };
    void SetZ(Double_t z)   { fZ  = z;  };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);


    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par );



  private:

    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];


    ClassDef(FairTrackParam,1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------


/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to GEANT3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Double_t, Bool_t, etc
#include "TVirtualMagField.h"

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, basic_ostream, etc

#include "FairLogger.h"


class FairField : public TVirtualMagField
{

  public:

    /** Default constructor **/
    FairField();


    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) {return *this;}

    /** Destructor **/
    virtual ~FairField();


    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init() { };

    /** Test whether field type is Constant **/
    Bool_t IsConst();


    /** Test whether field typ is Map **/
    Bool_t IsMap();


    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }


    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBx Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBy Should be implemented in User class"<<FairLogger::endl; return 0;}

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBz Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get magnetic field. For use of GEANT3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);


    void Field(const Double_t point[3], Double_t* B) {GetFieldValue(point,B);}


    /** Screen output. To be implemented in the concrete class. **/
    virtual void  Print(Option_t*) const {;}
    virtual void GetBxyz(const Double_t[3], Double_t*) {LOG(WARNING)<<"FairField::GetBxyz Should be implemented in User class"<<FairLogger::endl;}



    /**Fill Paramater*/

    virtual void FillParContainer() {LOG(WARNING)<<"FairField::FillParContainer Should be implemented in User class"<<FairLogger::endl;}
  protected:

    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    //TODO: Check why the htrack needs this
    ClassDef(FairField,4);

};




#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------


#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include "Rtypes.h"                     // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{

  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() {
      FairField* field=0;
      if(fCreator) { field= fCreator->createFairField(); }
      return field;
    };
    virtual void SetParm() {
      if(fCreator) { fCreator->SetParm(); }
    }

  protected:
    FairFieldFactory* fCreator;
    static FairFieldFactory*  fgRinstance;

    ClassDef(FairFieldFactory,1)
  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator= (const  FairFieldFactory&) {return *this;}

};
#endif //FAIRFIELDFACTORY_H







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
* Runge-Kutte Track propagator
* @author M. Al-Turany
* @version 0.1
* @since 22.1.10
*/

#ifndef RKPropagator
#define RKPropagator

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, etc

class FairField;

class FairRKPropagator : public TObject
{

  private:
    FairRKPropagator(const FairRKPropagator&);            // Not implemented
    FairRKPropagator& operator=(const FairRKPropagator&); // Not implemented
    Double_t fMaxStep;
    FairField*              fMagField;
  public:
    void Step(Double_t Charge, Double_t* vecRKIn, Double_t* vecOut);
    Double_t OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
    FairRKPropagator(FairField* field);
    /**Propagate to closest approach of a point
    @CHARGE    Particle charge
    @STEP      maximum Step size
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vecOut    Output co-ords,direction cosines,momentum
    */
    void Propagat(Double_t Charge, Double_t* vecRKIn, Double_t* Pos);

    /**Propagate to closest approach of a plane
    @CHARGE    Particle charge
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vec1      vector on the plane
    @vec2      vector on the plane
    @vec3      point on the plane
    @vecOut    Output co-ords,direction cosines,momentum
    */

    void PropagatToPlane(Double_t Charge, Double_t* vecRKIn, Double_t* vec1, Double_t* vec2, Double_t* vec3, Double_t* vecOut);

    virtual ~FairRKPropagator();
    ClassDef(FairRKPropagator, 1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "TObject.h"

#include <iostream>

class FairEventHeader;

enum Source_Type {kONLINE, kFILE};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void Reset() = 0;

    virtual Bool_t   ActivateObject(TObject**, const char*)  { return kFALSE; }
    virtual Bool_t   ActivateObjectAny(void **, const std::type_info &, const char*) { return kFALSE; }

    virtual Source_Type GetSourceType() = 0;

    virtual void SetParUnpackers() = 0;

    virtual Bool_t InitUnpackers() = 0;

    virtual Bool_t ReInitUnpackers() = 0;

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t=0) {return -1;}
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char*) {return;}
    virtual void   ReadBranchEvent(const char*, Int_t) {return;}
    virtual void FillEventHeader(FairEventHeader* feh);

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const     { return fRunId;  }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TFolder.h"
#include "TF1.h"
class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;

class FairFileSource : public FairSource
{
public:
    FairFileSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairFileSource(const FairFileSource& file);
    virtual ~FairFileSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName);
    /**Read specific tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName, Int_t Entry);
    virtual void FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/
    void                AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void                AddFile(TString FileName);
    void                AddFriendsToChain();
    void                PrintFriendList();
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    void                CheckFriendChains();
    void                CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree*              GetInTree() {return fInChain->GetTree();}
    TChain*             GetInChain() {return fInChain;}
    TFile*              GetInFile() {return  fRootFile;}
    void                CloseInFile() { if(fRootFile) { fRootFile->Close(); }}
    /**Set the input tree when running on PROOF worker*/
    void                SetInTree (TTree*  tempTree);
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void                SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    //    virtual Bool_t   SetObject(TObject* obj, const char* ObjType);
    //    virtual void     SetObjectName(const char* ObjName, const char* ObjType);

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);
    virtual Bool_t   ActivateObjectAny(void **, const std::type_info &, const char*);

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void                SetCheckFileLayout(Bool_t enable) {fCheckFileLayout = enable;}

private:
    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** Current Entry number */
    Int_t                             fCurrentEntryNr;  //!
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /**Input Chain */
    TChain*                             fInChain;
    /**Input Tree */
    TTree*                              fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;
    
    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
     Bool_t                                 fCheckFileLayout; //!

    ClassDef(FairFileSource, 3)
};


#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TF1.h"

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;
class TFolder;

class FairRootManager;

class FairMixedSource : public FairSource
{
public:
    FairMixedSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString RootFileName, const Int_t signalId, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairMixedSource(const FairMixedSource& file);
    virtual ~FairMixedSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName);
    /** Read specific tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName, Int_t Entry);

    void                FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    void             ReadBKEvent(UInt_t i=0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void                  SetSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void                  SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void                  AddSignalFile(TString name, UInt_t identifier );
    void                  AddBackgroundFile(TString name);

    TChain*             GetBGChain() { return  fBackgroundChain;}
    TChain*             GetSignalChainNo(UInt_t i);

    Bool_t            OpenBackgroundChain();
    Bool_t            OpenSignalChain();

    /**Set the signal to background ratio in event units
    *@param background :  Number of background Events for one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
    *@param background :  Time of background Events before one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    /**Add ROOT file to input, the file will be chained to already added files*/
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    /**Set the input tree when running on PROOF worker*/
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

private:
    /**IO manager */
    FairRootManager*         fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**Output Event Header*/
    FairEventHeader*                        fOutHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t                                  fNoOfBGEntries; //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t>                fCurrentEntry; //! 

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t>              fSignalBGN;//! 
    /* /\**True for background window in entry units*\/ */
    Bool_t                                  fSBRatiobyN;  //! 
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t                                  fSBRatiobyT;  //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t                              fActualSignalIdentifier; //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t                              fNoOfSignals; //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>*                  fSignalChainList; //!
    /**Chain containing the background*/
    TChain*                              fBackgroundChain; //!
    std::map<UInt_t, TChain*>            fSignalTypeList;//!

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);
    
public:
    ClassDef(FairMixedSource, 0)
};


#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRONLINESOURCE_H
#define FAIRONLINESOURCE_H

#include "FairSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairOnlineSource : public FairSource
{
  public:
    FairOnlineSource();
    FairOnlineSource(const FairOnlineSource& source);
    virtual ~FairOnlineSource();

    inline void AddUnpacker(FairUnpack* unpacker) { fUnpackers->Add(unpacker); }
    inline const TObjArray* GetUnpackers() const { return fUnpackers; }

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void SetParUnpackers();

    virtual Bool_t InitUnpackers();

    virtual Bool_t ReInitUnpackers();

    void Reset();

    virtual Source_Type GetSourceType() { return kONLINE; }

  protected:
    TObjArray* fUnpackers;

  private:
    FairOnlineSource& operator=(const FairOnlineSource&);

    ClassDef(FairOnlineSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                           FairLmdSource                           -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRLMDSOURCE_H
#define FAIRLMDSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"


class TList;


class FairLmdSource : public FairMbsSource
{
  public:
    FairLmdSource();
    FairLmdSource(const FairLmdSource& source);
    virtual ~FairLmdSource();

    void AddFile(TString fileName);
    void AddPath(TString dir, TString wildCard);
    inline Int_t GetCurrentFile() const { return fCurrentFile; }
    inline const TList* GetFileNames() const { return fFileNames; }

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

  protected:
    Bool_t OpenNextFile(TString fileName);

    Int_t fCurrentFile;
	Int_t fNEvent;
	Int_t fCurrentEvent;
    TList* fFileNames;
    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;
	s_filhe* fxInfoHeader;

    FairLmdSource& operator=(const FairLmdSource&);

    ClassDef(FairLmdSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                          FairRemoteSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRREMOTESOURCE_H
#define FAIRREMOTESOURCE_H

#include "FairMbsSource.h"


class TSocket;
class MRevBuffer;
class REvent;


class FairRemoteSource : public FairMbsSource
{
  public:
    FairRemoteSource(char* node);
    FairRemoteSource(const FairRemoteSource& source);
    virtual ~FairRemoteSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    inline const char* GetNode() const { return fNode; }

  private:
    char* fNode;
    TSocket* fSocket;
    MRevBuffer* fBuffer;
    REvent* fREvent;

    FairRemoteSource& operator=(const FairRemoteSource&);
    
  public:
    ClassDef(FairRemoteSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSOURCE_H
#define FAIRMBSSOURCE_H

#include "FairOnlineSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairMbsSource : public FairOnlineSource
{
  public:
    FairMbsSource();
    FairMbsSource(const FairMbsSource& source);
    virtual ~FairMbsSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

  protected:
    Bool_t Unpack(Int_t* data, Int_t size,
                  Short_t type, Short_t subType,
                  Short_t procId, Short_t subCrate, Short_t control);

    ClassDef(FairMbsSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairUnpack                            -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRUNPACK_H
#define FAIRUNPACK_H

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TObject.h"


class FairUnpack : public TObject
{
  public:
    FairUnpack(Short_t type, Short_t subType,
               Short_t procId, Short_t subCrate, Short_t control);
    virtual ~FairUnpack();

    virtual Bool_t Init() = 0;
    virtual Bool_t ReInit() { return kTRUE; }
    virtual Bool_t DoUnpack(Int_t* data, Int_t size) = 0;
    virtual void   Reset() = 0;
    virtual void   SetParContainers() {  };

    inline Short_t GetType()    const { return fType;     }
    inline Short_t GetSubType() const { return fSubType;  }
    inline Short_t GetProcId()  const { return fProcId;   }
    inline Short_t GetSubCrate() const { return fSubCrate; }
    inline Short_t GetControl()  const { return fControl;  }

  private:
    Short_t fType;
    Short_t fSubType;
    Short_t fProcId;
    Short_t fSubCrate;
    Short_t fControl;

  protected:
    virtual void Register() = 0;

  public:
    ClassDef(FairUnpack, 0)
};


#endif



/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//////////////////////////////////////////////////////////////////////
// Copyright:
//   GSI, Gesellschaft fuer Schwerionenforschung mbH
//   Planckstr. 1
//   D-64291 Darmstadt
//   Germany
// created 16. 2.1999 by Horst Goeringer
//////////////////////////////////////////////////////////////////////
// MRevBuffer.h
//   description of class MRevBuffer
//   ROOT client package for multithreaded remote event server (MBS)
//////////////////////////////////////////////////////////////////////
// 20. 8.1999, H.G.: MRevBuffer::RevGetI added
//  6. 3.2000, H.G.: new member function RevStatus
//////////////////////////////////////////////////////////////////////

#ifndef MRevBuffer_H
#define MRevBuffer_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, ClassDef, etc

class TSocket;

class REvent : public TObject
{
  private:
    Int_t  iSize;              // event size (byte)
    Int_t  iNumb;              // event number
    Int_t*  piData;            // event parameter

    REvent(const REvent&);
    REvent& operator=(const REvent&);

  public:
    REvent();                  // constructor
    ~REvent();                 // destructor

    void ReFillHead(Int_t* pHead);   // unpack and fill event header
    void ReFillData(Int_t* pData);   // unpack and fill event data

    Int_t ReGetNumb();               // get event number
    Int_t ReGetSize();               // get event size
    Int_t ReGetData(Int_t ichan);    // get event parameter ichan
    Int_t* GetData() { return piData; }

    Int_t nSubEvt;
    Int_t subEvtSize[100];
    Short_t subEvtType[100];
    Short_t subEvtSubType[100];
    Short_t subEvtProcId[100];
    Short_t subEvtSubCrate[100];
    Short_t subEvtControl[100];
    Int_t* pSubEvt[100];

    ClassDef(REvent, 0)           // prototype for event
};

//////////////////////////////////////////////////////////////////////

class MRevBuffer : public TObject
{
  private:
    TSocket* pTSocket;     // ptr socket of channel to event server
    Int_t  iSocket;        // socket id of channel to event server
    Int_t  iBufNo1;        // first buffer no. received (test)
    Int_t  iBufNo2;        // last buffer no. received (test)
    Int_t  iDebug;         // verbosity level (test)
    Int_t  iSwap;          // > 0: swap event data
    Int_t  iStatus;        // current status of server

    Int_t  iBufSizeAlloc;  // allocated buffer size
    Int_t  iBufSize;       // size current buffer
    Int_t  iBufNo;         // current buffer no.
    Int_t  iFragBegin;     // > 0: last buffer ended with fragment
    Int_t  iFragConc;      // no. of concatenated fragments
    Int_t  iFragBeginIgn;  // no. of ignored fragment begins
    Int_t  iFragEndIgn;    // no. of ignored fragment ends

    Int_t  iHeadPar;       // no. of (4 byte) parms buffer header
    Int_t  iEvtMax;        // no. of events requested
    Int_t  iEvtNo;         // last event no. handled
    Int_t  iEvtRel;        // rel. event no. in buffer
    Int_t  iEvtBuf;        // no. of events in current buffer
    Int_t  iEvtPar;        // no. of parameters in event (incl. len)
    Int_t*  piBuf;         // ptr event buffer
    Int_t*  piNextEvt;     // ptr first element next event
    REvent* pEvt;          // ptr event class

    MRevBuffer(const MRevBuffer&);
    MRevBuffer& operator=(const MRevBuffer&);

  public:
    MRevBuffer( Int_t iMode); // constructor
    ~MRevBuffer();            // destructor

    TSocket* RevOpen( char* pNode, Int_t iPort, Int_t iEvent);
    // input: node name and port number server, req. no. of events
    // returns Socket ptr of server connection

    Int_t* RevGetI( TSocket* pSocket, Int_t iFlush);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)

    REvent* RevGet( TSocket* pSocket, Int_t iFlush, Int_t iSkip);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)
    // iSkip > 0: take only each iSkip event (not impl)

    Int_t RevStatus(Int_t iOut);
    // get status information (iOut = 1: also message to stdout)
    // = 0: last event request successfull
    // = 1: server not yet connected
    // = 2: server connected, but still no request for events
    // = 3: server connection okay, but currently no DAQ events
    // = 4: connection to server closed
    // = 5: connection to server closed after user break (CTL C)
    // = 6: connection to server closed after failure

    void RevBufWait(Int_t iWait);
    // wait for iWait seconds

    Int_t RevBufsize();
    // get size of current buffer (byte)

    void  RevClose( TSocket* pSocket );           // input Socket ptr

    ClassDef(MRevBuffer, 0)        // prototype for remote event buffer
};

#endif     // !MRevBuffer_H 
// -----------------------------------------------------------------------------
// ----- FairMbsStreamSource header file                                   -----
// -----                                                                   -----
// ----- created by C. Simon on 2014-09-12                                 -----
// -----                                                                   -----
// ----- based on FairLmdSource by D. Kresan                               -----
// -----                                                                   -----
// ----- revision 23363, 2013-12-26                                        -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSTREAMSOURCE_H
#define FAIRMBSSTREAMSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"

class FairMbsStreamSource : public FairMbsSource
{
  public:
    FairMbsStreamSource(TString tServerName);
    FairMbsStreamSource(const FairMbsStreamSource& source);
    virtual ~FairMbsStreamSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    const char* GetServerName() const {return fServerName.Data();};

  private:
    Bool_t ConnectToServer();

    TString fServerName;

    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;

    FairMbsStreamSource& operator=(const FairMbsStreamSource&);


  public:
    ClassDef(FairMbsStreamSource, 0)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__BaseDict dictionary payload:1867:
In file included from /mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairTimeStamp.h:11:
In file included from /mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMultiLinkedData_Interface.h:13:
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairLink.h:104:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
                         ^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairLink.h:104:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
                         ^
In file included from G__BaseDict dictionary payload:1867:
In file included from /mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairTimeStamp.h:11:
In file included from /mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMultiLinkedData_Interface.h:14:
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMultiLinkedData.h:95:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
                         ^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMultiLinkedData.h:95:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
                         ^
In file included from G__BaseDict dictionary payload:1867:
In file included from /mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairTimeStamp.h:11:
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMultiLinkedData_Interface.h:73:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
                         ^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMultiLinkedData_Interface.h:73:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
                         ^
In file included from G__BaseDict dictionary payload:1867:
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairTimeStamp.h:66:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
                         ^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairTimeStamp.h:66:26: note: previous definition is here
    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
                         ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRunOnline with content:

#line 1 "G__BaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef BUILD_MBS
  #define BUILD_MBS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "TSelector.h"                  // for TSelector

#include "FairLogger.h"                 // for FairLogger, MESSAGE_ORIGIN

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TSelectorList.h"              // for TSelectorList
#include "TString.h"                    // for TString
#include "TTree.h"                      // for TTree

#include <stddef.h>                     // for NULL

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;
class TString;

class FairAnaSelector : public TSelector
{
  public :
    TProofOutputFile*     fProofFile;
    TFile*                fFile;
    TTree*                fChain;   //!pointer to the analyzed TTree or TChain
    FairRunAnaProof*      fRunAna;

    FairAnaSelector(TTree* /*tree*/ =0) : fProofFile(0), fFile(0), fChain(0), fRunAna(NULL), fLogger(FairLogger::GetLogger()), fProofSource(0), fCurrentDirectory("") { }

    virtual ~FairAnaSelector() { }
    virtual Int_t   Version() const {
      return 1;
    }
    virtual void    Begin(TTree* tree);
    virtual void    SlaveBegin(TTree* tree);
    virtual void    Init(TTree* tree);
    virtual Bool_t  Notify();
    virtual Bool_t  Process(Long64_t entry);
    virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) {
      return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    virtual void    SetOption(const char* option) {
      fOption = option;
    }
    virtual void    SetObject(TObject* obj) {
      fObject = obj;
    }
    virtual void    SetInputList(TList* input) {
      fInput = input;
    }
    virtual TList*  GetOutputList() const {
      return fOutput;
    }
    virtual void    SlaveTerminate();
    virtual void    Terminate();

    void SetFairRunAnaProof(FairRunAnaProof* runAna) {
      fRunAna = runAna;
    }

  protected:
    /** Fair Logger */
    FairLogger*             fLogger;//!

  private:

    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDef(FairAnaSelector,0);
};

#endif //FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1


#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TObjArray.h"                  // for TObjArray

#include <iostream>                     // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;


/**
 * @class FairRadGridManager
 */


class FairRadGridManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     * The pointer to this object can be reached via FairRadGridManager::Instance().
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager,1);


  private:

    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;              //!
    /**track length */
    Double_t       fLength;            //!
    /** energy loss */
    Double_t       fELoss;             //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;

    static Double_t fLtmp;
  public:

    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList ( TObjArray* list ) {
      std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
      fMeshList = list;
    }
    Bool_t  IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t  IsTrackEntering(TLorentzVector& vec1,TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     */
    static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1


#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;

/**
 * @class FairRadLenManager
 */


class FairRadLenManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     * The pointer to this object can be reached via FairRadLenManager::Instance().
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager,1);


  private:

    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /** energy loss */
    Double_t       fELoss;               //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;

  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     */
    static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;
class TMap;

/**
 * @class FairRadMapManager
 */


class FairRadMapManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     * The pointer to this object can be reached via FairRadMapManager::Instance().
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager,1);


  private:

    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /** pid */
    Int_t          fPdg;                //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /**track setp */
    Double_t       fStep;
    /** energy loss */
    Double_t       fELoss;               //!
    /**dose */
    Double_t        fDose;
    Double_t       fDoseSL;
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /** radiation length*/
    Float_t        fRadl;
    /**  density */
    Float_t        fDensity;
    /**absorption length */
    Float_t        fAbsl;
    //**volume, mass */
    Double_t       fActVol;
    Double_t       fActMass;

    TMap* fMassMap;


  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     */
    static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_


#include "TObject.h"                    // for TObject

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for FairRingSorter::Class, etc

#include <iostream>                     // for operator<<, ostream, etc
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
      : TObject(), fRingBuffer(size), fOutputData(), fLowerBoundPointer(0,0),
        fCellWidth(width), fVerbose(0) {
    }

    virtual ~FairRingSorter() {};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);       ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);          ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() {
      WriteOutElements(fLowerBoundPointer.first);
    }
    virtual double GetBufferSize() {return fCellWidth * fRingBuffer.size();}
    virtual std::vector<FairTimeStamp*> GetOutputData() {
      return fOutputData;
    }

    virtual void DeleteOutputData() {fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout) {
      out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << std::endl;
      out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second << std::endl;
      out << "| ";
      for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
        out << fRingBuffer[i].size() << " |";
      }
      out << std::endl;
    }


  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*> > fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter,1)

};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairTask.h"                   // for FairTask, InitStatus

#include "FairRingSorter.h"             // for FairRingSorter

#include "Rtypes.h"                     // for Bool_t, Int_t, kTRUE, etc
#include "TString.h"                    // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:

    /** Default constructor **/
    FairRingSorterTask():
      FairTask("SorterTask"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name):
      FairTask(name),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells, Double_t widthOfCells, TString inputBranch, TString outputBranch, TString folderName):
      FairTask("Sorter"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(numberOfCells),
      fWidthOfCells(widthOfCells),
      fInputBranch(inputBranch),
      fInputArray(0),
      fOutputBranch(outputBranch),
      fFolder(folderName),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Destructor **/
    virtual ~FairRingSorterTask() {
      delete fSorter;
    }

    /** Virtual method Init **/
    virtual InitStatus Init();
    virtual InitStatus ReInit();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);
    virtual void FinishEvent();
    virtual void FinishTask();

    virtual void SetParContainers() {};

    void SetPersistance(Bool_t p = kTRUE) {fPersistance=p;};
    Bool_t GetPersistance() {return fPersistance;};

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:

    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells; // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDef(FairRingSorterTask,2);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include "TChain.h"                     // for TChain
#include "TFile.h"                      // for TFile
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator<
#include "TMCtls.h"                     // for multi-threading

#include <stddef.h>                     // for NULL
#include <list>                         // for list
#include <map>                          // for map, multimap, etc
#include <queue>                        // for queue
#include "FairSource.h"
#include <typeinfo>
#include <typeindex>
#include <vector>
#include <memory>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairGeoNode;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TArrayI;
class TBranch;
class TClonesArray;
class TCollection;
class TF1;
class TFolder;
class TList;
class TNamed;
class TTree;
class TRefArray;
class TIterator;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

//_____________________________________________________________________

class FairRootManager : public TObject
{
  public:
      /**dtor*/
    virtual ~FairRootManager();
     Bool_t             AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t               CheckBranch(const char* BrName);

    
    void                CloseOutFile() { if(fOutFile) { fOutFile->Close(); }}
    /**Create a new file and save the current TGeoManager object to it*/
    void                CreateGeometryFile(const char* geofile);
    void                Fill();
    void                LastFill();
    TClonesArray*       GetEmptyTClonesArray(TString branchName);
    TClonesArray*       GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void                UpdateBranches();

    /**Return branch name by Id*/
    TString             GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t               GetBranchId(TString const &BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList*              GetBranchNameList() {return fBranchNameList;}
    /**Return the vector of branch names that were requested by tasks as input*/
    const std::vector<std::string>& GetReqBranchNames() const {return fReqBrNames;}

      /** Return a pointer to the output Tree of type TTree */
    TTree*              GetOutTree() {return fOutTree;}
    /** Return a pointer to the output File of type TFile */
    TFile*              GetOutFile() {return  fOutFile;}
    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject*            GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t            GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject*      GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* startFunction, Double_t startParameter, BinaryFunctor* stopFunction, Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer) {fTSBufferMap[branchName] = functionalBuffer;}
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional*   GetTSBuffer(TString branchName) {return fTSBufferMap[branchName];}

    /** static access method */
    static FairRootManager* Instance();

    TFile*            OpenOutFile(const char* fname="cbmsim.root");
    TFile*            OpenOutFile(TFile* f);
    /**Read a single entry from background chain*/
    Int_t             ReadEvent(Int_t i=0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t             ReadNonTimeBasedEventFromBranches(Int_t i=0);
    /**Read the tree entry on one branch**/
    void              ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void              ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t             GetRunId();

    Bool_t            ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
    *@param name            Name of the branch to create
    *@param Foldername      Folder name containing this branch (e.g Detector name)
    *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
    *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name,const char* Foldername ,TCollection* obj, Bool_t toFile);

    
    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T* &obj, Bool_t toFile);
    /// for branches which are not managed by folders, we need a special function
    /// to trigger persistent branch creation
    /// return true if successful; false if problem
    bool CreatePersistentBranchesAny();    

    void                RegisterInputObject(const char* name, TObject* obj);

    TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void                UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries*/
    void                RunWithTimeStamps() {fTimeStamps = kTRUE;}

    /**Set the branch name list*/
    void                SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList *list);
  
    void                FillEventHeader(FairEventHeader* feh) { if ( fSource ) fSource->FillEventHeader(feh); } 
   
    /**Set the output tree pointer*/
    void                SetOutTree(TTree* fTree) { fOutTree=fTree;}

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void        SetLastFill(Bool_t val = kTRUE) { fFillLastData=val;}
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TBranch* b, TString ffn);
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TTree* fTree, const char* folderName);

    Int_t               Write(const char* name=0, Int_t option=0, Int_t bufsize=0);
    /** Write the current TGeoManager to file*/
    void                WriteGeometry();
    /**Write the file header object to the output file*/
    void                WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void                WriteFolder() ;

    /**Check the maximum event number we can run to*/
    Int_t  CheckMaxEventNo(Int_t EvtEnd=0);


    void        StoreWriteoutBufferData(Double_t eventTime);
    void        StoreAllWriteoutBufferData();
    void    DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() {return fEntryNr;}
    void SetEntryNr(Int_t val) {fEntryNr = val;}

    void SetUseFairLinks(Bool_t val) {fUseFairLinks = val;};
    Bool_t GetUseFairLinks() const {return fUseFairLinks;};

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */
   
    
    /** These methods have been moved to the FairFileSource */
    void   SetSource(FairSource* tempSource) { fSource = tempSource; }    
    FairSource* GetSource() { return fSource;}
    Bool_t InitSource();
    
    void                SetListOfFolders(TObjArray* ta){ fListFolder=ta; }
    TChain*             GetInChain ()                  { return fSourceChain;}
    TChain*             GetSignalChainNo(UInt_t i)     { return fSignalChainList[i]; }
    TTree*              GetInTree  ()                  { if ( fSourceChain ) return fSourceChain->GetTree(); return 0; }
    const TFile*        GetRootFile()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    TFile*              GetInFile  ()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    void                SetInChain (TChain* tempChain, Int_t ident=-1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE){ fFinishRun = val;}
    Bool_t FinishRun() {return fFinishRun;}

    static char* GetTreeName();
  private:

    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair {
    TypeAddressPair(const std::type_info &oi, const std::type_info &pi, void* a) : origtypeinfo(oi), persistenttypeinfo(pi), ptraddr(a) {}
      const std::type_info &origtypeinfo; // type_info of type addr points to 
      const std::type_info &persistenttypeinfo; // type_info of ROOT persistent branch (drops pointers)
      void *ptraddr; // address of a pointer (pointing to origtypeinfo);
    };
    
    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject*            ActivateBranch(const char* BrName);
    void                AddFriends( );
    /**Add a branch to memory, it will not be written to the output files*/
    void                AddMemoryBranch(const char*, TObject* );

    template<typename T>
    void AddMemoryBranchAny(const char *name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t               CheckBranchSt(const char* BrName);
        /**Create the Map for the branch persistency status  */
    void                CreatePerMap();
    TObject*            GetMemoryBranch( const char* );
 //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char *typen1, const char *typen2) const;

    Int_t       fOldEntryNr;
//_____________________________________________________________________
    /**private Members*/
    /**folder structure of output*/
    TFolder*                            fOutFolder;
    /**folder structure of input*/
    TFolder*                            fRootFolder;
    /** current time in ns*/
    Double_t                            fCurrentTime;
    /**Output file */
    TFile*                              fOutFile;
    /**Output tree */
    TTree*                              fOutTree;
    TObject**                           fObj2; //!
    /** Counter for the number of branches activiated */
    Int_t                               fNObj;//!
    /** A list which hold the pointer to the branch 
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map < TString , TObject* >     fMap;  //!

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap; //!
    /// keeps track of branches which are supposed to be persistified
    std::vector<std::string> fPersistentBranchesAny;
    
    /**Branch id for this run */
    Int_t                                fBranchSeqId;
    /**List of branch names as TObjString*/
    TList*                               fBranchNameList; //!
    /**Vector of (not necessarily unique) branch names requested per GetObject / InitObjectAs */
    std::vector<std::string>             fReqBrNames; //!
    
    /**The branch ID for the special (required) MCTrack branch**/
    Int_t                                fMCTrackBranchId; //!

    /**List of Time based branchs names as TObjString*/
    TList*                               fTimeBasedBranchNameList; //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap; //!
    std::map<TString, FairWriteoutBuffer* > fWriteoutBufferMap; //!
    std::map<Int_t, TBranch*> fInputBranchMap; //!    //Map of input branch ID with TBranch pointer
    /**if kTRUE Read data according to time and not entries*/
    Bool_t                              fTimeStamps;
    /**Flag for creation of Map for branch persistency list  */
    Bool_t                              fBranchPerMap;
    /** Map for branch persistency list */
    std::map < TString , Int_t >        fBrPerMap; //!
    /**Iterator for the fBrPerMap  Map*/
    std::map < TString, Int_t>::iterator     fBrPerMapIter;
 
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    Bool_t  fFillLastData; //!
    Int_t fEntryNr; //!

    TObjArray                           *fListFolder; //!

    FairSource                          *fSource;

    TChain                              *fSourceChain;
    std::map<UInt_t, TChain*>            fSignalChainList;//!

    FairEventHeader                     *fEventHeader;
    
    Bool_t fUseFairLinks; //!
    Bool_t fFinishRun; //!
    /** List of branches from input Chain or Tree*/
    TObjArray* fListOfBranchesFromInput; //!
    /** Iterator for the list of branches from input Chain or Tree */
    TIterator* fListOfBranchesFromInputIter;//!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray* fListOfNonTimebasedBranches; //!
    /** Iterator for the list of branches used with no-time stamp in time-based session */
    TIterator* fListOfNonTimebasedBranchesIter; //!

    ClassDef(FairRootManager,12) // Root IO manager
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj) {
  if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
    auto& ot = typeid(T*);
    auto& pt = typeid(T);
    fAnyBranchMap[brname]=std::unique_ptr<TypeAddressPair const> (new TypeAddressPair(ot, pt,(void*)obj));
  }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const {
  static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer"); 
  using P = typename std::remove_pointer<T>::type;
  auto iter = fAnyBranchMap.find(brname);
  if(iter != fAnyBranchMap.end()) {
    // verify type consistency
    if(typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
      EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
      return nullptr;
    }
    return static_cast<T>(iter->second->ptraddr);
  }
  return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T *& obj, bool persistence) {
  AddBranchToList(brname);
  if (persistence) {
    fPersistentBranchesAny.push_back(brname);
  }
  // we are taking the address of the passed pointer
  AddMemoryBranchAny<T>(brname, &obj);
}

// this function serves as a factory (or lookup) for memory managed 
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname) {
  static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer"); 
  using X = typename std::remove_pointer<TPtr>::type;
  static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
  using T = typename std::remove_const<X>::type;
  
  // is there already an object associated to the branch in memory?? 
  // then just return
  T** obj = GetMemoryBranchAny<T**>(brname);
  // obj is some address/instance holding TPtr instances
  if(obj!=nullptr) return *obj;

  // it does not seem to be the case, let us create the pointer which will be initialized
  // with the data (pointer to T)
  T** addr = new T*;
  // init the pointee to a default obj which we can return
  (*addr) = new T;
  // try to find and activate in the source
  auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

  if(!succeeded) {
    delete (*addr);
    delete addr;
    return nullptr;
  }
  // add into branch list
  AddMemoryBranchAny<T>(brname, addr);
  // register as a **requested** branch
  // (duplications are explicitely allowed)
  fReqBrNames.emplace_back(brname);
  
  // NOTE: ideally we would do proper resource management for addr and *addr
  // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
  // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
  // container which we cannot know a priori; Some solutions we could think of in the future are
  // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
  // b) investigate if boost::any could be of help here
  // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
  // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
  return *addr;
}

#endif //FAIR_ROOT_MANAGER_H

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TMCtls.h"                     // for multi-threading

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairTask;
class TFile;
class FairField;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
    * default dtor
    */
    virtual ~FairRun();
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void       AddTask(FairTask* t);
    virtual void       SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void    Init()=0;
    /*
     * Get the magnetic field *
     */
    virtual FairField*  GetField()=0;
    /**
      * run the analysis or simulation
     */
    virtual void    Run(Int_t NStart =0,Int_t NStop=0)=0;
    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void        SetEventHeader(FairEventHeader* EvHeader)  {
      fEvtHeader=EvHeader;
    }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb(void) {
      return fRtdb;
    }
    /**
     * Set the  output file name without creating the file
     */
    void SetOutputFileName(const TString& name) {
      fOutname = name;
    }
    /**
     * return a pointer to the output file
     */
    TFile* GetOutputFile() {
      return fOutFile;
    }
    /**
     * return a pointer to the output file
     */
    TString GetOutputFileName() {
      return fOutname;
    }
    /**
     * return the run ID for the actul run
     */
    Int_t  GetRunId() {
      return (static_cast<Int_t>(fRunId));
    }

	/** 
     * Set the Run ID
	 */
    void SetRunId(UInt_t runId)
	{
	  fRunId = runId; 
    }    

    /**Get the detector specific run header*/
    FairEventHeader*  GetEventHeader();
    /**
    * return true for Anaylsis session
    */
    Bool_t            IsAna() {
      return fAna;
    }
    /**
    *Get task by name
    */

    FairTask* GetTask(const char* taskName);
    /**
    *Get Main Task
    */
    FairTask* GetMainTask() {
      return fTask;
    }
    /**
    * Return the number of Tasks added to this Run
    */
    Int_t     GetNTasks() {
      return fNTasks;
    }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    //** Set if RunInfo file should be written */
    void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write;}

    //** Get info if RunInfo file is written */
    Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo;}

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster;}

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }


  private:
    FairRun(const FairRun& M);
    FairRun& operator= (const  FairRun&) {
      return *this;
    }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /** Tasks used*/
    FairTask*                fTask;
    /**Output file name*/
    TString                  fOutname;
    /**IO manager */
    FairRootManager*         fRootManager;
    /**Output file*/
    TFile*                   fOutFile;
    /**Run Id*/
    UInt_t                   fRunId;//!
    /** true for Anaylsis session*/
    Bool_t                   fAna;  //!
    /** MC Event Header */
    FairEventHeader*         fEvtHeader; //!
    /** File  Header */
    FairFileHeader*          fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t                   fGenerateRunInfo;  //!
    /** true if on master*/
    Bool_t                   fIsMaster;  //!

    Bool_t                   fMarkFill; //!

    ClassDef(FairRun ,4)
};
#endif //FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H


/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"                    // for FairRun

#include "FairRootManager.h"            // for FairRootManager
#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Bool_t, Double_t, UInt_t, etc
#include "TString.h"                    // for TString

class FairField;
class TF1;
class TFile;
class TTree;

class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:

    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void        Init();
    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void        Run(Double_t delta_t);
    /**Run for the given single entry*/
    void        Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void        RunEventReco(Int_t NStart ,Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void        RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void        DummyRun(Int_t NStart ,Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
      * it read a certain event and call the task exec, but no output is written
      * @param entry : entry number in the tree
      */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void        RunOnLmdFiles(UInt_t NStart=0, UInt_t NStop=0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void        TerminateRun();
    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */

    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }

    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource
    /**Set the input file by name*/
    void        SetInputFile(TString fname);
    /**Add a file to input chain */
    void        AddFile(TString name);
    /** Add a friend file (input) by name)*/
    void        AddFriend(TString fName);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairMixedSource
    void        SetSignalFile(TString name, UInt_t identifier );
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void        AddSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void        SetBackgroundFile(TString name);
    /**Add input background file by name*/
    void        AddBackgroundFile(TString name);
    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);
    /**
     * This method will simply forward the call to the FairRootManager,
     * if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
    */
    //    void SetMixAllInputs(Bool_t Status);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource and FairMixedSource
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the time intervall the beam is interacting and the gap in ns */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    // ********************************************************* //

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag){
        fStoreEventHeader=flag;
    }

    void        Reinit(UInt_t runId);
    UInt_t      getRunId() {
      return fRunId;
    }
    /** Get the magnetic field **/
    FairField*  GetField() {
      return fField;
    }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield ) {
      fField=ffield ;
    }
    /** Set external geometry file */
    void        SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile*      GetGeoFile() {
      return fInputGeoFile;
    }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };
    void        RunWithTimeStamps();
    Bool_t      IsTimeStamp() {
      return fTimeStamps;
    }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD( void ) {
      fFinishProcessingLMDFile = kTRUE;
    }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus( void ) {
      return fFinishProcessingLMDFile;
    }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
    **/
    virtual void Fill();

  private:

    FairRunAna(const FairRunAna& M);
    FairRunAna& operator= (const  FairRunAna&) {
      return *this;
    }

    FairRunInfo fRunInfo;//!

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    TFile*                                  fInputGeoFile;
    static FairRunAna*                      fgRinstance;
    Bool_t                                  fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;
    Bool_t                                  fTimeStamps;
    Bool_t                                  fInFileIsOpen;//!
    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** Flag for proccessing lmd-files*/
    Bool_t                                  fFinishProcessingLMDFile;  //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource*                         fFileSource;  //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource*                        fMixedSource; //!
    /** Flag for Event Header Persistency */
    Bool_t  fStoreEventHeader; //!


    ClassDef(FairRunAna ,6)

};

#endif //FAIRRUNANA_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairRunAna.h"

#include "FairFileSource.h" // FairRunAnaProof can only accept FairFileSource as source
#include "TProof.h"

class FairRunAnaProof : public FairRunAna
{

  public:

    static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName="");

    /**initialize the run manager*/
    void        Init();

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();

    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);

    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run for one event, used on PROOF nodes*/
    void        RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void        RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() {
      return fProof;
    }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) {
      fRunOnProofWorker = tb;
    }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) {
      fProofParName = parName;
    }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) {
      fOutputDirectory = dirName;
    }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) {
      fProofOutputStatus = outStat;
    }

    virtual void   SetSource(FairSource* tempSource);

  protected:
    static FairRunAnaProof*                 fRAPInstance;

    /** PROOF **/
    TProof*                                 fProof;
    /** executing on PROOF worker*/
    Bool_t                                  fRunOnProofWorker; //!
    /** PROOF server name*/
    TString                                 fProofServerName; //!
    /** PROOF ARchive (PAR) file name*/
    TString                                 fProofParName; //!
    /** Output directory*/
    TString                                 fOutputDirectory; //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString                                  fProofOutputStatus;

  private:
  
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;
    
    ClassDef(FairRunAnaProof ,1)

};

#endif //FAIRRUNANAPROOF_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairRun.h"                    // for FairRun

#include "FairIon.h"                    // for FairIon
#include "FairMCApplication.h"          // for FairMCApplication
#include "FairParticle.h"               // for FairParticle

#include "Rtypes.h"                     // for Bool_t, Double_t, Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TMCtls.h"                     // for multi-threading

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * Configure the Simulation session
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    virtual ~FairRunSim();
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
    */
    void        AddModule  (FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewIon(FairIon* ion) {fIons->Add(ion);}
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewParticle(FairParticle* Particle) {fParticles->Add(Particle);}
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefParticles();

    /**
    *       Initialize the Simulation
    */
    virtual void        Init();
    /**
    *       run the  simulation
    */
    virtual void    Run(Int_t NEvents =0, Int_t NotUsed=0);
    /**
    *       Set the magnetic that has to be used for simulation field
    */
    void        SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
    */
    void        SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void  SetMCEventHeader(FairMCEventHeader* McHeader) {fMCEvHead=McHeader;}

    /** Set the material file name to be used */
    void    SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj=kTRUE) {fStoreTraj = storeTraj;}

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode( Bool_t set ) { if (fApp) { fApp->SetTrackingDebugMode( set ); } }

    /**Set geometry builder*/
    void SetGeoModel( char* name );

    /**return the geometry loader used in this session*/
    TString* GetGeoModel () { return fLoaderName; }

    /**Get the field used in simulation*/
    FairField*  GetField() { return fField;}

    /**Get the detector specific event header*/
    FairMCEventHeader*  GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray*        GetListOfModules() { return ListOfModules;}

    /**Get the used primary generator*/
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen;}

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer = decayer;}

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config );

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) {fUserDecay = decay;}

    /**Flag for external decayer*/
    Bool_t  IsExtDecayer() {return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t  IsUserDecay() {return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) {fRadLength= value;}

    void SetRadMapRegister(Bool_t value) { fRadMap=value; }

    void SetRadGridRegister(Bool_t value) {fRadGrid= value;}

    void AddMesh (FairMesh* Mesh);

    void SetUserConfig(const TString& Config) {fUserConfig = Config;}

    void SetUserCuts(const TString& Cuts) {fUserCuts= Cuts;}

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom) {  fBeamMom= BeamMom; fUseBeamMom=kTRUE;}

    /** Get the Beam energy */
    Double_t GetBeamMom() {return fBeamMom;}

    /**Get beam energy flag */
    Bool_t UseBeamMom() {return fUseBeamMom;}
    void SetFieldContainer();
  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator= (const  FairRunSim&) {return *this;}
    void SetMCConfig();
    void CheckFlukaExec();
  protected:

    Int_t                  count;//!                               /** Internal counter*/
    FairMCApplication*     fApp;  //!                              /** Main VMC application */
    Double_t               fBeamMom; //!                           /** Beam Energy in GeV/c  */
    Bool_t                 fUseBeamMom; //!                        /** flag for use Beam Energy  */
    FairPrimaryGenerator*  fGen; //!                               /** Primary Event Generator */
    FairMCEventHeader*     fMCEvHead; //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim*  fginstance;//!              /** Singleton Instance */
    FairField*             fField;                                 /** Magnetic Field */
    const char*            fMapName; //!                           /** Input file name map*/
    TObjArray*             fIons; //!                              /** Array of user defined ions */
    TObjArray*             fParticles; //!                         /** Array of user defined particles*/
    TObjArray*             ListOfModules;//!                       /** Array of used modules */
    TString                MatFname; //!                           /** Material file name */
    Bool_t                 fStoreTraj;   //!                       /** Trajectory store flags */
    TString*               fLoaderName;  //!                       /** Geometry Model (TGeo or G3)*/
    Bool_t                 fPythiaDecayer;  //!                    /** flag for using Pythia decayer*/
    TString                fPythiaDecayerConfig; //!               /** Macro for Pythia decay configuration*/
    Bool_t                 fUserDecay;                             /** flag for setting user decay */
    TString                fUserDecayConfig; //!                   /** Macro for decay configuration*/
    Bool_t                 fRadLength;   //!                       /** flag for registring radiation length*/
    Bool_t                 fRadMap; //!                            /** flag for RadiationMapManager
    Bool_t                 fRadGrid;  //!
    TObjArray*             fMeshList; //!                          /** radiation grid scoring
    TString                fUserConfig; //!                        /** Macro for geant configuration*/
    TString                fUserCuts; //!                          /** Macro for geant cuts*/


    ClassDef(FairRunSim ,2)

};

#endif //FAIRRUNSIM_H





/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"              // for FairTimeStamp

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TObject.h"                    // for TObject
#include "TString.h"                    // for TString

#include <functional>                   // for binary_function
#include <iostream>                     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;


/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor : public std::binary_function<FairTimeStamp* ,double, bool>
{
  public :
    virtual bool operator() (FairTimeStamp* a, double b) {return Call(a,b);};
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() {return false;}
    virtual void ResetTimeOut() {};

    virtual ~BinaryFunctor() {};

};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public :
    StopTime():fRequestTime(-1), fOldTime(-1), fSameTimeRequestCounter(0) {};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) {
      fRequestTime = b;
      //std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
      return a->GetTimeStamp() > b;
    };

    bool TimeOut() {
      if (fRequestTime != fOldTime) {
        fOldTime = fRequestTime;
        fSameTimeRequestCounter = 0;
        //std::cout << "RequestedTime: " << fRequestTime << std::endl;
        return false;
      } else if (fRequestTime == fOldTime) {
        std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime << std::endl;
        fSameTimeRequestCounter++;
      } else {
        std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime << " smaller than old time " << fOldTime << std::endl;
        return true;
      }
      if (fSameTimeRequestCounter > 9) {
        return true;
      } else { return false; }
    }

    void ResetTimeOut() {fSameTimeRequestCounter = 0;}

  private :
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};



/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap():fOldTime(-1.) {};


    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) {
      double aTime = a->GetTimeStamp();

      if (fOldTime < 0) {
        fOldTime = aTime;
        return false;
      }
      if (aTime - fOldTime > b) {
        fOldTime = aTime;
        return true;
      } else {
        fOldTime = aTime;
        return false;
      }
    };


  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already exists.
 * To extract the data one has to call GetData with a parameter which fits to the selected functor.
 * GetData returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot request data which is older than the
 * data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only works if you request a fixed time
 * via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{

  public:
    FairTSBufferFunctional(TString branchName, TTree* sourceTree, BinaryFunctor* stopFunction, BinaryFunctor* startFunction = 0);

    virtual ~FairTSBufferFunctional() {};
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() {return fBranchIndex;}

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function;}
    void SetStopFunction(BinaryFunctor* function)  { fStopFunction  = function;}
    Bool_t AllDataProcessed();
    void Terminate(){ fTerminate = kTRUE; }

    Bool_t TimeOut() {
      Bool_t stopTimeOut = fStopFunction->TimeOut();
      Bool_t startTimeOut = kTRUE;
      if (fStartFunction != 0) {
        startTimeOut = fStartFunction->TimeOut();
//        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
//          fStartFunction->ResetTimeOut();
//        }
//        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
//          fStopFunction->ResetTimeOut();
//        }
      }
      return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);


  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray(); //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDef(FairTSBufferFunctional,0);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------


/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include "TTask.h"                      // for TTask

#include "FairRootManager.h"            // for FairRootManager

#include "Rtypes.h"                     // for Int_t, FairTask::Class, etc
#include "TString.h"                    // for TString

#include <map>

class FairLogger;

enum InitStatus {kSUCCESS, kERROR, kFATAL};

class FairTask : public TTask
{

  public:

    /** Default constructor **/
    FairTask();


    /** Standard constructor
    *@param name        Name of task
    *@param iVerbose    Verbosity level
    **/
    FairTask(const char* name, Int_t iVerbose = 1);


    /** Destructor **/
    virtual ~FairTask();


    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();


    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();


    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();


    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

    void SetInputPersistance(Bool_t val) {fInputPersistance = val;}

    void CheckInputPersistance(TString branchName) {
      FairRootManager* ioman = FairRootManager::Instance();
      fInputPersistance = ioman->CheckBranch(branchName);
    }

    virtual void  ExecuteTask(Option_t *option="0");  // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
    **/   
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
    **/  
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val=kTRUE) {fStreamProcessing=val;}

  protected:

    Int_t        fVerbose;  //  Verbosity level
    Int_t        fInputPersistance; ///< Indicates if input branch is persistant
    FairLogger*  fLogger; //!
    Bool_t       fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus Init() { return kSUCCESS; };


    /** Reinitialisation. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus ReInit() { return kSUCCESS; };


    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers() { };


    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish() { };


    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    virtual void  ExecuteTasks(Option_t *option);

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:

    std::map<TString, Bool_t> fOutputPersistance;

    FairTask(const FairTask&);
    FairTask& operator=(const FairTask&);

    ClassDef(FairTask,4);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TGeoTrack.h"                  // IWYU pragma: keep needed by cint
#include "TMath.h"                      // for Pi, TwoPi
#include "TString.h"                    // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */


class FairTrajFilter
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter,1);


  private:

    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t    fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* GetCurrentTrk() {return fCurrentTrk;}

    void Init(TString brName="GeoTracks", TString folderName="MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin=-2000., Double_t vyMin=-2000., Double_t vzMin=-2000.,
                      Double_t vxMax= 2000., Double_t vyMax= 2000., Double_t vzMax= 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin=  0., Double_t thetaMin=0., Double_t phiMin=0.,
                         Double_t pMax=1e10, Double_t thetaMax=TMath::Pi(),
                         Double_t phiMax=TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin=-1e10, Double_t pyMin=-1e10, Double_t pzMin=-1e10,
                         Double_t pxMax= 1e10, Double_t pyMax= 1e10, Double_t pzMax= 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin=0., Double_t ptMax=1e10,
                          Double_t rapidityMin=-1e10, Double_t rapidityMax=1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin=0., Double_t etotMax=1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim=kTRUE) {fStorePrim = storePrim;};

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec=kTRUE) {fStoreSec = storeSec;};

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin=0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin, Double_t& vyMin, Double_t& vzMin,
                      Double_t& vxMax, Double_t& vyMax, Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin, Double_t& thetaMin, Double_t& phiMin,
                         Double_t& pMax, Double_t& thetaMax, Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin, Double_t& pyMin, Double_t& pzMin,
                         Double_t& pxMax, Double_t& pyMax, Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax,
                          Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const {return fStorePrim;};

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const {return fStoreSec;};

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "TObject.h"                    // for TObject

#include "FairLogger.h"                 // for FairLogger
#include "FairRootManager.h"            // for FairRootManager
#include "FairTimeStamp.h"              // for FairTimeStamp

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TClonesArray.h"               // for TClonesArray
#include "TString.h"                    // for TString

#include <iostream>                     // for cout, ostream
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairWriteoutBuffer: public TObject
{
  public:
    FairWriteoutBuffer() : TObject(), fStartTime_map(), fDeadTime_map(), fBranchName(), fClassName(),
      fTreeSave(false), fActivateBuffering(kFALSE), fVerbose(0), fLogger(FairLogger::GetLogger()) {};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    virtual ~FairWriteoutBuffer() {};

    virtual void SaveDataToTree(Bool_t val = kTRUE) {
      fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE) {
      fActivateBuffering=val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the data is directly stored in the given TClonesArray.
    }

   Bool_t IsBufferingActivated(){ return fActivateBuffering;}
  
/// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later data, activeTime gives the time how long the data can influence later data.
/// Both time data has to be given as an absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() {
      return fDeadTime_map.size();
    }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();


    virtual void SetVerbose(Int_t val) {
      fVerbose = val;
    }

    virtual void DeleteOldData() {
      if ( fBranchName.Length() > 0 ) {
        TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
        myArray->Delete();
      }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data) = 0; ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to cast it to your type of data)
    virtual double FindTimeForData(FairTimeStamp* data) = 0;  ///< if the same data object (like a pad or a pixel) is already present in the buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0; ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(FairTimeStamp* data) = 0; ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    ///Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters are the old data with the active time, the new data with an active time.
    ///Modify returns than a vector with the new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*> > Modify(std::pair<double, FairTimeStamp*> oldData, std::pair<double, FairTimeStamp*>) {
      std::vector<std::pair<double, FairTimeStamp*> > result;
      result.push_back(oldData);
      return result;
    }


    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data) {
      std::cout << data->GetTimeStamp();
    }; ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*> > fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;  //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDef(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNONLINE_H
#define FAIRRUNONLINE_H


/**
 * Configure and manage the Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"
#include "FairRootManager.h"

#include "TString.h"
#include <iostream>

class FairRuntimeDb;
class FairField;
class TFile;
class TF1;
class TTree;
class FairSource;
class TFolder;
class THttpServer;

class FairRunOnline : public FairRun
{

  public:
    static FairRunOnline* Instance();
    virtual ~FairRunOnline();
    FairRunOnline();
    FairRunOnline(FairSource* source);

    /**initialize the run manager*/
    void        Init();
    /**Run for the given number of events*/
    void        Run(Int_t Ev_start, Int_t Ev_end);
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField*  GetField() { return fField; }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield) { fField = ffield; }

    /** Set if the run should be closed automatically after executing the
        run functuion
    **/
    void        SetAutoFinish(Bool_t val) { fAutomaticFinish = val; }
    /** Set the source which should be used **/
    void        SetSource(FairSource* source) { fRootManager->SetSource(source); }
    /** Return pointer to source **/
    FairSource*  GetSource() { return fRootManager->GetSource(); }


    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();
    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };

    /** Add histogram to be displayed using THttpServer.*/
    void AddObject(TObject* object);

    /** Activate http server on defined host port. To be called before Init.
     * @param refreshRate an interval in number of events for server update.
     * @param httpPort the port which is used by the http server
     */
    void ActivateHttpServer(Int_t refreshRate = 10000, Int_t httpPort=8080);

    /** Register a command on the http server.
     * @param name a command name starting with /
     * @param command a call to method "/object_name/->Method()"
     */
    void RegisterHttpCommand(TString name, TString command);


    /** Get direct access to the http server. */
    THttpServer* GetHttpServer() { return fServer; }

    /** Write last data to file, close input and output **/
    void Finish();

  private:

    Bool_t fAutomaticFinish;

    FairRunOnline(const FairRunOnline& M);
    FairRunOnline& operator= (const  FairRunOnline&) { return *this; }

    /** Main Event loop **/
    Int_t EventLoop();

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    static FairRunOnline*                   fgRinstance;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;

    Int_t       fNevents;      //!
    THttpServer* fServer;             //!
    Int_t        fServerRefreshRate;  //!

    virtual void Fill();

    ClassDef(FairRunOnline, 0)
};

#endif //FAIRRUNONLINE_H
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include "TObject.h"                    // for TObject
#include "TMCtls.h"                     // for multi-threading

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include <set>							// for set of branch types to ignore


class FairLogger;

//_____________________________________________________________________

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();


    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);		///< Adds a BranchId (Type) to which links are not included in the link list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);	///< Adds a BranchId (Type) to which links are included in the link list. Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const {return fIgnoreTypes;}


  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

//_____________________________________________________________________
    /**private Members*/

    std::set<Int_t> fIgnoreTypes; //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger*                         fLogger;//!


    ClassDef(FairLinkManager,1) // Root IO manager
};

#endif //FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"               // for FairContFact, etc

#include "Rtypes.h"                     // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  private:
    void setAllContainers();
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*);
    ClassDef( FairBaseContFact,0)
};

#endif  /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet

#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairBaseParSet(const char* name="FairBaseParSet",
                   const char* title="Class for base parameter io",
                   const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) {fDetList=array;}
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) {fPriGen=gen;}
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t  BMom) {fBeamMom = BMom;}
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) {fContNameList= list;}
   /**
    * Set the random seed used in a run
    * @param RndSeed: Random Seed
    */
    void SetRndSeed(UInt_t RndSeed) {fRandomSeed= RndSeed;}
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray*             GetDetList() {return fDetList;}
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator*   GetPriGen() {return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t          GetBeamMom() {return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray*             GetContList() {return fContNameList;}
   /**
    *  Get the Random Seed used in this run
    */
    UInt_t  GetRndSeed() {return fRandomSeed;}
   

  protected:

    /// Detectors used in the simulation
    TObjArray*              fDetList;
    ///Generator used for simulation
    FairPrimaryGenerator*   fPriGen;
    ///Beam momentum (GeV/c)
    Double_t              fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray*              fContNameList;
    /// Random Seed from gRandom
    UInt_t                 fRandomSeed;

    ClassDef(FairBaseParSet,6)

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator= (const FairBaseParSet&) {return *this;}



};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet
#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairGeoParSet(const char* name="FairGeoParSet",
                  const char* title="Class for base parameter io",
                  const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) {fGeoNodes=array;}
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) {fGeom=Geom;}
    /**
    *  Get the Geometry Nodes list used in the simulation
    */
    TObjArray*             GetGeoNodes() {return fGeoNodes;}
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager*           GetGeometry() {return fGeom;}

  protected:

    /// List of FairGeoNodes for sensitive volumes
    TObjArray*              fGeoNodes; //!
    /// Full Geometry
    TGeoManager*            fGeom;
    ClassDef(FairGeoParSet,1)

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator= (const FairGeoParSet&) {return *this;}



};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"                 // for FairModule

#include "Rtypes.h"                     // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{

  public:

    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId=0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void   Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits( FairVolume* v=0)=0;
    /**
      this is called at the end of an event
    */
    virtual void   EndOfEvent() {
      ;
    }
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void   Register()=0;

    /** Gets the produced collections **/
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;

    /**
      has to be called after each event to reset the containers
    */
    virtual void   Reset()=0;

    virtual void   CopyClones( TClonesArray*,  TClonesArray*, Int_t) {
      ;
    }

    virtual void   FinishPrimary() {
      ;
    }
    virtual void   FinishRun() {
      ;
    }
    virtual void   BeginPrimary() {
      ;
    }
    virtual void   PostTrack() {
      ;
    }
    virtual void   PreTrack() {
      ;
    }
    virtual void   BeginEvent() {
      ;
    }
    virtual void   FinishEvent() {
      ;
    }
    virtual void   SetSpecialPhysicsCuts() {
      ;
    }
    void SaveGeoParams();
    Int_t  GetDetId() {
      return fDetId;
    }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator= (const FairDetector&);

    Int_t fDetId; // Detector Id has to be set from ctr.
    FairLogger* fLogger;  //! /// FairLogger

    ClassDef(FairDetector,1)

};
#endif //FAIRDETECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "Rtypes.h"                     // for Bool_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
    *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    virtual ~FairGeaneApplication();
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /**
    * Set the magnetic field for simulation or Geane
    * @param field: magnetic field
    */
    void                   SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void          GeaneStepping();                           // MC Application
    void ConstructGeometry();
    /** Singelton instance
     */
    static FairGeaneApplication* Instance();

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() {;}
    void GeneratePrimaries() {;}
    void BeginEvent() {;}
    void BeginPrimary() {;}
    void PreTrack() {;}
    void PostTrack() {;}
    void FinishPrimary() {;}
    void FinishEvent() {;}
    void Stepping() {;}
    void StopRun() {;}


  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Debug flag*/
    Bool_t               fDebug;//!
    TLorentzVector fTrkPos; //!

    ClassDef(FairGeaneApplication,1)  //Interface to MonteCarlo application
  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

// inline functions

inline FairGeaneApplication* FairGeaneApplication::Instance()
{ return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------


/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/


#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, etc

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{

  public:

    /** Default constructor. **/
    FairGenerator();


    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title="FAIR Generator");


    /** Destructor. **/
    virtual ~FairGenerator();


    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;


    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE;}

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator= (const FairGenerator&);

    ClassDef(FairGenerator,1);
};

#endif


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------


/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/


#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include "TClonesArray.h" 
#include "TVirtualMCStack.h"            // for TVirtualMCStack

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TMCProcess.h"                 // for TMCProcess

#include <stddef.h>                     // for NULL

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;


class FairGenericStack : public TVirtualMCStack
{

  public:

    /** Default constructor  **/
    FairGenericStack();


    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);


    /** Destructor  **/
    virtual ~FairGenericStack();


    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is, Int_t secondparentID) = 0;


    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}


    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* detArray=0) {}


    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger*  fLogger;//!

    /** List of detectors registering hits in the simulation */
    TRefArray*  fDetList;  //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    ClassDef(FairGenericStack,1)
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/


#ifndef FAIRION_H
#define FAIRION_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, etc

class FairLogger;

class FairIon: public TNamed
{
  public:

    /** Default constructor **/
    FairIon();


    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e=0., Double_t m=0.);
    void SetParams( const char* name, Int_t z, Int_t a,
                    Int_t q, Double_t e=0., Double_t m=0.) {
      SetName(name);
      fZ=z;
      fA=a;
      fQ=q;
      fExcEnergy=e;
      fMass=m;
    }
    /** Destructor **/
    virtual ~FairIon();


    /** Accessors **/
    /**
    * Return the atomic number
    */
    Int_t GetZ()            const { return fZ; }
    /**
     * Return the atomic mass
    */
    Int_t GetA()            const { return fA; }
    /**
     * Return the charge
    */
    Int_t GetQ()            const { return fQ; }
    /**
    * Return the  excitation energy
    */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
    * Return the mass in GeV
    */
    Double_t GetMass()      const { return fMass; }

    /** Modifiers **/
    /**
    * Set the  excitation energy
    */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
    * Set the mass in GeV
    */
    void SetMass(Double_t mass)      { fMass = mass*amu; }


  private:

    /** Data members **/

    static Int_t fgNIon;  //! /// Number of ions instantiated. One per generator.
    Int_t    fZ;          /// Atomic number
    Int_t    fA;          /// Atomic mass
    Int_t    fQ;          /// Electric charge
    Double_t fExcEnergy;  /// Excitation energy [GeV]
    Double_t fMass;       /// Mass [GeV]
    FairLogger* fLogger;  //! /// FairLogger
    static const Double_t amu; ///  .931494028 Gev/c**2

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon,2);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TString.h"                    // for TString

#include <map>                           // for map, multimap, etc
#include <list>                           // for list

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadGridManager;
class FairRadLenManager;
class FairRadMapManager;
class FairGenericRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;
/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
    *@param name      name
    *@param title     title
    *@param ModList  a TObjArray containing all detectors and modules used in this simulation
    *@param MatName  material file name
    */
    FairMCApplication(const char* name,   const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
    */
    FairMCApplication();
    /** default destructor
    */
    virtual ~FairMCApplication();
    /** Singelton instance
    */
    static FairMCApplication* Instance();
    virtual void          AddDecayModes();
    /**  Add user defined particles (optional) */
    virtual void          AddParticles();                                   // MC Application
    /** Add user defined ions (optional) */
    virtual void          AddIons();                                        // MC Application
    /**
    *Add user defined Tasks to be executed after each event (optional)
    * @param fTask: Task that has to be excuted during simulation
    */
    void                  AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    virtual void          BeginEvent();                                     // MC Application
    /** Define actions at the beginning of primary track */
    virtual void          BeginPrimary();                                   // MC Application
    /** Construct user geometry */
    virtual void          ConstructGeometry();                              // MC Application
    /** Define parameters for optical processes (optional) */
    virtual void          ConstructOpGeometry();                            // MC Application
    /** Define actions at the end of event */
    virtual void          FinishEvent();                                    // MC Application
    /** Define actions at the end of primary track */
    virtual void          FinishPrimary();                                  // MC Application
    /** Define actions at the end of run */
    void                  FinishRun();
    /** Generate primary particles */
    virtual void          GeneratePrimaries();                              // MC Application
    /** Return detector by name  */
    FairDetector*          GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /**Return primary generator*/
    FairPrimaryGenerator*  GetGenerator();
    /**Return list of tasks*/
    TTask*                GetListOfTasks();
    FairGenericStack*      GetStack();
    TChain*               GetChain();
    /** Initialize geometry */
    virtual void          InitGeometry();                                   // MC Application
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /** Initialize Tasks if any*/
    void                  InitTasks();
    /**Define actions at the end of each track */
    virtual void          PostTrack();                                      // MC Application
    /** Define actions at the beginning of each track*/
    virtual void          PreTrack();                                       // MC Application

    /** Clone for worker (used in MT mode only) */
    virtual TVirtualMCApplication* CloneForWorker() const;

    /** Init application on worker (used in MT mode only) */
    virtual void InitOnWorker();

    /** Finish run on worker (used in MT mode only) */
    virtual void FinishRunOnWorker();

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void                  RunMC(Int_t nofEvents);
    /**
    * Set the magnetic field for simulation
    * @param field: magnetic field
    */
    void                  SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void                  SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void                  SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see SetPythiaDecayerConfig)
     */
    void                  SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer=decayer;}
    /**
    * set the decay configuration macro to be used by Pythia
    */
    void                  SetPythiaDecayerConfig(const TString decayerConf) {fPythiaDecayerConfig=decayerConf;}
    /**
    * Switch for using the radiation length manager
    */
    void                  SetRadiationLengthReg(Bool_t RadLen);
    /**
    * Switch for using the radiation map manager
    */
    void                  SetRadiationMapReg(Bool_t RadMap);
    /**
    * Switch for debuging the tracking
    */
    void                  SetTrackingDebugMode( Bool_t set ) {fDebug = set;}
    /**
    * Switch for using 2 or 3 body phase-space decay
    * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config macro (see SetUserDecayConfig)
    */
    void                  SetUserDecay(Bool_t decay) {fUserDecay= decay;}
    /**
    * set the decay configuration macro to be used by user decay
    */
    void                  SetUserDecayConfig(const TString decayerConf) {fUserDecayConfig= decayerConf;}
    /** Define action at each step, dispatch the action to the corresponding detectors */
    virtual void          Stepping();                                       // MC Application
    /** Stop the run*/
    virtual void          StopRun();
    /**Define maximum radius for tracking (optional) */
    virtual Double_t      TrackingRmax() const;                             // MC Application
    /** Define maximum z for tracking (optional) */
    virtual Double_t      TrackingZmax() const;                              // MC Application

    void AddMeshList ( TObjArray* meshList );

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

    // data members
    /**List of active detector */
    TRefArray*           fActiveDetectors;
    /**List of FairTask*/
    FairTask*             fFairTaskList;//!
    /**detector list (Passive and Active)*/
    TRefArray*           fDetectors;
    /**Map used for dispatcher*/
    TRefArray*           fDetMap;
    /**Iterator for Module list*/
    TIterator*           fModIter; //!
    /**Module list in simulation*/
    TObjArray*           fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t                fNoSenVolumes; //!
    /**flag for using Pythia as external decayer */
    Bool_t               fPythiaDecayer;
    /** Pythia decay config macro*/
    TString               fPythiaDecayerConfig; //!
    /** Simulation Stack  */
    FairGenericStack*     fStack; //!
    /**Pointer to thr I/O Manager */
    FairGenericRootManager*  fRootManager; //!
    /**List of sensetive volumes in all detectors*/
    TRefArray*           fSenVolumes; //!
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Track visualization manager */
    FairTrajFilter*       fTrajFilter; //!
    /**Flag for accepted tracks for visualization*/
    Bool_t               fTrajAccepted; //!
    /**Flag for using user decay*/
    Bool_t               fUserDecay;
    /**User decay config macro*/
    TString               fUserDecayConfig; //!
    /** Debug flag*/
    Bool_t               fDebug;//!
    /**dispatcher internal use */
    FairVolume*          fDisVol;
    /**dispatcher internal use */
    FairDetector*         fDisDet;
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* > fVolMap;//!
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* >::iterator fVolIter; //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map <Int_t, Int_t > fModVolMap;//!
    /**dispatcher internal use RadLen*/
    std::map <Int_t, Int_t >::iterator fModVolIter; //!
    TLorentzVector fTrkPos; //!
    /** Flag for Radiation length register mode  */
    Bool_t   fRadLength;  //!

    /**Radiation length Manager*/
    FairRadLenManager*  fRadLenMan; //!
    /** Flag for Radiation map register mode  */
    Bool_t   fRadMap;     //!
    /**Radiation Map Manager*/
    FairRadMapManager*  fRadMapMan; //!
    /**Radiation map Grid Manager*/
    FairRadGridManager* fRadGridMan; //!

    FairEventHeader*    fEventHeader; //!

    FairMCEventHeader*  fMCEventHeader; //!
    /** list of senstive detectors used in the simuation session*/
    std::list <FairDetector *> listActiveDetectors; //!
    /** list of all detectors used in the simuation session*/
    std::list <FairDetector *> listDetectors;  //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC*  fMC;
    /** Pointer to FairRunSim //! */
    FairRunSim*  fRun;
    
    ClassDef(FairMCApplication,4)  //Interface to MonteCarlo application

  private:
    /** Protected copy constructor */
    FairMCApplication(const FairMCApplication&);
    /** Protected assignment operator */
    FairMCApplication& operator=(const FairMCApplication&);

    FairRunInfo fRunInfo;//!
    Bool_t      fGeometryIsInitialized;

    static FairMCApplication* fgMasterInstance;
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{ return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoInterface.h"           // for FairGeoInterface
#include "FairGeoLoader.h"              // for FairGeoLoader
#include "FairGeoNode.h"                // for FairGeoNode
#include "FairGeoVolume.h"              // for FairGeoVolume
#include "FairLogger.h"                 // for FairLogLevel::INFO, etc
#include "FairRun.h"                    // for FairRun
#include "FairRuntimeDb.h"              // for FairRuntimeDb

#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TList.h"                      // for TList (ptr only), TListIter
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator!=

#include <stddef.h>                     // for NULL
#include <string>                       // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TGeoMedium;
class TRefArray;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule:  public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active=kFALSE);
    /**default dtor*/
    virtual  ~FairModule();
    /**Print method should be implemented in detector or module*/
    virtual void        Print(Option_t*) const {;}
    /**Set the geometry file name o be used*/
    virtual void        SetGeometryFileName(TString fname, TString geoVer="0");
    /**Get the Geometry file name*/
    virtual TString     GetGeometryFileName() {return  fgeoName ;}
    /**Get the geometry file version if used*/
    virtual TString     GetGeometryFileVer() {return   fgeoVer ;}
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void        ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void        ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void        ConstructRootGeometry();
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void        ConstructASCIIGeometry();
    /** Modify the geometry for the simulation run using methods of the Root geometry package */
    virtual void        ModifyGeometry() {;}
    /**construct geometry from GDML files*/
    virtual void        ConstructGDMLGeometry(TGeoMatrix*);
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const {;}
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const {;}

    /**template function to construct geometry. to be used in derived classes.*/
    template<class T, class U>
    void ConstructASCIIGeometry(T dataType1, TString containerName="", U datatype2 = NULL);

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for detectors
     * which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t      CheckIfSensitive(std::string name);
    /**called from ConstructRootGeometry()*/
    virtual void        ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void        ExpandNodeForGDML(TGeoNode*);
    /**return the MC id of a volume named vname*/
    virtual Int_t       getVolId( const TString& ) const {return 0;}
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t               GetModId() {return fModId;}
    /**Set the verbose level in this detector*/
    void                SetVerboseLevel(Int_t level) {fVerboseLevel=level;}
    /**return the detector status */
    Bool_t              IsActive() {return fActive;}
    /**set the detector/module id*/
    void                SetModId(Int_t id) {fModId=id;}
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void                SetMotherVolume(TString volName) {fMotherVolumeName=volName;}
    /**called from ConstuctASCIIGeometry*/
    void   ProcessNodes ( TList* aList );
    /**Set the parameter containers*/
    virtual  void       SetParContainers() {;}
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual  void       InitParContainers() {;}
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar;}

    /**list of volumes in a simulation session*/
    static              FairVolumeList*   vList; //!
    /**total number of volumes in a simulaion session*/
    static Int_t        fNbOfVolumes;  //!
    /**list of all sensitive volumes in  a simulaion session*/
    static TRefArray*   svList;   //!

    static TArrayI*     volNumber; //!
    TString             fMotherVolumeName; //!
    FairVolume*   getFairVolume(FairGeoNode* fNode);
    void    AddSensitiveVolume(TGeoVolume* v);
  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);  // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString             fgeoVer;
    TString             fgeoName;
    Int_t               fModId;
    Bool_t              fActive;
    Int_t               fNbOfSensitiveVol; //!
    Int_t               fVerboseLevel;
    TList*              flGeoPar; //!  list of Detector Geometry parameters
    Bool_t              kGeoSaved; //! flag for initialisation

    ClassDef( FairModule,4)
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T dataType1, TString containerName, U)
{
  FairGeoLoader* loader=FairGeoLoader::Instance();
  FairGeoInterface* GeoInterface =loader->getGeoInterface();
  T* MGeo=new T();
  MGeo->print();
  MGeo->setGeomFile(GetGeometryFileName());
  GeoInterface->addGeoModule(MGeo);
  Bool_t rc = GeoInterface->readSet(MGeo);
  if ( rc ) { MGeo->create(loader->getGeoBuilder()); }

  TList* volList = MGeo->getListOfVolumes();
  // store geo parameter
  FairRun* fRun = FairRun::Instance();
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();

  dataType1 = *MGeo;

  if ( "" != containerName) {
    LOG(INFO) << "Add GeoNodes for "<< MGeo->getDescription()
              << " to container " << containerName << FairLogger::endl;

    //    U par=(U)(rtdb->getContainer(containerName));
    U*      par=static_cast<U*>(rtdb->getContainer(containerName));
    TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
    TObjArray* fPassNodes = par->GetGeoPassiveNodes();

    TListIter iter(volList);
    FairGeoNode* node   = NULL;
    FairGeoVolume* aVol=NULL;

    while( (node = static_cast<FairGeoNode*>(iter.Next())) ) {
      aVol = dynamic_cast<FairGeoVolume*> ( node );
      if ( node->isSensitive()  ) {
        fSensNodes->AddLast( aVol );
      } else {
        fPassNodes->AddLast( aVol );
      }
    }
    ProcessNodes( volList );
    par->setChanged();
    par->setInputVersion(fRun->GetRunId(),1);

  }
}


#endif //FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, Double_t, Bool_t, etc
#include "TMCParticleType.h"            // for TMCParticleType
#include "TRef.h"                       // for TRef
#include "TRefArray.h"                  // for TRefArray
#include "TString.h"                    // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name, Int_t z, Int_t a, Int_t s,Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle( Int_t pdg , const TString name, TMCParticleType mcType, Double_t mass, Double_t charge,
                  Double_t lifetime, const TString pType="Ion",  Double_t width=0, Int_t iSpin=0, Int_t iParity=0,
                  Int_t iConjugation=0, Int_t iIsospin=0, Int_t iIsospinZ=0, Int_t gParity=0, Int_t lepton=0,
                  Int_t baryon=0,Bool_t stable=kFALSE);

    FairParticle();

    virtual ~FairParticle();

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    virtual void  Print(Option_t* option = "") const;
    void PrintDaughters() const;

    // get methods
    Int_t            GetPDG() const;
    TParticle*       GetParticle() const;
    FairParticle*     GetMother() const;
    Int_t            GetNofDaughters() const;
    FairParticle*     GetDaughter(Int_t i) const;
    virtual const char* GetName() const {return fname.Data();}
    TMCParticleType  GetMCType()  {return fmcType;}
    Double_t         GetMass()          {return fmass;}
    Double_t         GetCharge()        {return fcharge;}
    Double_t         GetDecayTime()     {return fDecayTime;}
    const TString&   GetPType()         {return fpType;}
    Double_t         GetWidth()         {return fwidth;}
    Int_t            GetSpin()          {return fiSpin;}
    Int_t            GetiParity()        {return fiParity;}
    Int_t            GetConjugation()   {return fiConjugation;}
    Int_t            GetIsospin()       {return fiIsospin;}
    Int_t            GetIsospinZ()      {return fiIsospinZ;}
    Int_t            GetgParity()        {return fgParity;}
    Int_t            GetLepton()        {return flepton;}
    Int_t            GetBaryon()        {return fbaryon;}
    Bool_t           IsStable()         {return fstable;}

  private:

    FairParticle(const FairParticle& P);
    FairParticle& operator= (const  FairParticle&) {return *this;}
    // data members
    Int_t     fpdg;
    TParticle*    fParticle;
    TRef          fMother;
    TRefArray     fDaughters;
    const TString            fname;
    TMCParticleType   fmcType;
    Double_t    fmass;
    Double_t    fcharge;
    Double_t    fDecayTime;
    const TString   fpType;
    Double_t    fwidth;
    Int_t     fiSpin;
    Int_t     fiParity;
    Int_t     fiConjugation;
    Int_t     fiIsospin;
    Int_t     fiIsospinZ;
    Int_t     fgParity;
    Int_t     flepton;
    Int_t     fbaryon;
    Bool_t    fstable;

    ClassDef(FairParticle,3) // Extended TParticle
};

#endif //FAIR_PARTICLE_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3, *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "TNamed.h" // for TNamed

#include "FairGenerator.h" // for FairGenerator

#include <iosfwd>      // for ostream
#include "Rtypes.h"    // for Double_t, Bool_t, Int_t, etc
#include "TObjArray.h" // for TObjArray
#include "TVector3.h"  // for TVector3
#include "TMCProcess.h"

#include <iostream> // for operator<<, basic_ostream, etc

class FairGenericStack;
class FairMCEventHeader;
class TF1;
class TIterator;

class FairPrimaryGenerator : public TNamed {

public:
  /** Default constructor. **/
  FairPrimaryGenerator();

  /** Constructor with name and title **/
  FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

  /** Destructor. **/
  virtual ~FairPrimaryGenerator();

  /** Initialize the generater (if needed!)*/
  virtual Bool_t Init();

  /** Register a generator derived from FairGenerator.  **/
  void AddGenerator(FairGenerator *generator) {
    if (!fGenList) {
      std::cout << "Empty fGenList pointer ! " << std::endl;
      return;
    }
    fGenList->Add(generator);
  }

  /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
  virtual Bool_t GenerateEvent(FairGenericStack *pStack);

  /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
  virtual void AddTrack(Int_t pdgid, Double_t px, Double_t py, Double_t pz,
                        Double_t vx, Double_t vy, Double_t vz,
                        Int_t parent = -1, Bool_t wanttracking = true,
                        Double_t e = -9e9, Double_t tof = 0.,
                        Double_t weight = 0., TMCProcess proc = kPPrimary);

  /** Clone this object (used in MT mode only) */
  virtual FairPrimaryGenerator* ClonePrimaryGenerator() const;

  /** Set beam position and widths.
   *@param beamX0      mean x position of beam at target
   *@param beamY0      mean y position of beam at target
   *@param beamSigmaX  Gaussian beam width in x
   *@param beamSigmaY  Gaussian beam width in y
   **/
  void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX,
               Double_t beamSigmaY);

  /** Set nominal beam angle and angle widths.
   *@param beamAngleX0      mean x angle of beam at target
   *@param beamAngleY0      mean y angle of beam at target
   *@param beamAngleSigmaX  Gaussian beam angle width in x
   *@param beamAngleSigmaY  Gaussian beam angle width in y
   **/
  void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0,
                    Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

  /** Public method SetEventPlane
   **@param phiMin   Lower limit for event plane angle [rad]
   **@param phiMax   Upper limit for event plane angle [rad]
   **If set, an event plane angle will be generated with flat
   **distrtibution between phiMin and phiMax.
   **/
  void SetEventPlane(Double_t phiMin, Double_t phiMax);

  /** Set target position and thickness.
   *@param targetZ   z position of target center
   *@param targetDz  full target thickness
   **/
  void SetTarget(Double_t targetZ, Double_t targetDz);

  /** Set target position for multiple tagets. The thickness
   * is the same for all targets.
   *@param nroftargets   number of targets
   *@param *targetZ      z positions of target center
   *@param targetDz      full target thickness
   **/
  void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

  /** Enable vertex smearing in z and/or xy direction **/
  void SmearVertexZ(Bool_t flag);
  void SmearGausVertexZ(Bool_t flag);
  void SmearVertexXY(Bool_t flag);
  void SmearGausVertexXY(Bool_t flag);

  TObjArray *GetListOfGenerators() { return fGenList; }

  /** Set the pointer to the MCEvent **/
  void SetEvent(FairMCEventHeader *event) {
    fEvent = event;
  };

  /** Accessor to the MCEvent **/
  FairMCEventHeader *GetEvent() {
    return fEvent;
  };

  /** Swich on/off the tracking of a particle*/

  void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

  Int_t GetTotPrimary() { return fTotPrim; }

protected:
  /**  Copy constructor */
  FairPrimaryGenerator(const FairPrimaryGenerator&);
  /**  Assignment operator */
  FairPrimaryGenerator &operator=(const FairPrimaryGenerator&);

  /**  Nominal beam position at target in x [cm] */
  Double_t fBeamX0;
  /** Nominal beam position at target in y [cm]*/
  Double_t fBeamY0;
  /** Beam width (Gaussian) in x [cm]*/
  Double_t fBeamSigmaX;
  /**  Beam width (Gaussian) in y [cm]*/
  Double_t fBeamSigmaY;

  /**  Nominal beam angle at target in x [rad] */
  Double_t fBeamAngleX0;
  /**  Nominal beam angle at target in y [rad] */
  Double_t fBeamAngleY0;
  /**  Actual beam angle at target in x [rad] */
  Double_t fBeamAngleX;
  /**  Actual beam angle at target in y [rad] */
  Double_t fBeamAngleY;
  /** Beam angle width (Gaussian) in x [rad]*/
  Double_t fBeamAngleSigmaX;
  /** Beam angle width (Gaussian) in y [rad]*/
  Double_t fBeamAngleSigmaY;
  /** Actual beam direction at the vertex */
  TVector3 fBeamDirection;

  /** Lower limit for the event plane rotation angle [rad] */
  Double_t fPhiMin;
  /** Upper limit for the event plane rotation angle [rad] */
  Double_t fPhiMax;
  /** Actual event plane rotation angle [rad] */
  Double_t fPhi;

  /**  Nominal z position of center of targets [cm]*/
  Double_t *fTargetZ; //!
  /**  Number of targets;*/
  Int_t fNrTargets;
  /**  Full target thickness [cm]*/
  Double_t fTargetDz;

  /** Vertex position of current event [cm]*/
  TVector3 fVertex;

  /** Number of primary tracks in current event*/
  Int_t fNTracks;

  /**  Flag for uniform vertex smearing in z*/
  Bool_t fSmearVertexZ;
  /**  Flag for gaus vertex smearing in z*/
  Bool_t fSmearGausVertexZ;
  /**  Flag for vertex smearing in xy*/
  Bool_t fSmearVertexXY;
  /**  Flag for gaus vertex smearing in xy*/
  Bool_t fSmearGausVertexXY;
  /**  Flag for beam gradient calculation*/
  Bool_t fBeamAngle;
  /**  Flag for event plane rotation*/
  Bool_t fEventPlane;

  /**  Pointer to MC stack*/
  FairGenericStack *fStack; //!
  /**  List of registered generators */
  TObjArray *fGenList;
  /**  Iterator over generator list */
  TIterator *fListIter; //!
  /**  Pointer to MCEventHeader */
  FairMCEventHeader *fEvent; //!
  /** go to tracking  */
  Bool_t fdoTracking; //!
  /** Number of MC tracks before a Generator is called, needed for MC index
   * update */
  Int_t fMCIndexOffset; //!
  /** Number of all primaries of this run*/
  static Int_t fTotPrim; //!
  /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
  Int_t fEventNr;

  /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
  void MakeVertex();

  /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
  void MakeBeamAngle();

  /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
  void MakeEventPlane();

  ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairGenericRootManager.h
/// \brief Definition of the FairGenericRootManager class
///
/// TVirtualMCRootManager class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairGenericRootManager
#define ROOT_FairGenericRootManager

#include "TObject.h"
#include "TMCtls.h"

class FairWriteoutBuffer;
class FairRootManager;
class TClonesArray; 

/// \brief The interface to the Root IO manager for FairRoot multi-threaded applications.
///
/// Implemented according to TVirtualMCRootManager from Geant4 VMC.

class FairGenericRootManager : public TObject
{
  public:
    FairGenericRootManager();
    virtual ~FairGenericRootManager();     
  
    // static access method
    static FairGenericRootManager* Instance(); 
    
    // static method for activating debug mode
    static void SetDebug(Bool_t debug); 
    static Bool_t GetDebug();

    // methods
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile) = 0;
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile) = 0;
    virtual void                RegisterInputObject(const char* name, TObject* obj) = 0;
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile) = 0;
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer) = 0;

    virtual void  Fill() = 0;
    virtual void  Write() = 0;
    virtual void  CloseOutFile() = 0;
    // virtual void  WriteAndClose() = 0;

    virtual Int_t               GetBranchId(TString const &BrName) = 0;


    // access to the implementation class
    virtual FairRootManager*    GetFairRootManager() const = 0;
    virtual Int_t  GetId() const = 0;
    
    // static data members
    static  Bool_t  fgDebug; // Option to activate debug printings

  private:
    // not implemented
    FairGenericRootManager(const FairGenericRootManager& rhs);
    FairGenericRootManager& operator=(const FairGenericRootManager& rhs);
    
#if !defined(__CINT__)
    static  TMCThreadLocal FairGenericRootManager* fgInstance; // singleton instance
#else
    static                 FairGenericRootManager* fgInstance; // singleton instance
#endif 
};

// inline functions

inline void FairGenericRootManager::SetDebug(Bool_t debug) {
  fgDebug = debug;
}  
  
inline Bool_t FairGenericRootManager::GetDebug() {
  return fgDebug;
}  

#endif //ROOT_FairGenericRootManager
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairRootManagerSim.h
/// \brief Definition of the FairRootManagerSim class
///
/// TMCRootManager class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairRootManagerSim
#define ROOT_FairRootManagerSim

#include "FairGenericRootManager.h"

#include <vector>

class FairRootManager;
class FairWriteoutBuffer;
class TClonesArray; 

/// \brief The Root IO manager for FairRoot multi-threaded applications.
///
/// Implemented according to TMCRootManager from Geant4 VMC.
/// It implements the FairGenericRootManager interface.

class FairRootManagerSim : public FairGenericRootManager
{
  public:
    FairRootManagerSim();
    virtual ~FairRootManagerSim();     
  
    // methods
    // virtual void  Register(const char* name, const char* className, void* objAddress);
    // virtual void  Register(const char* name, const char* className, const void* objAddress);
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile);
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile);
    virtual void                RegisterInputObject(const char* name, TObject* obj);
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);

    virtual void  Fill();
    virtual void  Write();
    virtual void  CloseOutFile();

    virtual Int_t GetBranchId(TString const &BrName);

    virtual FairRootManager*    GetFairRootManager() const { return fRootManager; }
    virtual Int_t  GetId() const { return 0; }

  private:
    // not implemented
    FairRootManagerSim(const FairRootManagerSim& rhs);
    FairRootManagerSim& operator=(const FairRootManagerSim& rhs);

    // data members 
    FairRootManager*  fRootManager;  // The Root manager
};

#endif //ROOT_FairRootManagerSim
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairRootManagerSimMT.h
/// \brief Definition of the FairRootManagerSimMT class
///
/// TMCRootManagerMT class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairRootManagerSimMT
#define ROOT_FairRootManagerSimMT

#include "FairGenericRootManager.h"

#include <vector>

class FairRootManager;
class FairWriteoutBuffer;
class TClonesArray; 

/// \brief The Root IO manager for VMC examples for multi-threaded applications.
///
/// Implemented according to TMCRootManager from Geant4 VMC.
/// It implements the FairGenericRootManager interface.

class FairRootManagerSimMT : public FairGenericRootManager
{
  public:
    FairRootManagerSimMT();
    virtual ~FairRootManagerSimMT();     
  
    // methods
    // virtual void  Register(const char* name, const char* className, void* objAddress);
    // virtual void  Register(const char* name, const char* className, const void* objAddress);
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile);
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile);
    virtual void                RegisterInputObject(const char* name, TObject* obj);
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);

    virtual void  Fill();
    virtual void  Write();
    virtual void  CloseOutFile();

    virtual Int_t GetBranchId(TString const &BrName);

    virtual FairRootManager*    GetFairRootManager() const { return fRootManager; }
    virtual Int_t  GetId() const { return fId; }

  private:
    // not implemented
    FairRootManagerSimMT(const FairRootManagerSimMT& rhs);
    FairRootManagerSimMT& operator=(const FairRootManagerSimMT& rhs);
    
    // methods
    void  LogMessage(const TString& message);
    void  FillWithLock();
    void  FillWithTmpLock();
    void  FillWithoutLock();

    // global static data members
    static  Int_t    fgCounter;         // The counter of instances
    static  Bool_t   fgIsFillLock;      // The if the Fill should be locked 
    static  std::vector<Bool_t>* fgIsFillLocks; // The info per thread if the Fill should be locked

    // data members 
    Int_t             fId;           // This manager ID 
    FairRootManager*  fRootManager;  // The Root manager
};

#endif //ROOT_FairRootManagerSimMT
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>               // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char      uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned char      uuid_t[16];

class FairRunIdGenerator
{
    struct uuid {
      uint32_t time_low;
      uint16_t time_mid;
      uint16_t time_hi_and_version;
      uint16_t clock_seq;
      uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);
  public:
    struct timespec getTimeSpec() {return fTimeSpec;}
    struct timespec getTimeSpecFromTID( unsigned  int ms);
    unsigned  int getTID();

  public:
    FairRunIdGenerator() : fTimeSpec() {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);



};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairVolume::Class, etc
#include "TString.h"                    // for TString
#include "FairModule.h"
#include "FairDetector.h"
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */


class FairVolume : public TNamed
{

  public:

    FairVolume();
    FairVolume(TString name, Int_t id=0, Int_t detid=0,FairModule* fMod=0);
    virtual ~FairVolume();

    //    const char*  GetName() { return fName.Data();}
    //    TString getName() { return fName;}

    void setRealName( TString name ) { fRealName = name;}
    const char* getRealName() { return fRealName.Data();}
    Int_t getVolumeId() { return fVolumeId;}
    Int_t getModId() { return  fModId;}
    void  setModId(Int_t id) { fModId=id;}
    void  setCopyNo(Int_t id) { fCopyNo=id;}
    void  setVolumeId ( Int_t id ) {fVolumeId= id;}
    void  setGeoNode(FairGeoNode* d) {fNode=d;}
    void  setMotherId(Int_t fM) {fMotherId=fM;}
    void  setMotherCopyNo(Int_t CopyNo) {fMotherCopyNo=CopyNo;}

    FairModule*   GetModule()     {return fModule;}
    FairDetector* GetDetector() { return fDetector;}
    void SetModule(FairModule* mod) {
        fModule=mod;
        if (mod->InheritsFrom("FairDetector")){
           fDetector=dynamic_cast<FairDetector *>(mod);
        }
    }

    Int_t getMCid() {return fMCid;}
    Int_t getCopyNo() { return fCopyNo;}
    void  setMCid(Int_t id) {fMCid=id;}
    FairGeoNode* getGeoNode() {return fNode;}
    Int_t getMotherId() { return fMotherId;}
    Int_t getMotherCopyNo() {return fMotherCopyNo;}


  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    //    TString fName;   /**Volume Name in MC*/
    TString fRealName; /**Volume Name in ASCII file*/
    Int_t fVolumeId;       /**Volume Id in GeoManager*/
    Int_t fModId;          /**Module Id in which this volume exist*/
    Int_t fMCid;   /**Volume Id in MC*/
    Int_t fCopyNo;         /**Volume Copy No*/
    Int_t fMotherId; /**Mother Volume Id*/
    Int_t fMotherCopyNo;   /**Mother Volume Copy No*/
    FairDetector* fDetector; /** The Detector which will proccess the hits for this volume*/
    FairModule*   fModule;    /**The Module in which the volume is */
    FairGeoNode*  fNode;     /**Node corresponding to this volume*/
    

    ClassDef(FairVolume,2) // Volume Definition

};

#endif //
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "TObject.h"                    // for TObject

#include "FairVolume.h"

#include "Rtypes.h"                     // for Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

//class FairVolume;

/**
* This Object is only used for internal book keeping!
* @author M. Al-Turany, D. Bertini
* @version 0.1
* @since 12.01.04
*/

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume( TString* name );
    Int_t getVolumeId( TString* name );

    FairVolume* findObject( TString name );
    void addVolume( FairVolume* elem);

    Int_t getEntries () { return fData->GetEntries();}
    FairVolume* At(Int_t pos ) { return ( dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList,1) // Volume List
};

#endif //FAIR_VOLUMELIST_H


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/


#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairWriteoutBuffer.h"
#include "FairRecoEventHeader.h"

#include "TStopwatch.h"
#include "TString.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;
//class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{


  public :

    /** Default constructor **/
    FairEventBuilder();


    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);


    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*> > FindEvents() = 0;
    virtual void          StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void  SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }
    Int_t GetIdentifier() {
      return fIdentifier;
    }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t *option="") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() {
      return fMaxAllowedEventCreationTime;
    };
    void SetMaxAllowedTime(Double_t td) {
      fMaxAllowedEventCreationTime = td;
    };

    void    SetBuilderName(const char* name) {
      fBuilderName=name;
    }
    TString GetBuilderName() {
      return fBuilderName;
    }

  private:

    TString    fBuilderName;

    TStopwatch fTimer;
    Double_t   fExecTime;

    Int_t      fIdentifier;
    Double_t   fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/


#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairTask.h"
#include "FairEventBuilder.h"

#include "TStopwatch.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{


  public :

    /** Default constructor **/
    FairEventBuilderManager();


    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose=1);


    /** Destructor **/
    virtual ~FairEventBuilderManager();


    /** Execution **/
    virtual void Exec(Option_t* opt);


    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:

    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double,FairRecoEventHeader*> > >  fPossibleEvents;


    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();


    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;


    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:

    /** Get parameter containers **/
    virtual void SetParContainers();


    /** Intialisation **/
    virtual InitStatus Init();


    /** Reinitialisation **/
    virtual InitStatus ReInit();


    /** Finish at the end of each event **/
    virtual void Finish();


    ClassDef(FairEventBuilderManager,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, UInt_t, etc

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Get the MC time for this event*/
    Double_t GetEventTime() {return fEventTime;}

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() {return fInputFileId;}

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() {return fMCEntryNo;}

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) {fEventTime=time;}

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) {fInputFileId=id;}

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) {fMCEntryNo=id;}

    /**
     * Destructor
     */
    virtual ~FairEventHeader();
    virtual void Register(Bool_t Persistance = kTRUE);
  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Event Time **/
    Double_t  fEventTime;
    /** Input file identifier, the file description is in the File header*/
    Int_t     fInputFileId;
    /**MC entry number from input chain*/
    Int_t     fMCEntryNo;


    ClassDef(FairEventHeader,3)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, etc
#include "TString.h"                    // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
   **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{

  public:

    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
       * @param runid : unique run id
       */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Return the list of tasks class names */
    TList* GetListOfTasks() {return fTaskList;}

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();


    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);




  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);


    ClassDef(FairFileHeader,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, FairFileInfo::Class, etc
#include "TString.h"                    // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:

    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id,  UInt_t ChId);
    virtual  ~FairFileInfo();


    TString     GetPath()          {return fPath;}
    UInt_t      GetSize()          {return fSize;}
    UInt_t      GetIdentifier()    {return fIdentifier;}
    UInt_t      GetOrderInChain()  {return fInChainId;}

    void        Print(Option_t* option="") const;

    void        SetPath(TString path) {fPath = path;}
    void        SetSize(UInt_t  size) {fSize =size;}
    void        SetIdentifier(UInt_t  id) {fIdentifier =id;}
    void        SetOrderInChain(UInt_t id) {fInChainId =id;}



  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t  fSize;
    /** Signal file identifier used*/
    UInt_t  fIdentifier;
    /** file order in the chain*/
    UInt_t  fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo,1)
};

#endif //FAIRFILEINFO_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Rtypes.h"                     // for Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                   // for TVector3

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
  **@author V.Friese <v.friese@gsi.de>
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{

  public:

    /** Default constructor **/
    FairHit();


    /** Constructor with hit parameters **/
    FairHit(Int_t detID, TVector3& pos, TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();


    /** Accessors **/
    Double_t GetDx()            const { return fDx;                     };
    Double_t GetDy()            const { return fDy;                     };
    Double_t GetDz()            const { return fDz;                     };
    Int_t    GetRefIndex()      const { return fRefIndex;               };
    void PositionError(TVector3& dpos) const;
    Int_t    GetDetectorID()    const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos)       const;



    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index)   { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /*** Output to screen */
    virtual void Print(const Option_t*) const {;}

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& boost::serialization::base_object<FairTimeStamp>(*this);
        ar& fDetectorID;
        ar& fRefIndex;
        ar& fX;
        ar& fY;
        ar& fZ;
        ar& fDx;
        ar& fDy;
        ar& fDz;
    }

  protected:
    friend class boost::serialization::access;

    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t      fRefIndex;       ///< Index of FairMCPoint for this hit
    Int_t      fDetectorID;     ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit,3);
};


inline void FairHit::PositionError(TVector3& dpos) const
{
  dpos.SetXYZ(fDx, fDy, fDz);
}


inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
  fDx = dx;
  fDy = dy;
  fDz = dz;
}


inline void FairHit::SetPositionError(const TVector3& dpos)
{
  fDx = dpos.X();
  fDy = dpos.Y();
  fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const
{
  pos.SetXYZ(fX, fY, fZ);
}


inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairHit::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include "TObject.h"                    // for TObject; ClassDefNV

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Float_t, etc

#include <iostream>                     // for ostream, cout

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink() {};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.) {
      SetFile(file);
      SetEntry(entry);
      SetType(type);
      SetIndex(index);
      SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.) {
      SetFile(-1);
      SetEntry(-1);
      SetType(type);
      SetIndex(index);
      SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const {return fEntry;}
    int GetType() const;
    int GetIndex() const {return fIndex;}
    float GetWeight() const {return fWeight;}

    void SetFile(int file);
    void SetEntry(int entry){fEntry = entry;};
    void SetType(int type);
    void SetIndex(int index){fIndex = index;};

    void SetWeight(Float_t weight) {fWeight = weight;}
    void AddWeight(Float_t weight) {fWeight += weight;}


    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const {
      if ((GetFile() == link.GetFile() || link.GetFile() == -1) &&
		  (GetEntry() == link.GetEntry() || link.GetEntry() == -1) &&
			  GetType() == link.GetType() && GetIndex() == link.GetIndex()) {
        return true;
      } else {
        return false;
      }
    }

    bool operator<(const FairLink& link) const {
		if (GetFile() != -1 && link.GetFile() != -1){
			if (GetFile() < link.GetFile()) 		return true;
			else if (link.GetFile() < GetFile()) 	return false;
		}
		if (GetEntry() != -1 && link.GetEntry() != -1){
			if(GetEntry() < link.GetEntry())		return true;
			else if (link.GetEntry() < GetEntry())	return false;
		}
		if (GetType() < link.GetType())				return true;
		else if (link.GetType() < GetType())		return false;
		if (GetIndex() < link.GetIndex())			return true;
		else if (link.GetIndex() < GetIndex())		return false;

		return false;
    }

    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
      link.PrintLinkInfo(out);
      return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
        void serialize(Archive& ar, const unsigned int)
        {
            ar& fFile;
            ar& fType;
            ar& fEntry;
            ar& fIndex;
            ar& fWeight;
        }


  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;


};

inline FairLink::FairLink() :
   fFile(0),
   fType(0),
   fEntry(-1),
   fIndex(-1),
   fWeight(1.0)
{
}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
  :fFile(0),
   fType(0),
   fEntry(-1),
   fIndex(index),
   fWeight(weight)
{
	SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
  :fFile(0),
   fType(0),
   fEntry(entry),
   fIndex(index),
   fWeight(weight)
{
	SetFile(file);
	SetType(type);
}

inline void FairLink::SetType(int type)
{
	if (type < -1) return;
	fType = type + 1;
}

inline int FairLink::GetType() const
{
	int type = fType;
	return type - 1;
}

inline void FairLink::SetFile(int file)
{
	if (file < -1) return;
	fFile = file + 1;
}

inline int FairLink::GetFile() const
{
	int file = fFile;
	return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/


#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Double_t, UInt_t, etc
#include "TVector3.h"                   // for TVector3

class FairMCEventHeader : public TNamed
{

  public:

    /** Default constructor **/
    FairMCEventHeader();


    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(Int_t iEvent, Double_t x, Double_t y, Double_t z,
                      Double_t t, Double_t b, Int_t nPrim);


    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);


    /** Destructor **/
    virtual ~FairMCEventHeader();


    /** Accessors **/
    UInt_t GetRunID()   const { return fRunId; }     /// run identifier
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Double_t GetX()     const { return fX; }         /// vertex x [cm]
    Double_t GetY()     const { return fY; }         /// vertex y [cm]
    Double_t GetZ()     const { return fZ; }         /// vertex z [cm]
    Double_t GetT()     const { return fT; }         /// event time [ns]
    Double_t GetB()     const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim()    const { return fNPrim; }     /// number of input tracks
    Bool_t IsSet()      const { return fIsSet; }     /// Flag
    Double_t GetRotX()     const { return fRotX; } /// rot. around x-axis [rad]
    Double_t GetRotY()     const { return fRotY; } /// rot. around y-axis [rad]
    Double_t GetRotZ()     const { return fRotZ; } /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }


    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t)       { fT = t; }
    void SetB(Double_t b)          { fB = b; }
    void SetNPrim(Int_t nPrim)     { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet)     { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:


    UInt_t     fRunId;       ///  Run identifier
    UInt_t     fEventId;     ///  Event identifier
    Double32_t fX;           ///  Primary vertex x [cm]
    Double32_t fY;           ///  Primary vertex y [cm]
    Double32_t fZ;           ///  Primary vertex z [cm]
    Double32_t fT;           ///  Event time [s]
    Double32_t fB;           ///  Impact parameter [fm] (if relevant)
    Int_t      fNPrim;       ///  Number of input tracks
    Bool_t     fIsSet;       ///  Flag whether variables are filled
    Double32_t fRotX;        ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;        ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;        ///  Rotation around z-axis (event plane) [rad]


    ClassDef(FairMCEventHeader,2);

};


inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y,
    Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
  fX = vertex.X();
  fY = vertex.Y();
  fZ = vertex.Z();
}


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/



#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TVector3.h"                   // for TVector3


#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class FairMCPoint : public FairMultiLinkedData_Interface
{

  public:

    /** Default constructor **/
    FairMCPoint();


    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                Double_t tof, Double_t length, Double_t eLoss, UInt_t EventId=0);
    
    /** Destructor **/
    virtual ~FairMCPoint();


    /** Accessors */
    UInt_t   GetEventID()    const { return fEventId; }        /// event identifier
    Int_t    GetTrackID()    const { return fTrackID; }
    Double_t GetPx()         const { return fPx; }
    Double_t GetPy()         const { return fPy; }
    Double_t GetPz()         const { return fPz; }
    Double_t GetTime()       const { return fTime; }
    Double_t GetLength()     const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t    GetDetectorID()   const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }




    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id;}
    void SetTime(Double_t time)        { fTime = time; }
    void SetLength(Double_t length)    { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;


    
    template<class Archive>
    void serialize(Archive & ar, const unsigned int) 
    {
        //ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar & fTrackID;
        ar & fEventId;
        ar & fDetectorID; 
        ar & fX;
        ar & fY;
        ar & fZ;
        ar & fPx;
        ar & fPy;
        ar & fPz; 
        ar & fTime; 
        ar & fLength; 
        ar & fELoss; 
    }

  protected:

    friend class boost::serialization::access;

    Int_t fTrackID;               ///< Track index
    UInt_t fEventId;              ///< MC Event id
    Double32_t fPx, fPy, fPz;     ///< Momentum components [GeV]
    Double32_t fTime;             ///< Time since event start [ns]
    Double32_t fLength;           ///< Track length since creation [cm]
    Double32_t fELoss;            ///< Energy loss at this point [GeV]
    Int_t      fDetectorID;       ///< Detector unique identifier
    Double32_t fX, fY, fZ;        ///< Position of hit [cm]


    ClassDef(FairMCPoint,5)

};


inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
  fPx = mom.Px();
  fPy = mom.Py();
  fPz = mom.Pz();
}


inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCPoint::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TH2.h"                        // for TH2D
#include "TString.h"                    // for TString

/**
 * Abstract base class for Mesh Objects.
  **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{

  public:

    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);


    /** Destructor **/
    virtual ~FairMesh();


    /** Accessors **/
    Double_t GetXmin()  const { return fXmin;  };
    Double_t GetYmin()  const { return fYmin;  };
    Double_t GetZmin()  const { return fZmin;  };

    Double_t GetXmax()  const { return fXmax;  };
    Double_t GetYmax()  const { return fYmax;  };
    Double_t GetZmax()  const { return fZmax;  };


    /** Modifiers **/
    void SetX(Double_t xmin,Double_t xmax, Int_t nbin ) {
      fXmin = xmin;
      fXmax = xmax;
      NXbin = nbin;
    }
    void SetY(Double_t ymin,Double_t ymax, Int_t nbin ) {
      fYmin = ymin;
      fYmax = ymax;
      NYbin = nbin;
    }
    void SetZ(Double_t zmin,Double_t zmax, Int_t nbin ) {
      fZmin = zmin;
      fZmax = zmax;
      NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
// virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x , Double_t y , Double_t we ) {
      fMeshTid->Fill(x,y,we);
    }
    void fillFluence(Double_t x , Double_t y , Double_t we ) {
      fMeshFlu->Fill(x,y,we);

    }
    void fillSEU(Double_t x , Double_t y , Double_t we ) {
      fMeshSEU->Fill(x,y,we);

    }
    void Scale(Double_t fac ) {
      fMeshTid->Scale(fac);
      fMeshFlu->Scale(fac);
      fMeshSEU->Scale(fac);
    }

    void calculate();


    void print();
  protected:

    Double_t  fXmin, fYmin, fZmin;
    Double_t  fXmax, fYmax, fZmax;
    Int_t     NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid; // !mesh
    TH2D* fMeshFlu; // !mesh
    TH2D* fMeshSEU; // !mesh
    TString fhname; // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector

class FairMultiLinkedData : public  TObject
{
  public:
    FairMultiLinkedData();///< Default constructor
    FairMultiLinkedData(std::set<FairLink> links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor

    virtual ~FairMultiLinkedData() {};

    virtual std::set<FairLink>    GetLinks() const {    return fLinks;}           ///< returns stored links as FairLinks
    virtual FairLink		GetEntryNr() const { return fEntryNr;}				///< gives back the entryNr
    virtual Int_t           GetNLinks() const { return fLinks.size(); }       ///< returns the number of stored links
    virtual FairLink        GetLink(Int_t pos) const;                 ///< returns the FairLink at the given position
    virtual FairMultiLinkedData   GetLinksWithType(Int_t type) const;             ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink> GetSortedMCTracks();				///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject*         GetData(FairLink& myLink);                  ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType;}
    Bool_t              GetPersistanceCheck() {return fPersistanceCheck;}     ///< Returns the value of PersistanceCheck
    Int_t             GetVerbose() {return fVerbose;}             ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) {  fDefaultType = type;}
    virtual void SetPersistanceCheck(Bool_t check) {fPersistanceCheck = check;}       ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) {fVerbose = level;}                ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val){ fInsertHistory = val;}		///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const {return fInsertHistory;}

    virtual void SetEntryNr(FairLink entry){ fEntryNr = entry;}
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);                         ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(FairLink link);                      ///< Adds the FairLinks of the inserted link to the set of links of this object


    virtual void AddAllWeights(Double_t weight);                        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);                        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);                   ///<Multiplies all Links with weight


    virtual Bool_t IsLinkInList(FairLink link)    {return IsLinkInList(link.GetType(), link.GetIndex());}   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(Int_t type, Int_t index);                             ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)  {return LinkPosInList(link.GetType(), link.GetIndex());}    ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);                             ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)    {DeleteLink(link.GetType(), link.GetIndex());}          ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);                               ///< Deletes a link ouf of fLinks

    virtual void Reset() {ResetLinks();}
    virtual void ResetLinks() {fLinks.clear();}                                    ///< Clears fLinks


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
      out << GetEntryNr() << " -> [";
      for (Int_t i = 0; i < GetNLinks(); i++) {
        GetLink(i).PrintLinkInfo(out);
        out << " ";
      }
      out << "]";
      return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck; //!
    Bool_t fInsertHistory; //!
    Int_t fVerbose; //!

    virtual void SimpleAddLinks(Int_t fileId, Int_t evtId, Int_t dataType, std::vector<Int_t> links, Bool_t, Float_t) {
      for (UInt_t i = 0; i < links.size(); i++) {
        fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
      }
    }
    Int_t fDefaultType;


    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FAIRMULTILinkedData_H_ */
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink
#include "FairMultiLinkedData.h"
#include "FairRootManager.h"

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString
#include "TRef.h"

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector


class FairMultiLinkedData_Interface : public  TObject
{
  public:
    FairMultiLinkedData_Interface();///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData_Interface(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    virtual ~FairMultiLinkedData_Interface() {
    	delete(fLink);
    };

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    virtual std::set<FairLink>  GetLinks() const;           		///< returns stored links as FairLinks
    virtual Int_t           	GetNLinks() const;                	///< returns the number of stored links
    virtual FairLink        	GetLink(Int_t pos) const;         	///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(Int_t type) const; ///< returns all FairLinks with the corresponding type
    virtual FairLink            GetEntryNr() const;
    FairMultiLinkedData* 	GetPointerToLinks() const { return fLink;}

    virtual std::vector<FairLink> GetSortedMCTracks();

    virtual void SetLinks(FairMultiLinkedData links);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link);      					///< Sets the Links with a single FairLink
    virtual void SetInsertHistory(Bool_t val);
    virtual void SetEntryNr(FairLink val);
    virtual void SetPointerToLinks(FairMultiLinkedData* links) {fLink = links;}

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);		///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    virtual void AddLink(FairLink link);      									///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise
    virtual void AddInterfaceData(FairMultiLinkedData_Interface* data);



    virtual void ResetLinks();


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const {

		if (GetPointerToLinks() != 0)
			GetPointerToLinks()->PrintLinkInfo(out);
		return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    FairMultiLinkedData* fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();

    ClassDef(FairMultiLinkedData_Interface, 5);
};

inline
FairMultiLinkedData_Interface::FairMultiLinkedData_Interface()
  :TObject(), fLink(NULL)
{
}


/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------


/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadLenPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss, TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Float_t  fRadLen);


    /** Destructor **/
    virtual ~FairRadLenPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()              { return fZmat; }
    Float_t GetRadLength()      { return fRadLen;}
    Float_t GetDensity()        { return fDensity ; }


    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)              { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }


  protected:

    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Float_t        fRadLen;     // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadLenPoint,1)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------


/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadMapPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss,
                    TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Double_t fVolMass,
                    Double_t fStep, Double_t fDose, Double_t fDoseSL, Int_t fPdg );


    /** Destructor **/
    virtual ~FairRadMapPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()             { return fZmat; }
    Float_t GetMass()           { return fVolMass;}
    Float_t GetDensity()        { return fDensity ; }

    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)             { fZmat = Z; }
    void SetMass(Double_t vmass)       { fVolMass = vmass;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg;};

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose;}
    Double_t GetDoseSL() const { return fDoseSL;}

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }



  protected:

    //  Int_t          detID;       // detector ID or volume ID
    Int_t          fPdg;        // track PID
    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Double_t       fVolMass;     // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadMapPoint,3)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H


#include "TNamed.h"

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
  **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const {
      return fRunId;
    }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const {
      return fEventTime;
    }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const {
      return fEventTimeError;
    }

    /** Get identifier*/
    Int_t GetIdentifier() const {
      return fIdentifier;
    }

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {
      fRunId=runid;
    }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr) {
      fEventTime=time;
      fEventTimeError=terr;
    }

    /** Set the run ID for this run
    * @param ident : identifier
    */
    void SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const {
      if (fEventTime < tempObj.GetEventTime()) { return true; }
      else if (fEventTime > tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const {
      if (fEventTime > tempObj.GetEventTime()) { return true; }
      else if (fEventTime < tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const {
      if   (fEventTime == tempObj.GetEventTime() ) {
        return true;
      }
      return false;
    }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t     fIdentifier;
    /** Event Time **/
    Double_t  fEventTime;
    /** Event Time Error **/
    Double_t  fEventTimeError;

    ClassDef(FairRecoEventHeader,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Long_t, etc
#include "TSystem.h"                    // for CpuInfo_t, MemInfo_t, etc
#include "TTimeStamp.h"                 // for TTimeStamp

#include <vector>                       // for vector

class FairLogger;
class TList;

class FairRunInfo : public TObject
{

  public:

    FairRunInfo();

    ~FairRunInfo();

    void StoreInfo();

    void WriteInfo();

    void Reset();

  private:

    TTimeStamp  fTimeStamp;//!
    CpuInfo_t   fCpuInfo;//!
    MemInfo_t   fMemInfo;//!
    ProcInfo_t  fProcInfo;//!
    std::vector<Double_t> fTimeDiff;//!
    std::vector<Double_t> fTime;//!
    std::vector<Long_t> fResidentMemory;//!
    std::vector<Long_t> fVirtualMemory;//!

    void CalculateTimeDifference();

    void PrintInfo();

    void GetInfo();

    void CreateAndFillHistograms(TList* histoList);

    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "FairLink.h"                   // for FairLink

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Double_t, etc

#include <iostream>                     // for ostream, cout

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp()             const { return fTimeStamp; }
    Double_t GetTimeStampError()     const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) {fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const {
      if (this == obj) { return 0; }
      FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
      Double_t ts = tsobj->GetTimeStamp();
      Double_t tserror = tsobj->GetTimeStampError();
      if (fTimeStamp < ts) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError < tserror) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError == tserror) { return 0; }
      else { return 1; }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE;};

    virtual bool equal(FairTimeStamp* data) {
      return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
      link.PrintTimeInfo(out);
      return out;
    }

    virtual bool operator< (const FairTimeStamp* rValue) const {
    	if (GetTimeStamp() < rValue->GetTimeStamp())
    		return true;
    	else
    		return false;
    }

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        // ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar& fTimeStamp;
        ar& fTimeStampError;
    }

  protected:
    friend class boost::serialization::access;

    Double_t fTimeStamp;        /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError;     /** Error on time stamp */

    ClassDef(FairTimeStamp,4);
};

// -----   Default constructor   -------------------------------------------
inline
FairTimeStamp::FairTimeStamp()
  : FairMultiLinkedData_Interface(),
    fTimeStamp(-1),
    fTimeStampError(-1)
{
}

// -----   Standard constructor   ------------------------------------------
inline
FairTimeStamp::FairTimeStamp(Double_t time)
  : FairMultiLinkedData_Interface(),
    fTimeStamp(time),
    fTimeStampError(-1)
{
}

inline
FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
  : FairMultiLinkedData_Interface(),
    fTimeStamp(time),
    fTimeStampError(timeerror)
{
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------


/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/


#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TMatrixFSymfwd.h"             // for TMatrixFSym
#include "TVector3.h"                   // for TVector3

class FairTrackParam : public TObject
{

  public:

    /** Constructor **/
    FairTrackParam();


    /** Constructor with all variables **/
    FairTrackParam(Double_t x,  Double_t y,  Double_t z,
                   Double_t tx, Double_t ty, Double_t qp,
                   const TMatrixFSym& covMat);


    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);


    /** Destructor **/
    virtual ~FairTrackParam();


    /** Output to screen **/
    void  Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX()  const { return fX; };
    Double_t GetY()  const { return fY; };
    Double_t GetZ()  const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;


    /** Modifiers **/
    void SetX(Double_t x)   { fX  = x;  };
    void SetY(Double_t y)   { fY  = y;  };
    void SetZ(Double_t z)   { fZ  = z;  };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);


    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par );



  private:

    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];


    ClassDef(FairTrackParam,1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------


/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to GEANT3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Double_t, Bool_t, etc
#include "TVirtualMagField.h"

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, basic_ostream, etc

#include "FairLogger.h"


class FairField : public TVirtualMagField
{

  public:

    /** Default constructor **/
    FairField();


    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) {return *this;}

    /** Destructor **/
    virtual ~FairField();


    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init() { };

    /** Test whether field type is Constant **/
    Bool_t IsConst();


    /** Test whether field typ is Map **/
    Bool_t IsMap();


    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }


    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBx Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBy Should be implemented in User class"<<FairLogger::endl; return 0;}

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBz Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get magnetic field. For use of GEANT3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);


    void Field(const Double_t point[3], Double_t* B) {GetFieldValue(point,B);}


    /** Screen output. To be implemented in the concrete class. **/
    virtual void  Print(Option_t*) const {;}
    virtual void GetBxyz(const Double_t[3], Double_t*) {LOG(WARNING)<<"FairField::GetBxyz Should be implemented in User class"<<FairLogger::endl;}



    /**Fill Paramater*/

    virtual void FillParContainer() {LOG(WARNING)<<"FairField::FillParContainer Should be implemented in User class"<<FairLogger::endl;}
  protected:

    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    //TODO: Check why the htrack needs this
    ClassDef(FairField,4);

};




#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------


#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include "Rtypes.h"                     // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{

  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() {
      FairField* field=0;
      if(fCreator) { field= fCreator->createFairField(); }
      return field;
    };
    virtual void SetParm() {
      if(fCreator) { fCreator->SetParm(); }
    }

  protected:
    FairFieldFactory* fCreator;
    static FairFieldFactory*  fgRinstance;

    ClassDef(FairFieldFactory,1)
  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator= (const  FairFieldFactory&) {return *this;}

};
#endif //FAIRFIELDFACTORY_H







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
* Runge-Kutte Track propagator
* @author M. Al-Turany
* @version 0.1
* @since 22.1.10
*/

#ifndef RKPropagator
#define RKPropagator

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, etc

class FairField;

class FairRKPropagator : public TObject
{

  private:
    FairRKPropagator(const FairRKPropagator&);            // Not implemented
    FairRKPropagator& operator=(const FairRKPropagator&); // Not implemented
    Double_t fMaxStep;
    FairField*              fMagField;
  public:
    void Step(Double_t Charge, Double_t* vecRKIn, Double_t* vecOut);
    Double_t OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
    FairRKPropagator(FairField* field);
    /**Propagate to closest approach of a point
    @CHARGE    Particle charge
    @STEP      maximum Step size
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vecOut    Output co-ords,direction cosines,momentum
    */
    void Propagat(Double_t Charge, Double_t* vecRKIn, Double_t* Pos);

    /**Propagate to closest approach of a plane
    @CHARGE    Particle charge
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vec1      vector on the plane
    @vec2      vector on the plane
    @vec3      point on the plane
    @vecOut    Output co-ords,direction cosines,momentum
    */

    void PropagatToPlane(Double_t Charge, Double_t* vecRKIn, Double_t* vec1, Double_t* vec2, Double_t* vec3, Double_t* vecOut);

    virtual ~FairRKPropagator();
    ClassDef(FairRKPropagator, 1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "TObject.h"

#include <iostream>

class FairEventHeader;

enum Source_Type {kONLINE, kFILE};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void Reset() = 0;

    virtual Bool_t   ActivateObject(TObject**, const char*)  { return kFALSE; }
    virtual Bool_t   ActivateObjectAny(void **, const std::type_info &, const char*) { return kFALSE; }

    virtual Source_Type GetSourceType() = 0;

    virtual void SetParUnpackers() = 0;

    virtual Bool_t InitUnpackers() = 0;

    virtual Bool_t ReInitUnpackers() = 0;

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t=0) {return -1;}
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char*) {return;}
    virtual void   ReadBranchEvent(const char*, Int_t) {return;}
    virtual void FillEventHeader(FairEventHeader* feh);

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const     { return fRunId;  }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TFolder.h"
#include "TF1.h"
class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;

class FairFileSource : public FairSource
{
public:
    FairFileSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairFileSource(const FairFileSource& file);
    virtual ~FairFileSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName);
    /**Read specific tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName, Int_t Entry);
    virtual void FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/
    void                AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void                AddFile(TString FileName);
    void                AddFriendsToChain();
    void                PrintFriendList();
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    void                CheckFriendChains();
    void                CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree*              GetInTree() {return fInChain->GetTree();}
    TChain*             GetInChain() {return fInChain;}
    TFile*              GetInFile() {return  fRootFile;}
    void                CloseInFile() { if(fRootFile) { fRootFile->Close(); }}
    /**Set the input tree when running on PROOF worker*/
    void                SetInTree (TTree*  tempTree);
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void                SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    //    virtual Bool_t   SetObject(TObject* obj, const char* ObjType);
    //    virtual void     SetObjectName(const char* ObjName, const char* ObjType);

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);
    virtual Bool_t   ActivateObjectAny(void **, const std::type_info &, const char*);

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void                SetCheckFileLayout(Bool_t enable) {fCheckFileLayout = enable;}

private:
    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** Current Entry number */
    Int_t                             fCurrentEntryNr;  //!
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /**Input Chain */
    TChain*                             fInChain;
    /**Input Tree */
    TTree*                              fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;
    
    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
     Bool_t                                 fCheckFileLayout; //!

    ClassDef(FairFileSource, 3)
};


#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TF1.h"

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;
class TFolder;

class FairRootManager;

class FairMixedSource : public FairSource
{
public:
    FairMixedSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString RootFileName, const Int_t signalId, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairMixedSource(const FairMixedSource& file);
    virtual ~FairMixedSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName);
    /** Read specific tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName, Int_t Entry);

    void                FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    void             ReadBKEvent(UInt_t i=0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void                  SetSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void                  SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void                  AddSignalFile(TString name, UInt_t identifier );
    void                  AddBackgroundFile(TString name);

    TChain*             GetBGChain() { return  fBackgroundChain;}
    TChain*             GetSignalChainNo(UInt_t i);

    Bool_t            OpenBackgroundChain();
    Bool_t            OpenSignalChain();

    /**Set the signal to background ratio in event units
    *@param background :  Number of background Events for one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
    *@param background :  Time of background Events before one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    /**Add ROOT file to input, the file will be chained to already added files*/
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    /**Set the input tree when running on PROOF worker*/
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

private:
    /**IO manager */
    FairRootManager*         fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**Output Event Header*/
    FairEventHeader*                        fOutHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t                                  fNoOfBGEntries; //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t>                fCurrentEntry; //! 

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t>              fSignalBGN;//! 
    /* /\**True for background window in entry units*\/ */
    Bool_t                                  fSBRatiobyN;  //! 
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t                                  fSBRatiobyT;  //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t                              fActualSignalIdentifier; //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t                              fNoOfSignals; //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>*                  fSignalChainList; //!
    /**Chain containing the background*/
    TChain*                              fBackgroundChain; //!
    std::map<UInt_t, TChain*>            fSignalTypeList;//!

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);
    
public:
    ClassDef(FairMixedSource, 0)
};


#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRONLINESOURCE_H
#define FAIRONLINESOURCE_H

#include "FairSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairOnlineSource : public FairSource
{
  public:
    FairOnlineSource();
    FairOnlineSource(const FairOnlineSource& source);
    virtual ~FairOnlineSource();

    inline void AddUnpacker(FairUnpack* unpacker) { fUnpackers->Add(unpacker); }
    inline const TObjArray* GetUnpackers() const { return fUnpackers; }

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void SetParUnpackers();

    virtual Bool_t InitUnpackers();

    virtual Bool_t ReInitUnpackers();

    void Reset();

    virtual Source_Type GetSourceType() { return kONLINE; }

  protected:
    TObjArray* fUnpackers;

  private:
    FairOnlineSource& operator=(const FairOnlineSource&);

    ClassDef(FairOnlineSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                           FairLmdSource                           -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRLMDSOURCE_H
#define FAIRLMDSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"


class TList;


class FairLmdSource : public FairMbsSource
{
  public:
    FairLmdSource();
    FairLmdSource(const FairLmdSource& source);
    virtual ~FairLmdSource();

    void AddFile(TString fileName);
    void AddPath(TString dir, TString wildCard);
    inline Int_t GetCurrentFile() const { return fCurrentFile; }
    inline const TList* GetFileNames() const { return fFileNames; }

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

  protected:
    Bool_t OpenNextFile(TString fileName);

    Int_t fCurrentFile;
	Int_t fNEvent;
	Int_t fCurrentEvent;
    TList* fFileNames;
    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;
	s_filhe* fxInfoHeader;

    FairLmdSource& operator=(const FairLmdSource&);

    ClassDef(FairLmdSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                          FairRemoteSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRREMOTESOURCE_H
#define FAIRREMOTESOURCE_H

#include "FairMbsSource.h"


class TSocket;
class MRevBuffer;
class REvent;


class FairRemoteSource : public FairMbsSource
{
  public:
    FairRemoteSource(char* node);
    FairRemoteSource(const FairRemoteSource& source);
    virtual ~FairRemoteSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    inline const char* GetNode() const { return fNode; }

  private:
    char* fNode;
    TSocket* fSocket;
    MRevBuffer* fBuffer;
    REvent* fREvent;

    FairRemoteSource& operator=(const FairRemoteSource&);
    
  public:
    ClassDef(FairRemoteSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSOURCE_H
#define FAIRMBSSOURCE_H

#include "FairOnlineSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairMbsSource : public FairOnlineSource
{
  public:
    FairMbsSource();
    FairMbsSource(const FairMbsSource& source);
    virtual ~FairMbsSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

  protected:
    Bool_t Unpack(Int_t* data, Int_t size,
                  Short_t type, Short_t subType,
                  Short_t procId, Short_t subCrate, Short_t control);

    ClassDef(FairMbsSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairUnpack                            -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRUNPACK_H
#define FAIRUNPACK_H

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TObject.h"


class FairUnpack : public TObject
{
  public:
    FairUnpack(Short_t type, Short_t subType,
               Short_t procId, Short_t subCrate, Short_t control);
    virtual ~FairUnpack();

    virtual Bool_t Init() = 0;
    virtual Bool_t ReInit() { return kTRUE; }
    virtual Bool_t DoUnpack(Int_t* data, Int_t size) = 0;
    virtual void   Reset() = 0;
    virtual void   SetParContainers() {  };

    inline Short_t GetType()    const { return fType;     }
    inline Short_t GetSubType() const { return fSubType;  }
    inline Short_t GetProcId()  const { return fProcId;   }
    inline Short_t GetSubCrate() const { return fSubCrate; }
    inline Short_t GetControl()  const { return fControl;  }

  private:
    Short_t fType;
    Short_t fSubType;
    Short_t fProcId;
    Short_t fSubCrate;
    Short_t fControl;

  protected:
    virtual void Register() = 0;

  public:
    ClassDef(FairUnpack, 0)
};


#endif



/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//////////////////////////////////////////////////////////////////////
// Copyright:
//   GSI, Gesellschaft fuer Schwerionenforschung mbH
//   Planckstr. 1
//   D-64291 Darmstadt
//   Germany
// created 16. 2.1999 by Horst Goeringer
//////////////////////////////////////////////////////////////////////
// MRevBuffer.h
//   description of class MRevBuffer
//   ROOT client package for multithreaded remote event server (MBS)
//////////////////////////////////////////////////////////////////////
// 20. 8.1999, H.G.: MRevBuffer::RevGetI added
//  6. 3.2000, H.G.: new member function RevStatus
//////////////////////////////////////////////////////////////////////

#ifndef MRevBuffer_H
#define MRevBuffer_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, ClassDef, etc

class TSocket;

class REvent : public TObject
{
  private:
    Int_t  iSize;              // event size (byte)
    Int_t  iNumb;              // event number
    Int_t*  piData;            // event parameter

    REvent(const REvent&);
    REvent& operator=(const REvent&);

  public:
    REvent();                  // constructor
    ~REvent();                 // destructor

    void ReFillHead(Int_t* pHead);   // unpack and fill event header
    void ReFillData(Int_t* pData);   // unpack and fill event data

    Int_t ReGetNumb();               // get event number
    Int_t ReGetSize();               // get event size
    Int_t ReGetData(Int_t ichan);    // get event parameter ichan
    Int_t* GetData() { return piData; }

    Int_t nSubEvt;
    Int_t subEvtSize[100];
    Short_t subEvtType[100];
    Short_t subEvtSubType[100];
    Short_t subEvtProcId[100];
    Short_t subEvtSubCrate[100];
    Short_t subEvtControl[100];
    Int_t* pSubEvt[100];

    ClassDef(REvent, 0)           // prototype for event
};

//////////////////////////////////////////////////////////////////////

class MRevBuffer : public TObject
{
  private:
    TSocket* pTSocket;     // ptr socket of channel to event server
    Int_t  iSocket;        // socket id of channel to event server
    Int_t  iBufNo1;        // first buffer no. received (test)
    Int_t  iBufNo2;        // last buffer no. received (test)
    Int_t  iDebug;         // verbosity level (test)
    Int_t  iSwap;          // > 0: swap event data
    Int_t  iStatus;        // current status of server

    Int_t  iBufSizeAlloc;  // allocated buffer size
    Int_t  iBufSize;       // size current buffer
    Int_t  iBufNo;         // current buffer no.
    Int_t  iFragBegin;     // > 0: last buffer ended with fragment
    Int_t  iFragConc;      // no. of concatenated fragments
    Int_t  iFragBeginIgn;  // no. of ignored fragment begins
    Int_t  iFragEndIgn;    // no. of ignored fragment ends

    Int_t  iHeadPar;       // no. of (4 byte) parms buffer header
    Int_t  iEvtMax;        // no. of events requested
    Int_t  iEvtNo;         // last event no. handled
    Int_t  iEvtRel;        // rel. event no. in buffer
    Int_t  iEvtBuf;        // no. of events in current buffer
    Int_t  iEvtPar;        // no. of parameters in event (incl. len)
    Int_t*  piBuf;         // ptr event buffer
    Int_t*  piNextEvt;     // ptr first element next event
    REvent* pEvt;          // ptr event class

    MRevBuffer(const MRevBuffer&);
    MRevBuffer& operator=(const MRevBuffer&);

  public:
    MRevBuffer( Int_t iMode); // constructor
    ~MRevBuffer();            // destructor

    TSocket* RevOpen( char* pNode, Int_t iPort, Int_t iEvent);
    // input: node name and port number server, req. no. of events
    // returns Socket ptr of server connection

    Int_t* RevGetI( TSocket* pSocket, Int_t iFlush);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)

    REvent* RevGet( TSocket* pSocket, Int_t iFlush, Int_t iSkip);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)
    // iSkip > 0: take only each iSkip event (not impl)

    Int_t RevStatus(Int_t iOut);
    // get status information (iOut = 1: also message to stdout)
    // = 0: last event request successfull
    // = 1: server not yet connected
    // = 2: server connected, but still no request for events
    // = 3: server connection okay, but currently no DAQ events
    // = 4: connection to server closed
    // = 5: connection to server closed after user break (CTL C)
    // = 6: connection to server closed after failure

    void RevBufWait(Int_t iWait);
    // wait for iWait seconds

    Int_t RevBufsize();
    // get size of current buffer (byte)

    void  RevClose( TSocket* pSocket );           // input Socket ptr

    ClassDef(MRevBuffer, 0)        // prototype for remote event buffer
};

#endif     // !MRevBuffer_H 
// -----------------------------------------------------------------------------
// ----- FairMbsStreamSource header file                                   -----
// -----                                                                   -----
// ----- created by C. Simon on 2014-09-12                                 -----
// -----                                                                   -----
// ----- based on FairLmdSource by D. Kresan                               -----
// -----                                                                   -----
// ----- revision 23363, 2013-12-26                                        -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSTREAMSOURCE_H
#define FAIRMBSSTREAMSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"

class FairMbsStreamSource : public FairMbsSource
{
  public:
    FairMbsStreamSource(TString tServerName);
    FairMbsStreamSource(const FairMbsStreamSource& source);
    virtual ~FairMbsStreamSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    const char* GetServerName() const {return fServerName.Data();};

  private:
    Bool_t ConnectToServer();

    TString fServerName;

    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;

    FairMbsStreamSource& operator=(const FairMbsStreamSource&);


  public:
    ClassDef(FairMbsStreamSource, 0)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

G__BaseDict dictionary payload:1572:32: error: base class has incomplete type
class FairRunAnaProof : public FairRunAna
                        ~~~~~~~^~~~~~~~~~
G__BaseDict dictionary forward declarations' payload:16:7: note: forward declaration of 'FairRunAna'
class FairRunAna;
      ^
In file included from G__BaseDict dictionary payload:1673:
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairMCApplication.h:282:17: error: field has incomplete type 'FairRunInfo'
    FairRunInfo fRunInfo;//!
                ^
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairRunInfo.h:22:7: note: definition of 'FairRunInfo' is not complete until the closing '}'
class FairRunInfo : public TObject
      ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRunInfo with content:

#line 1 "G__BaseDict dictionary payload"

#ifndef G__VECTOR_HAS_CLASS_ITERATOR
  #define G__VECTOR_HAS_CLASS_ITERATOR 1
#endif
#ifndef BUILD_MBS
  #define BUILD_MBS 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "TSelector.h"                  // for TSelector

#include "FairLogger.h"                 // for FairLogger, MESSAGE_ORIGIN

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TSelectorList.h"              // for TSelectorList
#include "TString.h"                    // for TString
#include "TTree.h"                      // for TTree

#include <stddef.h>                     // for NULL

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;
class TString;

class FairAnaSelector : public TSelector
{
  public :
    TProofOutputFile*     fProofFile;
    TFile*                fFile;
    TTree*                fChain;   //!pointer to the analyzed TTree or TChain
    FairRunAnaProof*      fRunAna;

    FairAnaSelector(TTree* /*tree*/ =0) : fProofFile(0), fFile(0), fChain(0), fRunAna(NULL), fLogger(FairLogger::GetLogger()), fProofSource(0), fCurrentDirectory("") { }

    virtual ~FairAnaSelector() { }
    virtual Int_t   Version() const {
      return 1;
    }
    virtual void    Begin(TTree* tree);
    virtual void    SlaveBegin(TTree* tree);
    virtual void    Init(TTree* tree);
    virtual Bool_t  Notify();
    virtual Bool_t  Process(Long64_t entry);
    virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) {
      return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    virtual void    SetOption(const char* option) {
      fOption = option;
    }
    virtual void    SetObject(TObject* obj) {
      fObject = obj;
    }
    virtual void    SetInputList(TList* input) {
      fInput = input;
    }
    virtual TList*  GetOutputList() const {
      return fOutput;
    }
    virtual void    SlaveTerminate();
    virtual void    Terminate();

    void SetFairRunAnaProof(FairRunAnaProof* runAna) {
      fRunAna = runAna;
    }

  protected:
    /** Fair Logger */
    FairLogger*             fLogger;//!

  private:

    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDef(FairAnaSelector,0);
};

#endif //FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1


#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TObjArray.h"                  // for TObjArray

#include <iostream>                     // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;


/**
 * @class FairRadGridManager
 */


class FairRadGridManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     * The pointer to this object can be reached via FairRadGridManager::Instance().
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager,1);


  private:

    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;              //!
    /**track length */
    Double_t       fLength;            //!
    /** energy loss */
    Double_t       fELoss;             //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;

    static Double_t fLtmp;
  public:

    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList ( TObjArray* list ) {
      std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
      fMeshList = list;
    }
    Bool_t  IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t  IsTrackEntering(TLorentzVector& vec1,TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     */
    static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1


#include "Rtypes.h"                     // for Float_t, Double_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;

/**
 * @class FairRadLenManager
 */


class FairRadLenManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     * The pointer to this object can be reached via FairRadLenManager::Instance().
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager,1);


  private:

    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /** energy loss */
    Double_t       fELoss;               //!
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /**  density */
    Float_t        fDensity;
    /**radition length */
    Float_t        fRadl;
    /**absorption length */
    Float_t        fAbsl;

  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     */
    static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class TClonesArray;
class TMap;

/**
 * @class FairRadMapManager
 */


class FairRadMapManager
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     * The pointer to this object can be reached via FairRadMapManager::Instance().
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager,1);


  private:

    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray*  fPointCollection;
    /**track index */
    Int_t          fTrackID;           //!
    /**volume id */
    Int_t          fVolumeID;          //!
    /** pid */
    Int_t          fPdg;                //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;             //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;            //!
    /**  momentum in*/
    TLorentzVector fMomIn;             //!
    /**  momentum out*/
    TLorentzVector fMomOut;            //!
    /**track time */
    Double_t       fTime;                //!
    /**track length */
    Double_t       fLength;              //!
    /**track setp */
    Double_t       fStep;
    /** energy loss */
    Double_t       fELoss;               //!
    /**dose */
    Double_t        fDose;
    Double_t       fDoseSL;
    /** mass umber*/
    Float_t        fA;
    /** atomic number*/
    Float_t        fZmat;
    /** radiation length*/
    Float_t        fRadl;
    /**  density */
    Float_t        fDensity;
    /**absorption length */
    Float_t        fAbsl;
    //**volume, mass */
    Double_t       fActVol;
    Double_t       fActMass;

    TMap* fMassMap;


  public:
    /**Add point to collection*/
    void  AddPoint(Int_t& ModuleId);
    /**initialize the manager*/
    void  Init();
    /**reset*/
    void  Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     */
    static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_


#include "TObject.h"                    // for TObject

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for FairRingSorter::Class, etc

#include <iostream>                     // for operator<<, ostream, etc
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
      : TObject(), fRingBuffer(size), fOutputData(), fLowerBoundPointer(0,0),
        fCellWidth(width), fVerbose(0) {
    }

    virtual ~FairRingSorter() {};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);       ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);          ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() {
      WriteOutElements(fLowerBoundPointer.first);
    }
    virtual double GetBufferSize() {return fCellWidth * fRingBuffer.size();}
    virtual std::vector<FairTimeStamp*> GetOutputData() {
      return fOutputData;
    }

    virtual void DeleteOutputData() {fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout) {
      out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << std::endl;
      out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second << std::endl;
      out << "| ";
      for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
        out << fRingBuffer[i].size() << " |";
      }
      out << std::endl;
    }


  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*> > fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter,1)

};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairTask.h"                   // for FairTask, InitStatus

#include "FairRingSorter.h"             // for FairRingSorter

#include "Rtypes.h"                     // for Bool_t, Int_t, kTRUE, etc
#include "TString.h"                    // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:

    /** Default constructor **/
    FairRingSorterTask():
      FairTask("SorterTask"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name):
      FairTask(name),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(1000),
      fWidthOfCells(10),
      fInputBranch(),
      fInputArray(0),
      fOutputBranch(),
      fFolder(),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells, Double_t widthOfCells, TString inputBranch, TString outputBranch, TString folderName):
      FairTask("Sorter"),
      fSorter(0),
      fPersistance(kTRUE),
      fDigiPixelMCInfo(kFALSE),
      fNumberOfCells(numberOfCells),
      fWidthOfCells(widthOfCells),
      fInputBranch(inputBranch),
      fInputArray(0),
      fOutputBranch(outputBranch),
      fFolder(folderName),
      fOutputArray(0),
      fEntryNr(0) {
      SetVerbose(0);
    }

    /** Destructor **/
    virtual ~FairRingSorterTask() {
      delete fSorter;
    }

    /** Virtual method Init **/
    virtual InitStatus Init();
    virtual InitStatus ReInit();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);
    virtual void FinishEvent();
    virtual void FinishTask();

    virtual void SetParContainers() {};

    void SetPersistance(Bool_t p = kTRUE) {fPersistance=p;};
    Bool_t GetPersistance() {return fPersistance;};

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:

    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells; // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDef(FairRingSorterTask,2);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include "TChain.h"                     // for TChain
#include "TFile.h"                      // for TFile
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator<
#include "TMCtls.h"                     // for multi-threading

#include <stddef.h>                     // for NULL
#include <list>                         // for list
#include <map>                          // for map, multimap, etc
#include <queue>                        // for queue
#include "FairSource.h"
#include <typeinfo>
#include <typeindex>
#include <vector>
#include <memory>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairGeoNode;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TArrayI;
class TBranch;
class TClonesArray;
class TCollection;
class TF1;
class TFolder;
class TList;
class TNamed;
class TTree;
class TRefArray;
class TIterator;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

//_____________________________________________________________________

class FairRootManager : public TObject
{
  public:
      /**dtor*/
    virtual ~FairRootManager();
     Bool_t             AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t               CheckBranch(const char* BrName);

    
    void                CloseOutFile() { if(fOutFile) { fOutFile->Close(); }}
    /**Create a new file and save the current TGeoManager object to it*/
    void                CreateGeometryFile(const char* geofile);
    void                Fill();
    void                LastFill();
    TClonesArray*       GetEmptyTClonesArray(TString branchName);
    TClonesArray*       GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void                UpdateBranches();

    /**Return branch name by Id*/
    TString             GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t               GetBranchId(TString const &BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList*              GetBranchNameList() {return fBranchNameList;}
    /**Return the vector of branch names that were requested by tasks as input*/
    const std::vector<std::string>& GetReqBranchNames() const {return fReqBrNames;}

      /** Return a pointer to the output Tree of type TTree */
    TTree*              GetOutTree() {return fOutTree;}
    /** Return a pointer to the output File of type TFile */
    TFile*              GetOutFile() {return  fOutFile;}
    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject*            GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t            GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject*      GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray*     GetData(TString branchName, BinaryFunctor* startFunction, Double_t startParameter, BinaryFunctor* stopFunction, Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer) {fTSBufferMap[branchName] = functionalBuffer;}
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional*   GetTSBuffer(TString branchName) {return fTSBufferMap[branchName];}

    /** static access method */
    static FairRootManager* Instance();

    TFile*            OpenOutFile(const char* fname="cbmsim.root");
    TFile*            OpenOutFile(TFile* f);
    /**Read a single entry from background chain*/
    Int_t             ReadEvent(Int_t i=0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t             ReadNonTimeBasedEventFromBranches(Int_t i=0);
    /**Read the tree entry on one branch**/
    void              ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void              ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t             GetRunId();

    Bool_t            ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
    *@param name            Name of the branch to create
    *@param Foldername      Folder name containing this branch (e.g Detector name)
    *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
    *@param toFile          if kTRUE, branch will be saved to the tree*/
    void                Register(const char* name,const char* Foldername ,TCollection* obj, Bool_t toFile);

    
    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T* &obj, Bool_t toFile);
    /// for branches which are not managed by folders, we need a special function
    /// to trigger persistent branch creation
    /// return true if successful; false if problem
    bool CreatePersistentBranchesAny();    

    void                RegisterInputObject(const char* name, TObject* obj);

    TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void                UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries*/
    void                RunWithTimeStamps() {fTimeStamps = kTRUE;}

    /**Set the branch name list*/
    void                SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList *list);
  
    void                FillEventHeader(FairEventHeader* feh) { if ( fSource ) fSource->FillEventHeader(feh); } 
   
    /**Set the output tree pointer*/
    void                SetOutTree(TTree* fTree) { fOutTree=fTree;}

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void        SetLastFill(Bool_t val = kTRUE) { fFillLastData=val;}
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TBranch* b, TString ffn);
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
    */
    void                TruncateBranchNames(TTree* fTree, const char* folderName);

    Int_t               Write(const char* name=0, Int_t option=0, Int_t bufsize=0);
    /** Write the current TGeoManager to file*/
    void                WriteGeometry();
    /**Write the file header object to the output file*/
    void                WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void                WriteFolder() ;

    /**Check the maximum event number we can run to*/
    Int_t  CheckMaxEventNo(Int_t EvtEnd=0);


    void        StoreWriteoutBufferData(Double_t eventTime);
    void        StoreAllWriteoutBufferData();
    void    DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() {return fEntryNr;}
    void SetEntryNr(Int_t val) {fEntryNr = val;}

    void SetUseFairLinks(Bool_t val) {fUseFairLinks = val;};
    Bool_t GetUseFairLinks() const {return fUseFairLinks;};

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */
   
    
    /** These methods have been moved to the FairFileSource */
    void   SetSource(FairSource* tempSource) { fSource = tempSource; }    
    FairSource* GetSource() { return fSource;}
    Bool_t InitSource();
    
    void                SetListOfFolders(TObjArray* ta){ fListFolder=ta; }
    TChain*             GetInChain ()                  { return fSourceChain;}
    TChain*             GetSignalChainNo(UInt_t i)     { return fSignalChainList[i]; }
    TTree*              GetInTree  ()                  { if ( fSourceChain ) return fSourceChain->GetTree(); return 0; }
    const TFile*        GetRootFile()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    TFile*              GetInFile  ()                  { if ( fSourceChain ) return fSourceChain->GetFile(); return 0; }
    void                SetInChain (TChain* tempChain, Int_t ident=-1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE){ fFinishRun = val;}
    Bool_t FinishRun() {return fFinishRun;}

    static char* GetTreeName();
  private:

    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair {
    TypeAddressPair(const std::type_info &oi, const std::type_info &pi, void* a) : origtypeinfo(oi), persistenttypeinfo(pi), ptraddr(a) {}
      const std::type_info &origtypeinfo; // type_info of type addr points to 
      const std::type_info &persistenttypeinfo; // type_info of ROOT persistent branch (drops pointers)
      void *ptraddr; // address of a pointer (pointing to origtypeinfo);
    };
    
    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject*            ActivateBranch(const char* BrName);
    void                AddFriends( );
    /**Add a branch to memory, it will not be written to the output files*/
    void                AddMemoryBranch(const char*, TObject* );

    template<typename T>
    void AddMemoryBranchAny(const char *name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t               CheckBranchSt(const char* BrName);
        /**Create the Map for the branch persistency status  */
    void                CreatePerMap();
    TObject*            GetMemoryBranch( const char* );
 //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char *typen1, const char *typen2) const;

    Int_t       fOldEntryNr;
//_____________________________________________________________________
    /**private Members*/
    /**folder structure of output*/
    TFolder*                            fOutFolder;
    /**folder structure of input*/
    TFolder*                            fRootFolder;
    /** current time in ns*/
    Double_t                            fCurrentTime;
    /**Output file */
    TFile*                              fOutFile;
    /**Output tree */
    TTree*                              fOutTree;
    TObject**                           fObj2; //!
    /** Counter for the number of branches activiated */
    Int_t                               fNObj;//!
    /** A list which hold the pointer to the branch 
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map < TString , TObject* >     fMap;  //!

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap; //!
    /// keeps track of branches which are supposed to be persistified
    std::vector<std::string> fPersistentBranchesAny;
    
    /**Branch id for this run */
    Int_t                                fBranchSeqId;
    /**List of branch names as TObjString*/
    TList*                               fBranchNameList; //!
    /**Vector of (not necessarily unique) branch names requested per GetObject / InitObjectAs */
    std::vector<std::string>             fReqBrNames; //!
    
    /**The branch ID for the special (required) MCTrack branch**/
    Int_t                                fMCTrackBranchId; //!

    /**List of Time based branchs names as TObjString*/
    TList*                               fTimeBasedBranchNameList; //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap; //!
    std::map<TString, FairWriteoutBuffer* > fWriteoutBufferMap; //!
    std::map<Int_t, TBranch*> fInputBranchMap; //!    //Map of input branch ID with TBranch pointer
    /**if kTRUE Read data according to time and not entries*/
    Bool_t                              fTimeStamps;
    /**Flag for creation of Map for branch persistency list  */
    Bool_t                              fBranchPerMap;
    /** Map for branch persistency list */
    std::map < TString , Int_t >        fBrPerMap; //!
    /**Iterator for the fBrPerMap  Map*/
    std::map < TString, Int_t>::iterator     fBrPerMapIter;
 
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    Bool_t  fFillLastData; //!
    Int_t fEntryNr; //!

    TObjArray                           *fListFolder; //!

    FairSource                          *fSource;

    TChain                              *fSourceChain;
    std::map<UInt_t, TChain*>            fSignalChainList;//!

    FairEventHeader                     *fEventHeader;
    
    Bool_t fUseFairLinks; //!
    Bool_t fFinishRun; //!
    /** List of branches from input Chain or Tree*/
    TObjArray* fListOfBranchesFromInput; //!
    /** Iterator for the list of branches from input Chain or Tree */
    TIterator* fListOfBranchesFromInputIter;//!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray* fListOfNonTimebasedBranches; //!
    /** Iterator for the list of branches used with no-time stamp in time-based session */
    TIterator* fListOfNonTimebasedBranchesIter; //!

    ClassDef(FairRootManager,12) // Root IO manager
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj) {
  if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
    auto& ot = typeid(T*);
    auto& pt = typeid(T);
    fAnyBranchMap[brname]=std::unique_ptr<TypeAddressPair const> (new TypeAddressPair(ot, pt,(void*)obj));
  }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const {
  static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer"); 
  using P = typename std::remove_pointer<T>::type;
  auto iter = fAnyBranchMap.find(brname);
  if(iter != fAnyBranchMap.end()) {
    // verify type consistency
    if(typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
      EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
      return nullptr;
    }
    return static_cast<T>(iter->second->ptraddr);
  }
  return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T *& obj, bool persistence) {
  AddBranchToList(brname);
  if (persistence) {
    fPersistentBranchesAny.push_back(brname);
  }
  // we are taking the address of the passed pointer
  AddMemoryBranchAny<T>(brname, &obj);
}

// this function serves as a factory (or lookup) for memory managed 
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname) {
  static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer"); 
  using X = typename std::remove_pointer<TPtr>::type;
  static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
  using T = typename std::remove_const<X>::type;
  
  // is there already an object associated to the branch in memory?? 
  // then just return
  T** obj = GetMemoryBranchAny<T**>(brname);
  // obj is some address/instance holding TPtr instances
  if(obj!=nullptr) return *obj;

  // it does not seem to be the case, let us create the pointer which will be initialized
  // with the data (pointer to T)
  T** addr = new T*;
  // init the pointee to a default obj which we can return
  (*addr) = new T;
  // try to find and activate in the source
  auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

  if(!succeeded) {
    delete (*addr);
    delete addr;
    return nullptr;
  }
  // add into branch list
  AddMemoryBranchAny<T>(brname, addr);
  // register as a **requested** branch
  // (duplications are explicitely allowed)
  fReqBrNames.emplace_back(brname);
  
  // NOTE: ideally we would do proper resource management for addr and *addr
  // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
  // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
  // container which we cannot know a priori; Some solutions we could think of in the future are
  // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
  // b) investigate if boost::any could be of help here
  // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
  // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
  return *addr;
}

#endif //FAIR_ROOT_MANAGER_H

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TMCtls.h"                     // for multi-threading

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairTask;
class TFile;
class FairField;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
    * default dtor
    */
    virtual ~FairRun();
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void       AddTask(FairTask* t);
    virtual void       SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void    Init()=0;
    /*
     * Get the magnetic field *
     */
    virtual FairField*  GetField()=0;
    /**
      * run the analysis or simulation
     */
    virtual void    Run(Int_t NStart =0,Int_t NStop=0)=0;
    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void        SetEventHeader(FairEventHeader* EvHeader)  {
      fEvtHeader=EvHeader;
    }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb(void) {
      return fRtdb;
    }
    /**
     * Set the  output file name without creating the file
     */
    void SetOutputFileName(const TString& name) {
      fOutname = name;
    }
    /**
     * return a pointer to the output file
     */
    TFile* GetOutputFile() {
      return fOutFile;
    }
    /**
     * return a pointer to the output file
     */
    TString GetOutputFileName() {
      return fOutname;
    }
    /**
     * return the run ID for the actul run
     */
    Int_t  GetRunId() {
      return (static_cast<Int_t>(fRunId));
    }

	/** 
     * Set the Run ID
	 */
    void SetRunId(UInt_t runId)
	{
	  fRunId = runId; 
    }    

    /**Get the detector specific run header*/
    FairEventHeader*  GetEventHeader();
    /**
    * return true for Anaylsis session
    */
    Bool_t            IsAna() {
      return fAna;
    }
    /**
    *Get task by name
    */

    FairTask* GetTask(const char* taskName);
    /**
    *Get Main Task
    */
    FairTask* GetMainTask() {
      return fTask;
    }
    /**
    * Return the number of Tasks added to this Run
    */
    Int_t     GetNTasks() {
      return fNTasks;
    }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    //** Set if RunInfo file should be written */
    void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write;}

    //** Get info if RunInfo file is written */
    Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo;}

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster;}

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }


  private:
    FairRun(const FairRun& M);
    FairRun& operator= (const  FairRun&) {
      return *this;
    }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /** Tasks used*/
    FairTask*                fTask;
    /**Output file name*/
    TString                  fOutname;
    /**IO manager */
    FairRootManager*         fRootManager;
    /**Output file*/
    TFile*                   fOutFile;
    /**Run Id*/
    UInt_t                   fRunId;//!
    /** true for Anaylsis session*/
    Bool_t                   fAna;  //!
    /** MC Event Header */
    FairEventHeader*         fEvtHeader; //!
    /** File  Header */
    FairFileHeader*          fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t                   fGenerateRunInfo;  //!
    /** true if on master*/
    Bool_t                   fIsMaster;  //!

    Bool_t                   fMarkFill; //!

    ClassDef(FairRun ,4)
};
#endif //FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H


/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"                    // for FairRun

#include "FairRootManager.h"            // for FairRootManager
#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Bool_t, Double_t, UInt_t, etc
#include "TString.h"                    // for TString

class FairField;
class TF1;
class TFile;
class TTree;

class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:

    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void        Init();
    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void        Run(Double_t delta_t);
    /**Run for the given single entry*/
    void        Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void        RunEventReco(Int_t NStart ,Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void        RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void        DummyRun(Int_t NStart ,Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
      * it read a certain event and call the task exec, but no output is written
      * @param entry : entry number in the tree
      */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void        RunOnLmdFiles(UInt_t NStart=0, UInt_t NStop=0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void        TerminateRun();
    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */

    virtual void   SetSource(FairSource* tempSource) { fRootManager->SetSource(tempSource); }

    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource
    /**Set the input file by name*/
    void        SetInputFile(TString fname);
    /**Add a file to input chain */
    void        AddFile(TString name);
    /** Add a friend file (input) by name)*/
    void        AddFriend(TString fName);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairMixedSource
    void        SetSignalFile(TString name, UInt_t identifier );
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void        AddSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void        SetBackgroundFile(TString name);
    /**Add input background file by name*/
    void        AddBackgroundFile(TString name);
    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     * here we just forward the call to the FairRootManager
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);
    /**
     * This method will simply forward the call to the FairRootManager,
     * if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
    */
    //    void SetMixAllInputs(Bool_t Status);
    // ********************************************************* //
    // THE BELOW FUNCTIONS SHOULD BE MOVED TO FairFileSource and FairMixedSource
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the time intervall the beam is interacting and the gap in ns */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    // ********************************************************* //

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag){
        fStoreEventHeader=flag;
    }

    void        Reinit(UInt_t runId);
    UInt_t      getRunId() {
      return fRunId;
    }
    /** Get the magnetic field **/
    FairField*  GetField() {
      return fField;
    }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield ) {
      fField=ffield ;
    }
    /** Set external geometry file */
    void        SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile*      GetGeoFile() {
      return fInputGeoFile;
    }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };
    void        RunWithTimeStamps();
    Bool_t      IsTimeStamp() {
      return fTimeStamps;
    }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD( void ) {
      fFinishProcessingLMDFile = kTRUE;
    }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus( void ) {
      return fFinishProcessingLMDFile;
    }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
    **/
    virtual void Fill();

  private:

    FairRunAna(const FairRunAna& M);
    FairRunAna& operator= (const  FairRunAna&) {
      return *this;
    }

    FairRunInfo fRunInfo;//!

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    TFile*                                  fInputGeoFile;
    static FairRunAna*                      fgRinstance;
    Bool_t                                  fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;
    Bool_t                                  fTimeStamps;
    Bool_t                                  fInFileIsOpen;//!
    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** Flag for proccessing lmd-files*/
    Bool_t                                  fFinishProcessingLMDFile;  //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource*                         fFileSource;  //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource*                        fMixedSource; //!
    /** Flag for Event Header Persistency */
    Bool_t  fStoreEventHeader; //!


    ClassDef(FairRunAna ,6)

};

#endif //FAIRRUNANA_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairRunAna.h"

#include "FairFileSource.h" // FairRunAnaProof can only accept FairFileSource as source
#include "TProof.h"

class FairRunAnaProof : public FairRunAna
{

  public:

    static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName="");

    /**initialize the run manager*/
    void        Init();

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();

    /**
     * Set the output file name for analysis or simulation
    */
    virtual void    SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
    */
    virtual void    SetOutputFile(TFile* f);

    /**Run from event number NStart to event number NStop */
    void        Run(Int_t NStart=0 ,Int_t NStop=0);
    /**Run for one event, used on PROOF nodes*/
    void        RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void        RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() {
      return fProof;
    }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) {
      fRunOnProofWorker = tb;
    }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) {
      fProofParName = parName;
    }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) {
      fOutputDirectory = dirName;
    }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) {
      fProofOutputStatus = outStat;
    }

    virtual void   SetSource(FairSource* tempSource);

  protected:
    static FairRunAnaProof*                 fRAPInstance;

    /** PROOF **/
    TProof*                                 fProof;
    /** executing on PROOF worker*/
    Bool_t                                  fRunOnProofWorker; //!
    /** PROOF server name*/
    TString                                 fProofServerName; //!
    /** PROOF ARchive (PAR) file name*/
    TString                                 fProofParName; //!
    /** Output directory*/
    TString                                 fOutputDirectory; //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString                                  fProofOutputStatus;

  private:
  
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;
    
    ClassDef(FairRunAnaProof ,1)

};

#endif //FAIRRUNANAPROOF_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairRun.h"                    // for FairRun

#include "FairIon.h"                    // for FairIon
#include "FairMCApplication.h"          // for FairMCApplication
#include "FairParticle.h"               // for FairParticle

#include "Rtypes.h"                     // for Bool_t, Double_t, Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TMCtls.h"                     // for multi-threading

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * Configure the Simulation session
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    virtual ~FairRunSim();
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
    */
    void        AddModule  (FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewIon(FairIon* ion) {fIons->Add(ion);}
    /**
     *       Add a user defined ion to the simulation
    */
    void        AddNewParticle(FairParticle* Particle) {fParticles->Add(Particle);}
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
    */
    TObjArray*  GetUserDefParticles();

    /**
    *       Initialize the Simulation
    */
    virtual void        Init();
    /**
    *       run the  simulation
    */
    virtual void    Run(Int_t NEvents =0, Int_t NotUsed=0);
    /**
    *       Set the magnetic that has to be used for simulation field
    */
    void        SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
    */
    void        SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void  SetMCEventHeader(FairMCEventHeader* McHeader) {fMCEvHead=McHeader;}

    /** Set the material file name to be used */
    void    SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj=kTRUE) {fStoreTraj = storeTraj;}

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode( Bool_t set ) { if (fApp) { fApp->SetTrackingDebugMode( set ); } }

    /**Set geometry builder*/
    void SetGeoModel( char* name );

    /**return the geometry loader used in this session*/
    TString* GetGeoModel () { return fLoaderName; }

    /**Get the field used in simulation*/
    FairField*  GetField() { return fField;}

    /**Get the detector specific event header*/
    FairMCEventHeader*  GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray*        GetListOfModules() { return ListOfModules;}

    /**Get the used primary generator*/
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen;}

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer = decayer;}

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config );

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) {fUserDecay = decay;}

    /**Flag for external decayer*/
    Bool_t  IsExtDecayer() {return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t  IsUserDecay() {return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) {fRadLength= value;}

    void SetRadMapRegister(Bool_t value) { fRadMap=value; }

    void SetRadGridRegister(Bool_t value) {fRadGrid= value;}

    void AddMesh (FairMesh* Mesh);

    void SetUserConfig(const TString& Config) {fUserConfig = Config;}

    void SetUserCuts(const TString& Cuts) {fUserCuts= Cuts;}

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom) {  fBeamMom= BeamMom; fUseBeamMom=kTRUE;}

    /** Get the Beam energy */
    Double_t GetBeamMom() {return fBeamMom;}

    /**Get beam energy flag */
    Bool_t UseBeamMom() {return fUseBeamMom;}
    void SetFieldContainer();
  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator= (const  FairRunSim&) {return *this;}
    void SetMCConfig();
    void CheckFlukaExec();
  protected:

    Int_t                  count;//!                               /** Internal counter*/
    FairMCApplication*     fApp;  //!                              /** Main VMC application */
    Double_t               fBeamMom; //!                           /** Beam Energy in GeV/c  */
    Bool_t                 fUseBeamMom; //!                        /** flag for use Beam Energy  */
    FairPrimaryGenerator*  fGen; //!                               /** Primary Event Generator */
    FairMCEventHeader*     fMCEvHead; //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim*  fginstance;//!              /** Singleton Instance */
    FairField*             fField;                                 /** Magnetic Field */
    const char*            fMapName; //!                           /** Input file name map*/
    TObjArray*             fIons; //!                              /** Array of user defined ions */
    TObjArray*             fParticles; //!                         /** Array of user defined particles*/
    TObjArray*             ListOfModules;//!                       /** Array of used modules */
    TString                MatFname; //!                           /** Material file name */
    Bool_t                 fStoreTraj;   //!                       /** Trajectory store flags */
    TString*               fLoaderName;  //!                       /** Geometry Model (TGeo or G3)*/
    Bool_t                 fPythiaDecayer;  //!                    /** flag for using Pythia decayer*/
    TString                fPythiaDecayerConfig; //!               /** Macro for Pythia decay configuration*/
    Bool_t                 fUserDecay;                             /** flag for setting user decay */
    TString                fUserDecayConfig; //!                   /** Macro for decay configuration*/
    Bool_t                 fRadLength;   //!                       /** flag for registring radiation length*/
    Bool_t                 fRadMap; //!                            /** flag for RadiationMapManager
    Bool_t                 fRadGrid;  //!
    TObjArray*             fMeshList; //!                          /** radiation grid scoring
    TString                fUserConfig; //!                        /** Macro for geant configuration*/
    TString                fUserCuts; //!                          /** Macro for geant cuts*/


    ClassDef(FairRunSim ,2)

};

#endif //FAIRRUNSIM_H





/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"              // for FairTimeStamp

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TObject.h"                    // for TObject
#include "TString.h"                    // for TString

#include <functional>                   // for binary_function
#include <iostream>                     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;


/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor : public std::binary_function<FairTimeStamp* ,double, bool>
{
  public :
    virtual bool operator() (FairTimeStamp* a, double b) {return Call(a,b);};
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() {return false;}
    virtual void ResetTimeOut() {};

    virtual ~BinaryFunctor() {};

};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public :
    StopTime():fRequestTime(-1), fOldTime(-1), fSameTimeRequestCounter(0) {};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) {
      fRequestTime = b;
      //std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
      return a->GetTimeStamp() > b;
    };

    bool TimeOut() {
      if (fRequestTime != fOldTime) {
        fOldTime = fRequestTime;
        fSameTimeRequestCounter = 0;
        //std::cout << "RequestedTime: " << fRequestTime << std::endl;
        return false;
      } else if (fRequestTime == fOldTime) {
        std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime << std::endl;
        fSameTimeRequestCounter++;
      } else {
        std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime << " smaller than old time " << fOldTime << std::endl;
        return true;
      }
      if (fSameTimeRequestCounter > 9) {
        return true;
      } else { return false; }
    }

    void ResetTimeOut() {fSameTimeRequestCounter = 0;}

  private :
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};



/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap():fOldTime(-1.) {};


    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) {
      double aTime = a->GetTimeStamp();

      if (fOldTime < 0) {
        fOldTime = aTime;
        return false;
      }
      if (aTime - fOldTime > b) {
        fOldTime = aTime;
        return true;
      } else {
        fOldTime = aTime;
        return false;
      }
    };


  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already exists.
 * To extract the data one has to call GetData with a parameter which fits to the selected functor.
 * GetData returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot request data which is older than the
 * data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only works if you request a fixed time
 * via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{

  public:
    FairTSBufferFunctional(TString branchName, TTree* sourceTree, BinaryFunctor* stopFunction, BinaryFunctor* startFunction = 0);

    virtual ~FairTSBufferFunctional() {};
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() {return fBranchIndex;}

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function;}
    void SetStopFunction(BinaryFunctor* function)  { fStopFunction  = function;}
    Bool_t AllDataProcessed();
    void Terminate(){ fTerminate = kTRUE; }

    Bool_t TimeOut() {
      Bool_t stopTimeOut = fStopFunction->TimeOut();
      Bool_t startTimeOut = kTRUE;
      if (fStartFunction != 0) {
        startTimeOut = fStartFunction->TimeOut();
//        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
//          fStartFunction->ResetTimeOut();
//        }
//        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
//          fStopFunction->ResetTimeOut();
//        }
      }
      return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);


  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray(); //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDef(FairTSBufferFunctional,0);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------


/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include "TTask.h"                      // for TTask

#include "FairRootManager.h"            // for FairRootManager

#include "Rtypes.h"                     // for Int_t, FairTask::Class, etc
#include "TString.h"                    // for TString

#include <map>

class FairLogger;

enum InitStatus {kSUCCESS, kERROR, kFATAL};

class FairTask : public TTask
{

  public:

    /** Default constructor **/
    FairTask();


    /** Standard constructor
    *@param name        Name of task
    *@param iVerbose    Verbosity level
    **/
    FairTask(const char* name, Int_t iVerbose = 1);


    /** Destructor **/
    virtual ~FairTask();


    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();


    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();


    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();


    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

    void SetInputPersistance(Bool_t val) {fInputPersistance = val;}

    void CheckInputPersistance(TString branchName) {
      FairRootManager* ioman = FairRootManager::Instance();
      fInputPersistance = ioman->CheckBranch(branchName);
    }

    virtual void  ExecuteTask(Option_t *option="0");  // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
    **/   
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
    **/  
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val=kTRUE) {fStreamProcessing=val;}

  protected:

    Int_t        fVerbose;  //  Verbosity level
    Int_t        fInputPersistance; ///< Indicates if input branch is persistant
    FairLogger*  fLogger; //!
    Bool_t       fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus Init() { return kSUCCESS; };


    /** Reinitialisation. To be implemented in the derived class.
    *@value  Success   If not kSUCCESS, task will be set inactive.
    **/
    virtual InitStatus ReInit() { return kSUCCESS; };


    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers() { };


    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish() { };


    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    virtual void  ExecuteTasks(Option_t *option);

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:

    std::map<TString, Bool_t> fOutputPersistance;

    FairTask(const FairTask&);
    FairTask& operator=(const FairTask&);

    ClassDef(FairTask,4);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include "Rtypes.h"                     // for Double_t, Bool_t, Int_t, etc
#include "TGeoTrack.h"                  // IWYU pragma: keep needed by cint
#include "TMath.h"                      // for Pi, TwoPi
#include "TString.h"                    // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */


class FairTrajFilter
{

  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter,1);


  private:

    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t    fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* GetCurrentTrk() {return fCurrentTrk;}

    void Init(TString brName="GeoTracks", TString folderName="MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin=-2000., Double_t vyMin=-2000., Double_t vzMin=-2000.,
                      Double_t vxMax= 2000., Double_t vyMax= 2000., Double_t vzMax= 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin=  0., Double_t thetaMin=0., Double_t phiMin=0.,
                         Double_t pMax=1e10, Double_t thetaMax=TMath::Pi(),
                         Double_t phiMax=TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin=-1e10, Double_t pyMin=-1e10, Double_t pzMin=-1e10,
                         Double_t pxMax= 1e10, Double_t pyMax= 1e10, Double_t pzMax= 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin=0., Double_t ptMax=1e10,
                          Double_t rapidityMin=-1e10, Double_t rapidityMax=1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin=0., Double_t etotMax=1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim=kTRUE) {fStorePrim = storePrim;};

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec=kTRUE) {fStoreSec = storeSec;};

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin=0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin, Double_t& vyMin, Double_t& vzMin,
                      Double_t& vxMax, Double_t& vyMax, Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin, Double_t& thetaMin, Double_t& phiMin,
                         Double_t& pMax, Double_t& thetaMax, Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin, Double_t& pyMin, Double_t& pzMin,
                         Double_t& pxMax, Double_t& pyMax, Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax,
                          Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const {return fStorePrim;};

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const {return fStoreSec;};

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "TObject.h"                    // for TObject

#include "FairLogger.h"                 // for FairLogger
#include "FairRootManager.h"            // for FairRootManager
#include "FairTimeStamp.h"              // for FairTimeStamp

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TClonesArray.h"               // for TClonesArray
#include "TString.h"                    // for TString

#include <iostream>                     // for cout, ostream
#include <map>                          // for multimap
#include <utility>                      // for pair
#include <vector>                       // for vector

class FairWriteoutBuffer: public TObject
{
  public:
    FairWriteoutBuffer() : TObject(), fStartTime_map(), fDeadTime_map(), fBranchName(), fClassName(),
      fTreeSave(false), fActivateBuffering(kFALSE), fVerbose(0), fLogger(FairLogger::GetLogger()) {};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    virtual ~FairWriteoutBuffer() {};

    virtual void SaveDataToTree(Bool_t val = kTRUE) {
      fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE) {
      fActivateBuffering=val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the data is directly stored in the given TClonesArray.
    }

   Bool_t IsBufferingActivated(){ return fActivateBuffering;}
  
/// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later data, activeTime gives the time how long the data can influence later data.
/// Both time data has to be given as an absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() {
      return fDeadTime_map.size();
    }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();


    virtual void SetVerbose(Int_t val) {
      fVerbose = val;
    }

    virtual void DeleteOldData() {
      if ( fBranchName.Length() > 0 ) {
        TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
        myArray->Delete();
      }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data) = 0; ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to cast it to your type of data)
    virtual double FindTimeForData(FairTimeStamp* data) = 0;  ///< if the same data object (like a pad or a pixel) is already present in the buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0; ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(FairTimeStamp* data) = 0; ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    ///Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters are the old data with the active time, the new data with an active time.
    ///Modify returns than a vector with the new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*> > Modify(std::pair<double, FairTimeStamp*> oldData, std::pair<double, FairTimeStamp*>) {
      std::vector<std::pair<double, FairTimeStamp*> > result;
      result.push_back(oldData);
      return result;
    }


    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data) {
      std::cout << data->GetTimeStamp();
    }; ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*> > fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;  //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDef(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNONLINE_H
#define FAIRRUNONLINE_H


/**
 * Configure and manage the Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRun.h"
#include "FairRootManager.h"

#include "TString.h"
#include <iostream>

class FairRuntimeDb;
class FairField;
class TFile;
class TF1;
class TTree;
class FairSource;
class TFolder;
class THttpServer;

class FairRunOnline : public FairRun
{

  public:
    static FairRunOnline* Instance();
    virtual ~FairRunOnline();
    FairRunOnline();
    FairRunOnline(FairSource* source);

    /**initialize the run manager*/
    void        Init();
    /**Run for the given number of events*/
    void        Run(Int_t Ev_start, Int_t Ev_end);
 
    void        Reinit(UInt_t runId);
    UInt_t      getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField*  GetField() { return fField; }
    /** Set the magnetic Field */
    void        SetField (FairField* ffield) { fField = ffield; }

    /** Set if the run should be closed automatically after executing the
        run functuion
    **/
    void        SetAutoFinish(Bool_t val) { fAutomaticFinish = val; }
    /** Set the source which should be used **/
    void        SetSource(FairSource* source) { fRootManager->SetSource(source); }
    /** Return pointer to source **/
    FairSource*  GetSource() { return fRootManager->GetSource(); }


    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void        InitContainers();
    void        SetContainerStatic(Bool_t tempBool=kTRUE);
    Bool_t      GetContainerStatic() { return fStatic; };

    /** Add histogram to be displayed using THttpServer.*/
    void AddObject(TObject* object);

    /** Activate http server on defined host port. To be called before Init.
     * @param refreshRate an interval in number of events for server update.
     * @param httpPort the port which is used by the http server
     */
    void ActivateHttpServer(Int_t refreshRate = 10000, Int_t httpPort=8080);

    /** Register a command on the http server.
     * @param name a command name starting with /
     * @param command a call to method "/object_name/->Method()"
     */
    void RegisterHttpCommand(TString name, TString command);


    /** Get direct access to the http server. */
    THttpServer* GetHttpServer() { return fServer; }

    /** Write last data to file, close input and output **/
    void Finish();

  private:

    Bool_t fAutomaticFinish;

    FairRunOnline(const FairRunOnline& M);
    FairRunOnline& operator= (const  FairRunOnline&) { return *this; }

    /** Main Event loop **/
    Int_t EventLoop();

  protected:
    /** This variable became true after Init is called*/
    Bool_t                                  fIsInitialized;
    static FairRunOnline*                   fgRinstance;
    /** true for static initialisation of parameters */
    Bool_t                                  fStatic;//!
    FairField*                              fField;

    Int_t       fNevents;      //!
    THttpServer* fServer;             //!
    Int_t        fServerRefreshRate;  //!

    virtual void Fill();

    ClassDef(FairRunOnline, 0)
};

#endif //FAIRRUNONLINE_H
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include "TObject.h"                    // for TObject
#include "TMCtls.h"                     // for multi-threading

#include "Rtypes.h"                     // for Bool_t, Int_t, UInt_t, etc
#include <set>							// for set of branch types to ignore


class FairLogger;

//_____________________________________________________________________

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();


    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);		///< Adds a BranchId (Type) to which links are not included in the link list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);	///< Adds a BranchId (Type) to which links are included in the link list. Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const {return fIgnoreTypes;}


  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

//_____________________________________________________________________
    /**private Members*/

    std::set<Int_t> fIgnoreTypes; //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger*                         fLogger;//!


    ClassDef(FairLinkManager,1) // Root IO manager
};

#endif //FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"               // for FairContFact, etc

#include "Rtypes.h"                     // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  private:
    void setAllContainers();
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*);
    ClassDef( FairBaseContFact,0)
};

#endif  /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet

#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairBaseParSet(const char* name="FairBaseParSet",
                   const char* title="Class for base parameter io",
                   const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) {fDetList=array;}
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) {fPriGen=gen;}
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t  BMom) {fBeamMom = BMom;}
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) {fContNameList= list;}
   /**
    * Set the random seed used in a run
    * @param RndSeed: Random Seed
    */
    void SetRndSeed(UInt_t RndSeed) {fRandomSeed= RndSeed;}
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray*             GetDetList() {return fDetList;}
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator*   GetPriGen() {return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t          GetBeamMom() {return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray*             GetContList() {return fContNameList;}
   /**
    *  Get the Random Seed used in this run
    */
    UInt_t  GetRndSeed() {return fRandomSeed;}
   

  protected:

    /// Detectors used in the simulation
    TObjArray*              fDetList;
    ///Generator used for simulation
    FairPrimaryGenerator*   fPriGen;
    ///Beam momentum (GeV/c)
    Double_t              fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray*              fContNameList;
    /// Random Seed from gRandom
    UInt_t                 fRandomSeed;

    ClassDef(FairBaseParSet,6)

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator= (const FairBaseParSet&) {return *this;}



};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"          // for FairParGenericSet
#include "Rtypes.h"                     // for Double_t, etc
#include "TGeoManager.h"                // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
    * @param title:  Parameter set title
    * @param context:  Parameter set context
    */


    FairGeoParSet(const char* name="FairGeoParSet",
                  const char* title="Class for base parameter io",
                  const char* context="BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet(void);
    /** clear*/
    void clear(void);
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
    */
    void putParams(FairParamList*);
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*);
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) {fGeoNodes=array;}
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) {fGeom=Geom;}
    /**
    *  Get the Geometry Nodes list used in the simulation
    */
    TObjArray*             GetGeoNodes() {return fGeoNodes;}
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager*           GetGeometry() {return fGeom;}

  protected:

    /// List of FairGeoNodes for sensitive volumes
    TObjArray*              fGeoNodes; //!
    /// Full Geometry
    TGeoManager*            fGeom;
    ClassDef(FairGeoParSet,1)

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator= (const FairGeoParSet&) {return *this;}



};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"                 // for FairModule

#include "Rtypes.h"                     // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{

  public:

    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId=0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void   Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits( FairVolume* v=0)=0;
    /**
      this is called at the end of an event
    */
    virtual void   EndOfEvent() {
      ;
    }
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void   Register()=0;

    /** Gets the produced collections **/
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;

    /**
      has to be called after each event to reset the containers
    */
    virtual void   Reset()=0;

    virtual void   CopyClones( TClonesArray*,  TClonesArray*, Int_t) {
      ;
    }

    virtual void   FinishPrimary() {
      ;
    }
    virtual void   FinishRun() {
      ;
    }
    virtual void   BeginPrimary() {
      ;
    }
    virtual void   PostTrack() {
      ;
    }
    virtual void   PreTrack() {
      ;
    }
    virtual void   BeginEvent() {
      ;
    }
    virtual void   FinishEvent() {
      ;
    }
    virtual void   SetSpecialPhysicsCuts() {
      ;
    }
    void SaveGeoParams();
    Int_t  GetDetId() {
      return fDetId;
    }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator= (const FairDetector&);

    Int_t fDetId; // Detector Id has to be set from ctr.
    FairLogger* fLogger;  //! /// FairLogger

    ClassDef(FairDetector,1)

};
#endif //FAIRDETECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "Rtypes.h"                     // for Bool_t, etc
#include "TLorentzVector.h"             // for TLorentzVector

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
    *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    virtual ~FairGeaneApplication();
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /**
    * Set the magnetic field for simulation or Geane
    * @param field: magnetic field
    */
    void                   SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void          GeaneStepping();                           // MC Application
    void ConstructGeometry();
    /** Singelton instance
     */
    static FairGeaneApplication* Instance();

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() {;}
    void GeneratePrimaries() {;}
    void BeginEvent() {;}
    void BeginPrimary() {;}
    void PreTrack() {;}
    void PostTrack() {;}
    void FinishPrimary() {;}
    void FinishEvent() {;}
    void Stepping() {;}
    void StopRun() {;}


  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Debug flag*/
    Bool_t               fDebug;//!
    TLorentzVector fTrkPos; //!

    ClassDef(FairGeaneApplication,1)  //Interface to MonteCarlo application
  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

// inline functions

inline FairGeaneApplication* FairGeaneApplication::Instance()
{ return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------


/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/


#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Bool_t, etc

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{

  public:

    /** Default constructor. **/
    FairGenerator();


    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title="FAIR Generator");


    /** Destructor. **/
    virtual ~FairGenerator();


    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;


    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE;}

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator= (const FairGenerator&);

    ClassDef(FairGenerator,1);
};

#endif


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------


/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/


#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include "TClonesArray.h" 
#include "TVirtualMCStack.h"            // for TVirtualMCStack

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TMCProcess.h"                 // for TMCProcess

#include <stddef.h>                     // for NULL

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;


class FairGenericStack : public TVirtualMCStack
{

  public:

    /** Default constructor  **/
    FairGenericStack();


    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);


    /** Destructor  **/
    virtual ~FairGenericStack();


    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode,
                           Double_t px, Double_t py, Double_t pz,
                           Double_t e, Double_t vx, Double_t vy,
                           Double_t vz, Double_t time, Double_t polx,
                           Double_t poly, Double_t polz, TMCProcess proc,
                           Int_t& ntr, Double_t weight, Int_t is, Int_t secondparentID) = 0;


    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}


    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* detArray=0) {}


    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger*  fLogger;//!

    /** List of detectors registering hits in the simulation */
    TRefArray*  fDetList;  //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    ClassDef(FairGenericStack,1)
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/


#ifndef FAIRION_H
#define FAIRION_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, etc

class FairLogger;

class FairIon: public TNamed
{
  public:

    /** Default constructor **/
    FairIon();


    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e=0., Double_t m=0.);
    void SetParams( const char* name, Int_t z, Int_t a,
                    Int_t q, Double_t e=0., Double_t m=0.) {
      SetName(name);
      fZ=z;
      fA=a;
      fQ=q;
      fExcEnergy=e;
      fMass=m;
    }
    /** Destructor **/
    virtual ~FairIon();


    /** Accessors **/
    /**
    * Return the atomic number
    */
    Int_t GetZ()            const { return fZ; }
    /**
     * Return the atomic mass
    */
    Int_t GetA()            const { return fA; }
    /**
     * Return the charge
    */
    Int_t GetQ()            const { return fQ; }
    /**
    * Return the  excitation energy
    */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
    * Return the mass in GeV
    */
    Double_t GetMass()      const { return fMass; }

    /** Modifiers **/
    /**
    * Set the  excitation energy
    */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
    * Set the mass in GeV
    */
    void SetMass(Double_t mass)      { fMass = mass*amu; }


  private:

    /** Data members **/

    static Int_t fgNIon;  //! /// Number of ions instantiated. One per generator.
    Int_t    fZ;          /// Atomic number
    Int_t    fA;          /// Atomic mass
    Int_t    fQ;          /// Electric charge
    Double_t fExcEnergy;  /// Excitation energy [GeV]
    Double_t fMass;       /// Mass [GeV]
    FairLogger* fLogger;  //! /// FairLogger
    static const Double_t amu; ///  .931494028 Gev/c**2

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon,2);

};



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "TVirtualMCApplication.h"      // for TVirtualMCApplication

#include "FairRunInfo.h"                // for FairRunInfo

#include "Rtypes.h"                     // for Int_t, Bool_t, Double_t, etc
#include "TLorentzVector.h"             // for TLorentzVector
#include "TString.h"                    // for TString

#include <map>                           // for map, multimap, etc
#include <list>                           // for list

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadGridManager;
class FairRadLenManager;
class FairRadMapManager;
class FairGenericRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;
/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
    *@param name      name
    *@param title     title
    *@param ModList  a TObjArray containing all detectors and modules used in this simulation
    *@param MatName  material file name
    */
    FairMCApplication(const char* name,   const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
    */
    FairMCApplication();
    /** default destructor
    */
    virtual ~FairMCApplication();
    /** Singelton instance
    */
    static FairMCApplication* Instance();
    virtual void          AddDecayModes();
    /**  Add user defined particles (optional) */
    virtual void          AddParticles();                                   // MC Application
    /** Add user defined ions (optional) */
    virtual void          AddIons();                                        // MC Application
    /**
    *Add user defined Tasks to be executed after each event (optional)
    * @param fTask: Task that has to be excuted during simulation
    */
    void                  AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    virtual void          BeginEvent();                                     // MC Application
    /** Define actions at the beginning of primary track */
    virtual void          BeginPrimary();                                   // MC Application
    /** Construct user geometry */
    virtual void          ConstructGeometry();                              // MC Application
    /** Define parameters for optical processes (optional) */
    virtual void          ConstructOpGeometry();                            // MC Application
    /** Define actions at the end of event */
    virtual void          FinishEvent();                                    // MC Application
    /** Define actions at the end of primary track */
    virtual void          FinishPrimary();                                  // MC Application
    /** Define actions at the end of run */
    void                  FinishRun();
    /** Generate primary particles */
    virtual void          GeneratePrimaries();                              // MC Application
    /** Return detector by name  */
    FairDetector*          GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField*             GetField() {return fxField;}
    /**Return primary generator*/
    FairPrimaryGenerator*  GetGenerator();
    /**Return list of tasks*/
    TTask*                GetListOfTasks();
    FairGenericStack*      GetStack();
    TChain*               GetChain();
    /** Initialize geometry */
    virtual void          InitGeometry();                                   // MC Application
    /** Initialize MC engine */
    void                  InitMC(const char* setup,  const char* cuts);
    /** Initialize Tasks if any*/
    void                  InitTasks();
    /**Define actions at the end of each track */
    virtual void          PostTrack();                                      // MC Application
    /** Define actions at the beginning of each track*/
    virtual void          PreTrack();                                       // MC Application

    /** Clone for worker (used in MT mode only) */
    virtual TVirtualMCApplication* CloneForWorker() const;

    /** Init application on worker (used in MT mode only) */
    virtual void InitOnWorker();

    /** Finish run on worker (used in MT mode only) */
    virtual void FinishRunOnWorker();

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void                  RunMC(Int_t nofEvents);
    /**
    * Set the magnetic field for simulation
    * @param field: magnetic field
    */
    void                  SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void                  SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void                  SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see SetPythiaDecayerConfig)
     */
    void                  SetPythiaDecayer(Bool_t decayer) {fPythiaDecayer=decayer;}
    /**
    * set the decay configuration macro to be used by Pythia
    */
    void                  SetPythiaDecayerConfig(const TString decayerConf) {fPythiaDecayerConfig=decayerConf;}
    /**
    * Switch for using the radiation length manager
    */
    void                  SetRadiationLengthReg(Bool_t RadLen);
    /**
    * Switch for using the radiation map manager
    */
    void                  SetRadiationMapReg(Bool_t RadMap);
    /**
    * Switch for debuging the tracking
    */
    void                  SetTrackingDebugMode( Bool_t set ) {fDebug = set;}
    /**
    * Switch for using 2 or 3 body phase-space decay
    * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config macro (see SetUserDecayConfig)
    */
    void                  SetUserDecay(Bool_t decay) {fUserDecay= decay;}
    /**
    * set the decay configuration macro to be used by user decay
    */
    void                  SetUserDecayConfig(const TString decayerConf) {fUserDecayConfig= decayerConf;}
    /** Define action at each step, dispatch the action to the corresponding detectors */
    virtual void          Stepping();                                       // MC Application
    /** Stop the run*/
    virtual void          StopRun();
    /**Define maximum radius for tracking (optional) */
    virtual Double_t      TrackingRmax() const;                             // MC Application
    /** Define maximum z for tracking (optional) */
    virtual Double_t      TrackingZmax() const;                              // MC Application

    void AddMeshList ( TObjArray* meshList );

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

    // data members
    /**List of active detector */
    TRefArray*           fActiveDetectors;
    /**List of FairTask*/
    FairTask*             fFairTaskList;//!
    /**detector list (Passive and Active)*/
    TRefArray*           fDetectors;
    /**Map used for dispatcher*/
    TRefArray*           fDetMap;
    /**Iterator for Module list*/
    TIterator*           fModIter; //!
    /**Module list in simulation*/
    TObjArray*           fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t                fNoSenVolumes; //!
    /**flag for using Pythia as external decayer */
    Bool_t               fPythiaDecayer;
    /** Pythia decay config macro*/
    TString               fPythiaDecayerConfig; //!
    /** Simulation Stack  */
    FairGenericStack*     fStack; //!
    /**Pointer to thr I/O Manager */
    FairGenericRootManager*  fRootManager; //!
    /**List of sensetive volumes in all detectors*/
    TRefArray*           fSenVolumes; //!
    /**Magnetic Field Pointer*/
    FairField*            fxField; //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen; //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t                fMcVersion;     // mc Version
    /** Track visualization manager */
    FairTrajFilter*       fTrajFilter; //!
    /**Flag for accepted tracks for visualization*/
    Bool_t               fTrajAccepted; //!
    /**Flag for using user decay*/
    Bool_t               fUserDecay;
    /**User decay config macro*/
    TString               fUserDecayConfig; //!
    /** Debug flag*/
    Bool_t               fDebug;//!
    /**dispatcher internal use */
    FairVolume*          fDisVol;
    /**dispatcher internal use */
    FairDetector*         fDisDet;
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* > fVolMap;//!
    /**dispatcher internal use */
    std::multimap <Int_t, FairVolume* >::iterator fVolIter; //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map <Int_t, Int_t > fModVolMap;//!
    /**dispatcher internal use RadLen*/
    std::map <Int_t, Int_t >::iterator fModVolIter; //!
    TLorentzVector fTrkPos; //!
    /** Flag for Radiation length register mode  */
    Bool_t   fRadLength;  //!

    /**Radiation length Manager*/
    FairRadLenManager*  fRadLenMan; //!
    /** Flag for Radiation map register mode  */
    Bool_t   fRadMap;     //!
    /**Radiation Map Manager*/
    FairRadMapManager*  fRadMapMan; //!
    /**Radiation map Grid Manager*/
    FairRadGridManager* fRadGridMan; //!

    FairEventHeader*    fEventHeader; //!

    FairMCEventHeader*  fMCEventHeader; //!
    /** list of senstive detectors used in the simuation session*/
    std::list <FairDetector *> listActiveDetectors; //!
    /** list of all detectors used in the simuation session*/
    std::list <FairDetector *> listDetectors;  //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC*  fMC;
    /** Pointer to FairRunSim //! */
    FairRunSim*  fRun;
    
    ClassDef(FairMCApplication,4)  //Interface to MonteCarlo application

  private:
    /** Protected copy constructor */
    FairMCApplication(const FairMCApplication&);
    /** Protected assignment operator */
    FairMCApplication& operator=(const FairMCApplication&);

    FairRunInfo fRunInfo;//!
    Bool_t      fGeometryIsInitialized;

    static FairMCApplication* fgMasterInstance;
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{ return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "TNamed.h"                     // for TNamed

#include "FairGeoInterface.h"           // for FairGeoInterface
#include "FairGeoLoader.h"              // for FairGeoLoader
#include "FairGeoNode.h"                // for FairGeoNode
#include "FairGeoVolume.h"              // for FairGeoVolume
#include "FairLogger.h"                 // for FairLogLevel::INFO, etc
#include "FairRun.h"                    // for FairRun
#include "FairRuntimeDb.h"              // for FairRuntimeDb

#include "Rtypes.h"                     // for Bool_t, Int_t, etc
#include "TList.h"                      // for TList (ptr only), TListIter
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString, operator!=

#include <stddef.h>                     // for NULL
#include <string>                       // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TGeoMedium;
class TRefArray;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule:  public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active=kFALSE);
    /**default dtor*/
    virtual  ~FairModule();
    /**Print method should be implemented in detector or module*/
    virtual void        Print(Option_t*) const {;}
    /**Set the geometry file name o be used*/
    virtual void        SetGeometryFileName(TString fname, TString geoVer="0");
    /**Get the Geometry file name*/
    virtual TString     GetGeometryFileName() {return  fgeoName ;}
    /**Get the geometry file version if used*/
    virtual TString     GetGeometryFileVer() {return   fgeoVer ;}
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void        ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void        ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void        ConstructRootGeometry();
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void        ConstructASCIIGeometry();
    /** Modify the geometry for the simulation run using methods of the Root geometry package */
    virtual void        ModifyGeometry() {;}
    /**construct geometry from GDML files*/
    virtual void        ConstructGDMLGeometry(TGeoMatrix*);
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const {;}
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const {;}

    /**template function to construct geometry. to be used in derived classes.*/
    template<class T, class U>
    void ConstructASCIIGeometry(T dataType1, TString containerName="", U datatype2 = NULL);

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for detectors
     * which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t      CheckIfSensitive(std::string name);
    /**called from ConstructRootGeometry()*/
    virtual void        ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void        ExpandNodeForGDML(TGeoNode*);
    /**return the MC id of a volume named vname*/
    virtual Int_t       getVolId( const TString& ) const {return 0;}
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t               GetModId() {return fModId;}
    /**Set the verbose level in this detector*/
    void                SetVerboseLevel(Int_t level) {fVerboseLevel=level;}
    /**return the detector status */
    Bool_t              IsActive() {return fActive;}
    /**set the detector/module id*/
    void                SetModId(Int_t id) {fModId=id;}
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void                SetMotherVolume(TString volName) {fMotherVolumeName=volName;}
    /**called from ConstuctASCIIGeometry*/
    void   ProcessNodes ( TList* aList );
    /**Set the parameter containers*/
    virtual  void       SetParContainers() {;}
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual  void       InitParContainers() {;}
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar;}

    /**list of volumes in a simulation session*/
    static              FairVolumeList*   vList; //!
    /**total number of volumes in a simulaion session*/
    static Int_t        fNbOfVolumes;  //!
    /**list of all sensitive volumes in  a simulaion session*/
    static TRefArray*   svList;   //!

    static TArrayI*     volNumber; //!
    TString             fMotherVolumeName; //!
    FairVolume*   getFairVolume(FairGeoNode* fNode);
    void    AddSensitiveVolume(TGeoVolume* v);
  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);  // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString             fgeoVer;
    TString             fgeoName;
    Int_t               fModId;
    Bool_t              fActive;
    Int_t               fNbOfSensitiveVol; //!
    Int_t               fVerboseLevel;
    TList*              flGeoPar; //!  list of Detector Geometry parameters
    Bool_t              kGeoSaved; //! flag for initialisation

    ClassDef( FairModule,4)
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T dataType1, TString containerName, U)
{
  FairGeoLoader* loader=FairGeoLoader::Instance();
  FairGeoInterface* GeoInterface =loader->getGeoInterface();
  T* MGeo=new T();
  MGeo->print();
  MGeo->setGeomFile(GetGeometryFileName());
  GeoInterface->addGeoModule(MGeo);
  Bool_t rc = GeoInterface->readSet(MGeo);
  if ( rc ) { MGeo->create(loader->getGeoBuilder()); }

  TList* volList = MGeo->getListOfVolumes();
  // store geo parameter
  FairRun* fRun = FairRun::Instance();
  FairRuntimeDb* rtdb= FairRun::Instance()->GetRuntimeDb();

  dataType1 = *MGeo;

  if ( "" != containerName) {
    LOG(INFO) << "Add GeoNodes for "<< MGeo->getDescription()
              << " to container " << containerName << FairLogger::endl;

    //    U par=(U)(rtdb->getContainer(containerName));
    U*      par=static_cast<U*>(rtdb->getContainer(containerName));
    TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
    TObjArray* fPassNodes = par->GetGeoPassiveNodes();

    TListIter iter(volList);
    FairGeoNode* node   = NULL;
    FairGeoVolume* aVol=NULL;

    while( (node = static_cast<FairGeoNode*>(iter.Next())) ) {
      aVol = dynamic_cast<FairGeoVolume*> ( node );
      if ( node->isSensitive()  ) {
        fSensNodes->AddLast( aVol );
      } else {
        fPassNodes->AddLast( aVol );
      }
    }
    ProcessNodes( volList );
    par->setChanged();
    par->setInputVersion(fRun->GetRunId(),1);

  }
}


#endif //FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, Double_t, Bool_t, etc
#include "TMCParticleType.h"            // for TMCParticleType
#include "TRef.h"                       // for TRef
#include "TRefArray.h"                  // for TRefArray
#include "TString.h"                    // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name, Int_t z, Int_t a, Int_t s,Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass , Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle( Int_t pdg , const TString name, TMCParticleType mcType, Double_t mass, Double_t charge,
                  Double_t lifetime, const TString pType="Ion",  Double_t width=0, Int_t iSpin=0, Int_t iParity=0,
                  Int_t iConjugation=0, Int_t iIsospin=0, Int_t iIsospinZ=0, Int_t gParity=0, Int_t lepton=0,
                  Int_t baryon=0,Bool_t stable=kFALSE);

    FairParticle();

    virtual ~FairParticle();

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    virtual void  Print(Option_t* option = "") const;
    void PrintDaughters() const;

    // get methods
    Int_t            GetPDG() const;
    TParticle*       GetParticle() const;
    FairParticle*     GetMother() const;
    Int_t            GetNofDaughters() const;
    FairParticle*     GetDaughter(Int_t i) const;
    virtual const char* GetName() const {return fname.Data();}
    TMCParticleType  GetMCType()  {return fmcType;}
    Double_t         GetMass()          {return fmass;}
    Double_t         GetCharge()        {return fcharge;}
    Double_t         GetDecayTime()     {return fDecayTime;}
    const TString&   GetPType()         {return fpType;}
    Double_t         GetWidth()         {return fwidth;}
    Int_t            GetSpin()          {return fiSpin;}
    Int_t            GetiParity()        {return fiParity;}
    Int_t            GetConjugation()   {return fiConjugation;}
    Int_t            GetIsospin()       {return fiIsospin;}
    Int_t            GetIsospinZ()      {return fiIsospinZ;}
    Int_t            GetgParity()        {return fgParity;}
    Int_t            GetLepton()        {return flepton;}
    Int_t            GetBaryon()        {return fbaryon;}
    Bool_t           IsStable()         {return fstable;}

  private:

    FairParticle(const FairParticle& P);
    FairParticle& operator= (const  FairParticle&) {return *this;}
    // data members
    Int_t     fpdg;
    TParticle*    fParticle;
    TRef          fMother;
    TRefArray     fDaughters;
    const TString            fname;
    TMCParticleType   fmcType;
    Double_t    fmass;
    Double_t    fcharge;
    Double_t    fDecayTime;
    const TString   fpType;
    Double_t    fwidth;
    Int_t     fiSpin;
    Int_t     fiParity;
    Int_t     fiConjugation;
    Int_t     fiIsospin;
    Int_t     fiIsospinZ;
    Int_t     fgParity;
    Int_t     flepton;
    Int_t     fbaryon;
    Bool_t    fstable;

    ClassDef(FairParticle,3) // Extended TParticle
};

#endif //FAIR_PARTICLE_H   


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3, *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "TNamed.h" // for TNamed

#include "FairGenerator.h" // for FairGenerator

#include <iosfwd>      // for ostream
#include "Rtypes.h"    // for Double_t, Bool_t, Int_t, etc
#include "TObjArray.h" // for TObjArray
#include "TVector3.h"  // for TVector3
#include "TMCProcess.h"

#include <iostream> // for operator<<, basic_ostream, etc

class FairGenericStack;
class FairMCEventHeader;
class TF1;
class TIterator;

class FairPrimaryGenerator : public TNamed {

public:
  /** Default constructor. **/
  FairPrimaryGenerator();

  /** Constructor with name and title **/
  FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

  /** Destructor. **/
  virtual ~FairPrimaryGenerator();

  /** Initialize the generater (if needed!)*/
  virtual Bool_t Init();

  /** Register a generator derived from FairGenerator.  **/
  void AddGenerator(FairGenerator *generator) {
    if (!fGenList) {
      std::cout << "Empty fGenList pointer ! " << std::endl;
      return;
    }
    fGenList->Add(generator);
  }

  /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
  virtual Bool_t GenerateEvent(FairGenericStack *pStack);

  /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
  virtual void AddTrack(Int_t pdgid, Double_t px, Double_t py, Double_t pz,
                        Double_t vx, Double_t vy, Double_t vz,
                        Int_t parent = -1, Bool_t wanttracking = true,
                        Double_t e = -9e9, Double_t tof = 0.,
                        Double_t weight = 0., TMCProcess proc = kPPrimary);

  /** Clone this object (used in MT mode only) */
  virtual FairPrimaryGenerator* ClonePrimaryGenerator() const;

  /** Set beam position and widths.
   *@param beamX0      mean x position of beam at target
   *@param beamY0      mean y position of beam at target
   *@param beamSigmaX  Gaussian beam width in x
   *@param beamSigmaY  Gaussian beam width in y
   **/
  void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX,
               Double_t beamSigmaY);

  /** Set nominal beam angle and angle widths.
   *@param beamAngleX0      mean x angle of beam at target
   *@param beamAngleY0      mean y angle of beam at target
   *@param beamAngleSigmaX  Gaussian beam angle width in x
   *@param beamAngleSigmaY  Gaussian beam angle width in y
   **/
  void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0,
                    Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

  /** Public method SetEventPlane
   **@param phiMin   Lower limit for event plane angle [rad]
   **@param phiMax   Upper limit for event plane angle [rad]
   **If set, an event plane angle will be generated with flat
   **distrtibution between phiMin and phiMax.
   **/
  void SetEventPlane(Double_t phiMin, Double_t phiMax);

  /** Set target position and thickness.
   *@param targetZ   z position of target center
   *@param targetDz  full target thickness
   **/
  void SetTarget(Double_t targetZ, Double_t targetDz);

  /** Set target position for multiple tagets. The thickness
   * is the same for all targets.
   *@param nroftargets   number of targets
   *@param *targetZ      z positions of target center
   *@param targetDz      full target thickness
   **/
  void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

  /** Enable vertex smearing in z and/or xy direction **/
  void SmearVertexZ(Bool_t flag);
  void SmearGausVertexZ(Bool_t flag);
  void SmearVertexXY(Bool_t flag);
  void SmearGausVertexXY(Bool_t flag);

  TObjArray *GetListOfGenerators() { return fGenList; }

  /** Set the pointer to the MCEvent **/
  void SetEvent(FairMCEventHeader *event) {
    fEvent = event;
  };

  /** Accessor to the MCEvent **/
  FairMCEventHeader *GetEvent() {
    return fEvent;
  };

  /** Swich on/off the tracking of a particle*/

  void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

  Int_t GetTotPrimary() { return fTotPrim; }

protected:
  /**  Copy constructor */
  FairPrimaryGenerator(const FairPrimaryGenerator&);
  /**  Assignment operator */
  FairPrimaryGenerator &operator=(const FairPrimaryGenerator&);

  /**  Nominal beam position at target in x [cm] */
  Double_t fBeamX0;
  /** Nominal beam position at target in y [cm]*/
  Double_t fBeamY0;
  /** Beam width (Gaussian) in x [cm]*/
  Double_t fBeamSigmaX;
  /**  Beam width (Gaussian) in y [cm]*/
  Double_t fBeamSigmaY;

  /**  Nominal beam angle at target in x [rad] */
  Double_t fBeamAngleX0;
  /**  Nominal beam angle at target in y [rad] */
  Double_t fBeamAngleY0;
  /**  Actual beam angle at target in x [rad] */
  Double_t fBeamAngleX;
  /**  Actual beam angle at target in y [rad] */
  Double_t fBeamAngleY;
  /** Beam angle width (Gaussian) in x [rad]*/
  Double_t fBeamAngleSigmaX;
  /** Beam angle width (Gaussian) in y [rad]*/
  Double_t fBeamAngleSigmaY;
  /** Actual beam direction at the vertex */
  TVector3 fBeamDirection;

  /** Lower limit for the event plane rotation angle [rad] */
  Double_t fPhiMin;
  /** Upper limit for the event plane rotation angle [rad] */
  Double_t fPhiMax;
  /** Actual event plane rotation angle [rad] */
  Double_t fPhi;

  /**  Nominal z position of center of targets [cm]*/
  Double_t *fTargetZ; //!
  /**  Number of targets;*/
  Int_t fNrTargets;
  /**  Full target thickness [cm]*/
  Double_t fTargetDz;

  /** Vertex position of current event [cm]*/
  TVector3 fVertex;

  /** Number of primary tracks in current event*/
  Int_t fNTracks;

  /**  Flag for uniform vertex smearing in z*/
  Bool_t fSmearVertexZ;
  /**  Flag for gaus vertex smearing in z*/
  Bool_t fSmearGausVertexZ;
  /**  Flag for vertex smearing in xy*/
  Bool_t fSmearVertexXY;
  /**  Flag for gaus vertex smearing in xy*/
  Bool_t fSmearGausVertexXY;
  /**  Flag for beam gradient calculation*/
  Bool_t fBeamAngle;
  /**  Flag for event plane rotation*/
  Bool_t fEventPlane;

  /**  Pointer to MC stack*/
  FairGenericStack *fStack; //!
  /**  List of registered generators */
  TObjArray *fGenList;
  /**  Iterator over generator list */
  TIterator *fListIter; //!
  /**  Pointer to MCEventHeader */
  FairMCEventHeader *fEvent; //!
  /** go to tracking  */
  Bool_t fdoTracking; //!
  /** Number of MC tracks before a Generator is called, needed for MC index
   * update */
  Int_t fMCIndexOffset; //!
  /** Number of all primaries of this run*/
  static Int_t fTotPrim; //!
  /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
  Int_t fEventNr;

  /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
  void MakeVertex();

  /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
  void MakeBeamAngle();

  /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
  void MakeEventPlane();

  ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairGenericRootManager.h
/// \brief Definition of the FairGenericRootManager class
///
/// TVirtualMCRootManager class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairGenericRootManager
#define ROOT_FairGenericRootManager

#include "TObject.h"
#include "TMCtls.h"

class FairWriteoutBuffer;
class FairRootManager;
class TClonesArray; 

/// \brief The interface to the Root IO manager for FairRoot multi-threaded applications.
///
/// Implemented according to TVirtualMCRootManager from Geant4 VMC.

class FairGenericRootManager : public TObject
{
  public:
    FairGenericRootManager();
    virtual ~FairGenericRootManager();     
  
    // static access method
    static FairGenericRootManager* Instance(); 
    
    // static method for activating debug mode
    static void SetDebug(Bool_t debug); 
    static Bool_t GetDebug();

    // methods
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile) = 0;
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile) = 0;
    virtual void                RegisterInputObject(const char* name, TObject* obj) = 0;
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile) = 0;
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer) = 0;

    virtual void  Fill() = 0;
    virtual void  Write() = 0;
    virtual void  CloseOutFile() = 0;
    // virtual void  WriteAndClose() = 0;

    virtual Int_t               GetBranchId(TString const &BrName) = 0;


    // access to the implementation class
    virtual FairRootManager*    GetFairRootManager() const = 0;
    virtual Int_t  GetId() const = 0;
    
    // static data members
    static  Bool_t  fgDebug; // Option to activate debug printings

  private:
    // not implemented
    FairGenericRootManager(const FairGenericRootManager& rhs);
    FairGenericRootManager& operator=(const FairGenericRootManager& rhs);
    
#if !defined(__CINT__)
    static  TMCThreadLocal FairGenericRootManager* fgInstance; // singleton instance
#else
    static                 FairGenericRootManager* fgInstance; // singleton instance
#endif 
};

// inline functions

inline void FairGenericRootManager::SetDebug(Bool_t debug) {
  fgDebug = debug;
}  
  
inline Bool_t FairGenericRootManager::GetDebug() {
  return fgDebug;
}  

#endif //ROOT_FairGenericRootManager
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairRootManagerSim.h
/// \brief Definition of the FairRootManagerSim class
///
/// TMCRootManager class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairRootManagerSim
#define ROOT_FairRootManagerSim

#include "FairGenericRootManager.h"

#include <vector>

class FairRootManager;
class FairWriteoutBuffer;
class TClonesArray; 

/// \brief The Root IO manager for FairRoot multi-threaded applications.
///
/// Implemented according to TMCRootManager from Geant4 VMC.
/// It implements the FairGenericRootManager interface.

class FairRootManagerSim : public FairGenericRootManager
{
  public:
    FairRootManagerSim();
    virtual ~FairRootManagerSim();     
  
    // methods
    // virtual void  Register(const char* name, const char* className, void* objAddress);
    // virtual void  Register(const char* name, const char* className, const void* objAddress);
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile);
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile);
    virtual void                RegisterInputObject(const char* name, TObject* obj);
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);

    virtual void  Fill();
    virtual void  Write();
    virtual void  CloseOutFile();

    virtual Int_t GetBranchId(TString const &BrName);

    virtual FairRootManager*    GetFairRootManager() const { return fRootManager; }
    virtual Int_t  GetId() const { return 0; }

  private:
    // not implemented
    FairRootManagerSim(const FairRootManagerSim& rhs);
    FairRootManagerSim& operator=(const FairRootManagerSim& rhs);

    // data members 
    FairRootManager*  fRootManager;  // The Root manager
};

#endif //ROOT_FairRootManagerSim
/********************************************************************************
 *    Copyright (C) 2017 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

//------------------------------------------------
// The Geant4 Virtual Monte Carlo package
// Copyright (C) 2013, 2014 Ivana Hrivnacova
// All rights reserved.
//
// For the licensing terms see geant4_vmc/LICENSE.
// Contact: root-vmc@cern.ch
//-------------------------------------------------

/// \file FairRootManagerSimMT.h
/// \brief Definition of the FairRootManagerSimMT class
///
/// TMCRootManagerMT class adapted for FairRoot.
///
/// \author I. Hrivnacova; IPN Orsay

#ifndef ROOT_FairRootManagerSimMT
#define ROOT_FairRootManagerSimMT

#include "FairGenericRootManager.h"

#include <vector>

class FairRootManager;
class FairWriteoutBuffer;
class TClonesArray; 

/// \brief The Root IO manager for VMC examples for multi-threaded applications.
///
/// Implemented according to TMCRootManager from Geant4 VMC.
/// It implements the FairGenericRootManager interface.

class FairRootManagerSimMT : public FairGenericRootManager
{
  public:
    FairRootManagerSimMT();
    virtual ~FairRootManagerSimMT();     
  
    // methods
    // virtual void  Register(const char* name, const char* className, void* objAddress);
    // virtual void  Register(const char* name, const char* className, const void* objAddress);
    virtual void                Register(const char* name, const char* folderName, TNamed* obj, Bool_t toFile);
    virtual void                Register(const char* name,const char* folderName ,TCollection* obj, Bool_t toFile);
    virtual void                RegisterInputObject(const char* name, TObject* obj);
    virtual TClonesArray*       Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    virtual FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);

    virtual void  Fill();
    virtual void  Write();
    virtual void  CloseOutFile();

    virtual Int_t GetBranchId(TString const &BrName);

    virtual FairRootManager*    GetFairRootManager() const { return fRootManager; }
    virtual Int_t  GetId() const { return fId; }

  private:
    // not implemented
    FairRootManagerSimMT(const FairRootManagerSimMT& rhs);
    FairRootManagerSimMT& operator=(const FairRootManagerSimMT& rhs);
    
    // methods
    void  LogMessage(const TString& message);
    void  FillWithLock();
    void  FillWithTmpLock();
    void  FillWithoutLock();

    // global static data members
    static  Int_t    fgCounter;         // The counter of instances
    static  Bool_t   fgIsFillLock;      // The if the Fill should be locked 
    static  std::vector<Bool_t>* fgIsFillLocks; // The info per thread if the Fill should be locked

    // data members 
    Int_t             fId;           // This manager ID 
    FairRootManager*  fRootManager;  // The Root manager
};

#endif //ROOT_FairRootManagerSimMT
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>               // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char      uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned char      uuid_t[16];

class FairRunIdGenerator
{
    struct uuid {
      uint32_t time_low;
      uint16_t time_mid;
      uint16_t time_hi_and_version;
      uint16_t clock_seq;
      uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);
  public:
    struct timespec getTimeSpec() {return fTimeSpec;}
    struct timespec getTimeSpecFromTID( unsigned  int ms);
    unsigned  int getTID();

  public:
    FairRunIdGenerator() : fTimeSpec() {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);



};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, FairVolume::Class, etc
#include "TString.h"                    // for TString
#include "FairModule.h"
#include "FairDetector.h"
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */


class FairVolume : public TNamed
{

  public:

    FairVolume();
    FairVolume(TString name, Int_t id=0, Int_t detid=0,FairModule* fMod=0);
    virtual ~FairVolume();

    //    const char*  GetName() { return fName.Data();}
    //    TString getName() { return fName;}

    void setRealName( TString name ) { fRealName = name;}
    const char* getRealName() { return fRealName.Data();}
    Int_t getVolumeId() { return fVolumeId;}
    Int_t getModId() { return  fModId;}
    void  setModId(Int_t id) { fModId=id;}
    void  setCopyNo(Int_t id) { fCopyNo=id;}
    void  setVolumeId ( Int_t id ) {fVolumeId= id;}
    void  setGeoNode(FairGeoNode* d) {fNode=d;}
    void  setMotherId(Int_t fM) {fMotherId=fM;}
    void  setMotherCopyNo(Int_t CopyNo) {fMotherCopyNo=CopyNo;}

    FairModule*   GetModule()     {return fModule;}
    FairDetector* GetDetector() { return fDetector;}
    void SetModule(FairModule* mod) {
        fModule=mod;
        if (mod->InheritsFrom("FairDetector")){
           fDetector=dynamic_cast<FairDetector *>(mod);
        }
    }

    Int_t getMCid() {return fMCid;}
    Int_t getCopyNo() { return fCopyNo;}
    void  setMCid(Int_t id) {fMCid=id;}
    FairGeoNode* getGeoNode() {return fNode;}
    Int_t getMotherId() { return fMotherId;}
    Int_t getMotherCopyNo() {return fMotherCopyNo;}


  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    //    TString fName;   /**Volume Name in MC*/
    TString fRealName; /**Volume Name in ASCII file*/
    Int_t fVolumeId;       /**Volume Id in GeoManager*/
    Int_t fModId;          /**Module Id in which this volume exist*/
    Int_t fMCid;   /**Volume Id in MC*/
    Int_t fCopyNo;         /**Volume Copy No*/
    Int_t fMotherId; /**Mother Volume Id*/
    Int_t fMotherCopyNo;   /**Mother Volume Copy No*/
    FairDetector* fDetector; /** The Detector which will proccess the hits for this volume*/
    FairModule*   fModule;    /**The Module in which the volume is */
    FairGeoNode*  fNode;     /**Node corresponding to this volume*/
    

    ClassDef(FairVolume,2) // Volume Definition

};

#endif //
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "TObject.h"                    // for TObject

#include "FairVolume.h"

#include "Rtypes.h"                     // for Int_t, etc
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString

//class FairVolume;

/**
* This Object is only used for internal book keeping!
* @author M. Al-Turany, D. Bertini
* @version 0.1
* @since 12.01.04
*/

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume( TString* name );
    Int_t getVolumeId( TString* name );

    FairVolume* findObject( TString name );
    void addVolume( FairVolume* elem);

    Int_t getEntries () { return fData->GetEntries();}
    FairVolume* At(Int_t pos ) { return ( dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList,1) // Volume List
};

#endif //FAIR_VOLUMELIST_H


/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/


#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairWriteoutBuffer.h"
#include "FairRecoEventHeader.h"

#include "TStopwatch.h"
#include "TString.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;
//class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{


  public :

    /** Default constructor **/
    FairEventBuilder();


    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);


    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*> > FindEvents() = 0;
    virtual void          StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void  SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }
    Int_t GetIdentifier() {
      return fIdentifier;
    }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t *option="") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() {
      return fMaxAllowedEventCreationTime;
    };
    void SetMaxAllowedTime(Double_t td) {
      fMaxAllowedEventCreationTime = td;
    };

    void    SetBuilderName(const char* name) {
      fBuilderName=name;
    }
    TString GetBuilderName() {
      return fBuilderName;
    }

  private:

    TString    fBuilderName;

    TStopwatch fTimer;
    Double_t   fExecTime;

    Int_t      fIdentifier;
    Double_t   fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------


/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/


#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairTask.h"
#include "FairEventBuilder.h"

#include "TStopwatch.h"

#include <map>
#include <set>
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{


  public :

    /** Default constructor **/
    FairEventBuilderManager();


    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose=1);


    /** Destructor **/
    virtual ~FairEventBuilderManager();


    /** Execution **/
    virtual void Exec(Option_t* opt);


    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:

    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double,FairRecoEventHeader*> > >  fPossibleEvents;


    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();


    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;


    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:

    /** Get parameter containers **/
    virtual void SetParContainers();


    /** Intialisation **/
    virtual InitStatus Init();


    /** Reinitialisation **/
    virtual InitStatus ReInit();


    /** Finish at the end of each event **/
    virtual void Finish();


    ClassDef(FairEventBuilderManager,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Int_t, Double_t, UInt_t, etc

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Get the MC time for this event*/
    Double_t GetEventTime() {return fEventTime;}

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() {return fInputFileId;}

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() {return fMCEntryNo;}

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) {fEventTime=time;}

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) {fInputFileId=id;}

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) {fMCEntryNo=id;}

    /**
     * Destructor
     */
    virtual ~FairEventHeader();
    virtual void Register(Bool_t Persistance = kTRUE);
  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Event Time **/
    Double_t  fEventTime;
    /** Input file identifier, the file description is in the File header*/
    Int_t     fInputFileId;
    /**MC entry number from input chain*/
    Int_t     fMCEntryNo;


    ClassDef(FairEventHeader,3)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, etc
#include "TString.h"                    // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
   **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{

  public:

    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
       * @param runid : unique run id
       */
    void SetRunId(UInt_t runid) {fRunId=runid;}

    /** Get the run ID for this run*/
    UInt_t GetRunId() {return fRunId;}

    /** Return the list of tasks class names */
    TList* GetListOfTasks() {return fTaskList;}

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();


    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);




  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);


    ClassDef(FairFileHeader,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for UInt_t, FairFileInfo::Class, etc
#include "TString.h"                    // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:

    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id,  UInt_t ChId);
    virtual  ~FairFileInfo();


    TString     GetPath()          {return fPath;}
    UInt_t      GetSize()          {return fSize;}
    UInt_t      GetIdentifier()    {return fIdentifier;}
    UInt_t      GetOrderInChain()  {return fInChainId;}

    void        Print(Option_t* option="") const;

    void        SetPath(TString path) {fPath = path;}
    void        SetSize(UInt_t  size) {fSize =size;}
    void        SetIdentifier(UInt_t  id) {fIdentifier =id;}
    void        SetOrderInChain(UInt_t id) {fInChainId =id;}



  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t  fSize;
    /** Signal file identifier used*/
    UInt_t  fIdentifier;
    /** file order in the chain*/
    UInt_t  fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo,1)
};

#endif //FAIRFILEINFO_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"              // for FairTimeStamp

#include "Rtypes.h"                     // for Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                   // for TVector3

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
  **@author V.Friese <v.friese@gsi.de>
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{

  public:

    /** Default constructor **/
    FairHit();


    /** Constructor with hit parameters **/
    FairHit(Int_t detID, TVector3& pos, TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();


    /** Accessors **/
    Double_t GetDx()            const { return fDx;                     };
    Double_t GetDy()            const { return fDy;                     };
    Double_t GetDz()            const { return fDz;                     };
    Int_t    GetRefIndex()      const { return fRefIndex;               };
    void PositionError(TVector3& dpos) const;
    Int_t    GetDetectorID()    const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos)       const;



    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index)   { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /*** Output to screen */
    virtual void Print(const Option_t*) const {;}

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& boost::serialization::base_object<FairTimeStamp>(*this);
        ar& fDetectorID;
        ar& fRefIndex;
        ar& fX;
        ar& fY;
        ar& fZ;
        ar& fDx;
        ar& fDy;
        ar& fDz;
    }

  protected:
    friend class boost::serialization::access;

    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t      fRefIndex;       ///< Index of FairMCPoint for this hit
    Int_t      fDetectorID;     ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit,3);
};


inline void FairHit::PositionError(TVector3& dpos) const
{
  dpos.SetXYZ(fDx, fDy, fDz);
}


inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
  fDx = dx;
  fDy = dy;
  fDz = dz;
}


inline void FairHit::SetPositionError(const TVector3& dpos)
{
  fDx = dpos.X();
  fDy = dpos.Y();
  fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const
{
  pos.SetXYZ(fX, fY, fZ);
}


inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairHit::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include "TObject.h"                    // for TObject; ClassDefNV

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Float_t, etc

#include <iostream>                     // for ostream, cout

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink() {};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.) {
      SetFile(file);
      SetEntry(entry);
      SetType(type);
      SetIndex(index);
      SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.) {
      SetFile(-1);
      SetEntry(-1);
      SetType(type);
      SetIndex(index);
      SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const {return fEntry;}
    int GetType() const;
    int GetIndex() const {return fIndex;}
    float GetWeight() const {return fWeight;}

    void SetFile(int file);
    void SetEntry(int entry){fEntry = entry;};
    void SetType(int type);
    void SetIndex(int index){fIndex = index;};

    void SetWeight(Float_t weight) {fWeight = weight;}
    void AddWeight(Float_t weight) {fWeight += weight;}


    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const {
      if ((GetFile() == link.GetFile() || link.GetFile() == -1) &&
		  (GetEntry() == link.GetEntry() || link.GetEntry() == -1) &&
			  GetType() == link.GetType() && GetIndex() == link.GetIndex()) {
        return true;
      } else {
        return false;
      }
    }

    bool operator<(const FairLink& link) const {
		if (GetFile() != -1 && link.GetFile() != -1){
			if (GetFile() < link.GetFile()) 		return true;
			else if (link.GetFile() < GetFile()) 	return false;
		}
		if (GetEntry() != -1 && link.GetEntry() != -1){
			if(GetEntry() < link.GetEntry())		return true;
			else if (link.GetEntry() < GetEntry())	return false;
		}
		if (GetType() < link.GetType())				return true;
		else if (link.GetType() < GetType())		return false;
		if (GetIndex() < link.GetIndex())			return true;
		else if (link.GetIndex() < GetIndex())		return false;

		return false;
    }

    friend std::ostream& operator<< (std::ostream& out, const FairLink& link) {
      link.PrintLinkInfo(out);
      return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
        void serialize(Archive& ar, const unsigned int)
        {
            ar& fFile;
            ar& fType;
            ar& fEntry;
            ar& fIndex;
            ar& fWeight;
        }


  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;


};

inline FairLink::FairLink() :
   fFile(0),
   fType(0),
   fEntry(-1),
   fIndex(-1),
   fWeight(1.0)
{
}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
  :fFile(0),
   fType(0),
   fEntry(-1),
   fIndex(index),
   fWeight(weight)
{
	SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
  :fFile(0),
   fType(0),
   fEntry(entry),
   fIndex(index),
   fWeight(weight)
{
	SetFile(file);
	SetType(type);
}

inline void FairLink::SetType(int type)
{
	if (type < -1) return;
	fType = type + 1;
}

inline int FairLink::GetType() const
{
	int type = fType;
	return type - 1;
}

inline void FairLink::SetFile(int file)
{
	if (file < -1) return;
	fFile = file + 1;
}

inline int FairLink::GetFile() const
{
	int file = fFile;
	return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/


#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include "TNamed.h"                     // for TNamed

#include "Rtypes.h"                     // for Double_t, UInt_t, etc
#include "TVector3.h"                   // for TVector3

class FairMCEventHeader : public TNamed
{

  public:

    /** Default constructor **/
    FairMCEventHeader();


    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(Int_t iEvent, Double_t x, Double_t y, Double_t z,
                      Double_t t, Double_t b, Int_t nPrim);


    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);


    /** Destructor **/
    virtual ~FairMCEventHeader();


    /** Accessors **/
    UInt_t GetRunID()   const { return fRunId; }     /// run identifier
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Double_t GetX()     const { return fX; }         /// vertex x [cm]
    Double_t GetY()     const { return fY; }         /// vertex y [cm]
    Double_t GetZ()     const { return fZ; }         /// vertex z [cm]
    Double_t GetT()     const { return fT; }         /// event time [ns]
    Double_t GetB()     const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim()    const { return fNPrim; }     /// number of input tracks
    Bool_t IsSet()      const { return fIsSet; }     /// Flag
    Double_t GetRotX()     const { return fRotX; } /// rot. around x-axis [rad]
    Double_t GetRotY()     const { return fRotY; } /// rot. around y-axis [rad]
    Double_t GetRotZ()     const { return fRotZ; } /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }


    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t)       { fT = t; }
    void SetB(Double_t b)          { fB = b; }
    void SetNPrim(Int_t nPrim)     { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet)     { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:


    UInt_t     fRunId;       ///  Run identifier
    UInt_t     fEventId;     ///  Event identifier
    Double32_t fX;           ///  Primary vertex x [cm]
    Double32_t fY;           ///  Primary vertex y [cm]
    Double32_t fZ;           ///  Primary vertex z [cm]
    Double32_t fT;           ///  Event time [s]
    Double32_t fB;           ///  Impact parameter [fm] (if relevant)
    Int_t      fNPrim;       ///  Number of input tracks
    Bool_t     fIsSet;       ///  Flag whether variables are filled
    Double32_t fRotX;        ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;        ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;        ///  Rotation around z-axis (event plane) [rad]


    ClassDef(FairMCEventHeader,2);

};


inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y,
    Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
  fX = vertex.X();
  fY = vertex.Y();
  fZ = vertex.Z();
}


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/



#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TVector3.h"                   // for TVector3


#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class FairMCPoint : public FairMultiLinkedData_Interface
{

  public:

    /** Default constructor **/
    FairMCPoint();


    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                Double_t tof, Double_t length, Double_t eLoss, UInt_t EventId=0);
    
    /** Destructor **/
    virtual ~FairMCPoint();


    /** Accessors */
    UInt_t   GetEventID()    const { return fEventId; }        /// event identifier
    Int_t    GetTrackID()    const { return fTrackID; }
    Double_t GetPx()         const { return fPx; }
    Double_t GetPy()         const { return fPy; }
    Double_t GetPz()         const { return fPz; }
    Double_t GetTime()       const { return fTime; }
    Double_t GetLength()     const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t    GetDetectorID()   const { return fDetectorID;             };
    Double_t GetX()             const { return fX;                      };
    Double_t GetY()             const { return fY;                      };
    Double_t GetZ()             const { return fZ;                      };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }




    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id;}
    void SetTime(Double_t time)        { fTime = time; }
    void SetLength(Double_t length)    { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);


    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;


    
    template<class Archive>
    void serialize(Archive & ar, const unsigned int) 
    {
        //ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar & fTrackID;
        ar & fEventId;
        ar & fDetectorID; 
        ar & fX;
        ar & fY;
        ar & fZ;
        ar & fPx;
        ar & fPy;
        ar & fPz; 
        ar & fTime; 
        ar & fLength; 
        ar & fELoss; 
    }

  protected:

    friend class boost::serialization::access;

    Int_t fTrackID;               ///< Track index
    UInt_t fEventId;              ///< MC Event id
    Double32_t fPx, fPy, fPz;     ///< Momentum components [GeV]
    Double32_t fTime;             ///< Time since event start [ns]
    Double32_t fLength;           ///< Track length since creation [cm]
    Double32_t fELoss;            ///< Energy loss at this point [GeV]
    Int_t      fDetectorID;       ///< Detector unique identifier
    Double32_t fX, fY, fZ;        ///< Position of hit [cm]


    ClassDef(FairMCPoint,5)

};


inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
  fPx = mom.Px();
  fPy = mom.Py();
  fPz = mom.Pz();
}


inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
  fX = x;
  fY = y;
  fZ = z;
}


inline void FairMCPoint::SetPosition(const TVector3& pos)
{
  fX = pos.X();
  fY = pos.Y();
  fZ = pos.Z();
}



#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Int_t, etc
#include "TH2.h"                        // for TH2D
#include "TString.h"                    // for TString

/**
 * Abstract base class for Mesh Objects.
  **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{

  public:

    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);


    /** Destructor **/
    virtual ~FairMesh();


    /** Accessors **/
    Double_t GetXmin()  const { return fXmin;  };
    Double_t GetYmin()  const { return fYmin;  };
    Double_t GetZmin()  const { return fZmin;  };

    Double_t GetXmax()  const { return fXmax;  };
    Double_t GetYmax()  const { return fYmax;  };
    Double_t GetZmax()  const { return fZmax;  };


    /** Modifiers **/
    void SetX(Double_t xmin,Double_t xmax, Int_t nbin ) {
      fXmin = xmin;
      fXmax = xmax;
      NXbin = nbin;
    }
    void SetY(Double_t ymin,Double_t ymax, Int_t nbin ) {
      fYmin = ymin;
      fYmax = ymax;
      NYbin = nbin;
    }
    void SetZ(Double_t zmin,Double_t zmax, Int_t nbin ) {
      fZmin = zmin;
      fZmax = zmax;
      NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
// virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x , Double_t y , Double_t we ) {
      fMeshTid->Fill(x,y,we);
    }
    void fillFluence(Double_t x , Double_t y , Double_t we ) {
      fMeshFlu->Fill(x,y,we);

    }
    void fillSEU(Double_t x , Double_t y , Double_t we ) {
      fMeshSEU->Fill(x,y,we);

    }
    void Scale(Double_t fac ) {
      fMeshTid->Scale(fac);
      fMeshFlu->Scale(fac);
      fMeshSEU->Scale(fac);
    }

    void calculate();


    void print();
  protected:

    Double_t  fXmin, fYmin, fZmin;
    Double_t  fXmax, fYmax, fZmax;
    Int_t     NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid; // !mesh
    TH2D* fMeshFlu; // !mesh
    TH2D* fMeshSEU; // !mesh
    TString fhname; // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh,1);

};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector

class FairMultiLinkedData : public  TObject
{
  public:
    FairMultiLinkedData();///< Default constructor
    FairMultiLinkedData(std::set<FairLink> links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor

    virtual ~FairMultiLinkedData() {};

    virtual std::set<FairLink>    GetLinks() const {    return fLinks;}           ///< returns stored links as FairLinks
    virtual FairLink		GetEntryNr() const { return fEntryNr;}				///< gives back the entryNr
    virtual Int_t           GetNLinks() const { return fLinks.size(); }       ///< returns the number of stored links
    virtual FairLink        GetLink(Int_t pos) const;                 ///< returns the FairLink at the given position
    virtual FairMultiLinkedData   GetLinksWithType(Int_t type) const;             ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink> GetSortedMCTracks();				///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject*         GetData(FairLink& myLink);                  ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType;}
    Bool_t              GetPersistanceCheck() {return fPersistanceCheck;}     ///< Returns the value of PersistanceCheck
    Int_t             GetVerbose() {return fVerbose;}             ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) {  fDefaultType = type;}
    virtual void SetPersistanceCheck(Bool_t check) {fPersistanceCheck = check;}       ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) {fVerbose = level;}                ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val){ fInsertHistory = val;}		///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const {return fInsertHistory;}

    virtual void SetEntryNr(FairLink entry){ fEntryNr = entry;}
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);           ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link, Bool_t bypass = kFALSE, Float_t mult = 1.0);      ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);                         ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(FairLink link);                      ///< Adds the FairLinks of the inserted link to the set of links of this object


    virtual void AddAllWeights(Double_t weight);                        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);                        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);                   ///<Multiplies all Links with weight


    virtual Bool_t IsLinkInList(FairLink link)    {return IsLinkInList(link.GetType(), link.GetIndex());}   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(Int_t type, Int_t index);                             ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)  {return LinkPosInList(link.GetType(), link.GetIndex());}    ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);                             ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)    {DeleteLink(link.GetType(), link.GetIndex());}          ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);                               ///< Deletes a link ouf of fLinks

    virtual void Reset() {ResetLinks();}
    virtual void ResetLinks() {fLinks.clear();}                                    ///< Clears fLinks


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
      out << GetEntryNr() << " -> [";
      for (Int_t i = 0; i < GetNLinks(); i++) {
        GetLink(i).PrintLinkInfo(out);
        out << " ";
      }
      out << "]";
      return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, const FairMultiLinkedData& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck; //!
    Bool_t fInsertHistory; //!
    Int_t fVerbose; //!

    virtual void SimpleAddLinks(Int_t fileId, Int_t evtId, Int_t dataType, std::vector<Int_t> links, Bool_t, Float_t) {
      for (UInt_t i = 0; i < links.size(); i++) {
        fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
      }
    }
    Int_t fDefaultType;


    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FAIRMULTILinkedData_H_ */
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "TObject.h"                    // for TObject

#include "FairLink.h"                   // for FairLink
#include "FairMultiLinkedData.h"
#include "FairRootManager.h"

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Int_t, Bool_t, kFALSE, etc
#include "TString.h"                    // for TString
#include "TRef.h"

#include <iostream>                     // for operator<<, ostream, cout
#include <set>                          // for set
#include <vector>                       // for vector


class FairMultiLinkedData_Interface : public  TObject
{
  public:
    FairMultiLinkedData_Interface();///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);///< Constructor
    FairMultiLinkedData_Interface(TString dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1,Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType, std::vector<Int_t> links, Int_t fileId = -1, Int_t evtId = -1, Bool_t persistanceCheck = kTRUE, Bool_t bypass = kFALSE, Float_t mult = 1.0);///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    virtual ~FairMultiLinkedData_Interface() {
    	delete(fLink);
    };

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    virtual std::set<FairLink>  GetLinks() const;           		///< returns stored links as FairLinks
    virtual Int_t           	GetNLinks() const;                	///< returns the number of stored links
    virtual FairLink        	GetLink(Int_t pos) const;         	///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(Int_t type) const; ///< returns all FairLinks with the corresponding type
    virtual FairLink            GetEntryNr() const;
    FairMultiLinkedData* 	GetPointerToLinks() const { return fLink;}

    virtual std::vector<FairLink> GetSortedMCTracks();

    virtual void SetLinks(FairMultiLinkedData links);           ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link);      					///< Sets the Links with a single FairLink
    virtual void SetInsertHistory(Bool_t val);
    virtual void SetEntryNr(FairLink val);
    virtual void SetPointerToLinks(FairMultiLinkedData* links) {fLink = links;}

    virtual void AddLinks(FairMultiLinkedData links, Float_t mult = 1.0);		///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    virtual void AddLink(FairLink link);      									///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed more than once otherwise
    virtual void AddInterfaceData(FairMultiLinkedData_Interface* data);



    virtual void ResetLinks();


    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const {

		if (GetPointerToLinks() != 0)
			GetPointerToLinks()->PrintLinkInfo(out);
		return out;
    }                                                     ///< Output

    friend std::ostream& operator<< (std::ostream& out, FairMultiLinkedData_Interface& data) {
      data.PrintLinkInfo(out);
      return out;
    }                                                     ///< Output

  protected:
    FairMultiLinkedData* fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();

    ClassDef(FairMultiLinkedData_Interface, 5);
};

inline
FairMultiLinkedData_Interface::FairMultiLinkedData_Interface()
  :TObject(), fLink(NULL)
{
}


/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is stored
 */


#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------


/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadLenPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss, TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Float_t  fRadLen);


    /** Destructor **/
    virtual ~FairRadLenPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()              { return fZmat; }
    Float_t GetRadLength()      { return fRadLen;}
    Float_t GetDensity()        { return fDensity ; }


    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)              { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }


  protected:

    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Float_t        fRadLen;     // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadLenPoint,1)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------


/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"                // for FairMCPoint

#include "Rtypes.h"                     // for Double_t, Float_t, Int_t, etc
#include "TVector3.h"                   // for TVector3

class FairRadMapPoint : public FairMCPoint
{

  public:

    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID, Int_t detID, TVector3 pos, TVector3 mom,
                    Double_t tof, Double_t length, Double_t eLoss,
                    TVector3 posOut, TVector3 momOut,
                    Float_t  fA, Float_t fZ,  Float_t  fDensity, Double_t fVolMass,
                    Double_t fStep, Double_t fDose, Double_t fDoseSL, Int_t fPdg );


    /** Destructor **/
    virtual ~FairRadMapPoint();


    /** Accessors **/
    Float_t GetA()              { return fA; }
    Float_t GetZm()             { return fZmat; }
    Float_t GetMass()           { return fVolMass;}
    Float_t GetDensity()        { return fDensity ; }

    /** Modifiers **/
    void SetA(Double_t A)              { fA = A; }
    void SetZm(Double_t Z)             { fZmat = Z; }
    void SetMass(Double_t vmass)       { fVolMass = vmass;}
    void SetDensity (Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg;};

    Double_t GetXOut() const { return fXOut;};
    Double_t GetYOut() const { return fYOut;};
    Double_t GetZOut() const { return fZOut;};

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose;}
    Double_t GetDoseSL() const { return fDoseSL;}

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ);}
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut);}

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut);};
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut,fPyOut,fPzOut); }



  protected:

    //  Int_t          detID;       // detector ID or volume ID
    Int_t          fPdg;        // track PID
    Float_t        fA;          // A of material
    Float_t        fZmat;       // Z of material
    Float_t        fDensity;    // density of material
    Double_t       fVolMass;     // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;


    ClassDef(FairRadMapPoint,3)

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H


#include "TNamed.h"

/**
 *  Event Header Class
  **@author D.Bertini <d.bertini@gsi.de>
  **@author M.Al-Turany <m.al-turany@gsi.de>
  **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{

  public:

    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const {
      return fRunId;
    }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const {
      return fEventTime;
    }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const {
      return fEventTimeError;
    }

    /** Get identifier*/
    Int_t GetIdentifier() const {
      return fIdentifier;
    }

    /** Set the run ID for this run
    * @param runid : unique run id
    */
    void SetRunId(UInt_t runid) {
      fRunId=runid;
    }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr) {
      fEventTime=time;
      fEventTimeError=terr;
    }

    /** Set the run ID for this run
    * @param ident : identifier
    */
    void SetIdentifier(Int_t ident) {
      fIdentifier=ident;
    }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const {
      if (fEventTime < tempObj.GetEventTime()) { return true; }
      else if (fEventTime > tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const {
      if (fEventTime > tempObj.GetEventTime()) { return true; }
      else if (fEventTime < tempObj.GetEventTime()) { return false; }
      return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const {
      if   (fEventTime == tempObj.GetEventTime() ) {
        return true;
      }
      return false;
    }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:

    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t     fIdentifier;
    /** Event Time **/
    Double_t  fEventTime;
    /** Event Time Error **/
    Double_t  fEventTimeError;

    ClassDef(FairRecoEventHeader,1)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Long_t, etc
#include "TSystem.h"                    // for CpuInfo_t, MemInfo_t, etc
#include "TTimeStamp.h"                 // for TTimeStamp

#include <vector>                       // for vector

class FairLogger;
class TList;

class FairRunInfo : public TObject
{

  public:

    FairRunInfo();

    ~FairRunInfo();

    void StoreInfo();

    void WriteInfo();

    void Reset();

  private:

    TTimeStamp  fTimeStamp;//!
    CpuInfo_t   fCpuInfo;//!
    MemInfo_t   fMemInfo;//!
    ProcInfo_t  fProcInfo;//!
    std::vector<Double_t> fTimeDiff;//!
    std::vector<Double_t> fTime;//!
    std::vector<Long_t> fResidentMemory;//!
    std::vector<Long_t> fVirtualMemory;//!

    void CalculateTimeDifference();

    void PrintInfo();

    void GetInfo();

    void CreateAndFillHistograms(TList* histoList);

    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo,2)

};
#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"        // for FairMultiLinkedData

#include "FairLink.h"                   // for FairLink

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Double_t, etc

#include <iostream>                     // for ostream, cout

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp()             const { return fTimeStamp; }
    Double_t GetTimeStampError()     const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) {fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const {
      if (this == obj) { return 0; }
      FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
      Double_t ts = tsobj->GetTimeStamp();
      Double_t tserror = tsobj->GetTimeStampError();
      if (fTimeStamp < ts) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError < tserror) { return -1; }
      else if (fTimeStamp == ts && fTimeStampError == tserror) { return 0; }
      else { return 1; }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE;};

    virtual bool equal(FairTimeStamp* data) {
      return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<< (std::ostream& out, const FairTimeStamp& link) {
      link.PrintTimeInfo(out);
      return out;
    }

    virtual bool operator< (const FairTimeStamp* rValue) const {
    	if (GetTimeStamp() < rValue->GetTimeStamp())
    		return true;
    	else
    		return false;
    }

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        // ar & boost::serialization::base_object<FairMultiLinkedData>(*this);
        ar& fTimeStamp;
        ar& fTimeStampError;
    }

  protected:
    friend class boost::serialization::access;

    Double_t fTimeStamp;        /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError;     /** Error on time stamp */

    ClassDef(FairTimeStamp,4);
};

// -----   Default constructor   -------------------------------------------
inline
FairTimeStamp::FairTimeStamp()
  : FairMultiLinkedData_Interface(),
    fTimeStamp(-1),
    fTimeStampError(-1)
{
}

// -----   Standard constructor   ------------------------------------------
inline
FairTimeStamp::FairTimeStamp(Double_t time)
  : FairMultiLinkedData_Interface(),
    fTimeStamp(time),
    fTimeStampError(-1)
{
}

inline
FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
  : FairMultiLinkedData_Interface(),
    fTimeStamp(time),
    fTimeStampError(timeerror)
{
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------


/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/


#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, Double32_t, Int_t, etc
#include "TMatrixFSymfwd.h"             // for TMatrixFSym
#include "TVector3.h"                   // for TVector3

class FairTrackParam : public TObject
{

  public:

    /** Constructor **/
    FairTrackParam();


    /** Constructor with all variables **/
    FairTrackParam(Double_t x,  Double_t y,  Double_t z,
                   Double_t tx, Double_t ty, Double_t qp,
                   const TMatrixFSym& covMat);


    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);


    /** Destructor **/
    virtual ~FairTrackParam();


    /** Output to screen **/
    void  Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX()  const { return fX; };
    Double_t GetY()  const { return fY; };
    Double_t GetZ()  const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;


    /** Modifiers **/
    void SetX(Double_t x)   { fX  = x;  };
    void SetY(Double_t y)   { fY  = y;  };
    void SetZ(Double_t z)   { fZ  = z;  };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);


    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par );



  private:

    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];


    ClassDef(FairTrackParam,1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------


/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to GEANT3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include <iosfwd>                       // for ostream
#include "Rtypes.h"                     // for Double_t, Bool_t, etc
#include "TVirtualMagField.h"

#include <stdio.h>                      // for printf
#include <iostream>                     // for operator<<, basic_ostream, etc

#include "FairLogger.h"


class FairField : public TVirtualMagField
{

  public:

    /** Default constructor **/
    FairField();


    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) {return *this;}

    /** Destructor **/
    virtual ~FairField();


    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init() { };

    /** Test whether field type is Constant **/
    Bool_t IsConst();


    /** Test whether field typ is Map **/
    Bool_t IsMap();


    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }


    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBx Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBy Should be implemented in User class"<<FairLogger::endl; return 0;}

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz(Double_t, Double_t, Double_t) {LOG(WARNING)<<"FairField::GetBz Should be implemented in User class"<<FairLogger::endl; return 0;}


    /** Get magnetic field. For use of GEANT3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);


    void Field(const Double_t point[3], Double_t* B) {GetFieldValue(point,B);}


    /** Screen output. To be implemented in the concrete class. **/
    virtual void  Print(Option_t*) const {;}
    virtual void GetBxyz(const Double_t[3], Double_t*) {LOG(WARNING)<<"FairField::GetBxyz Should be implemented in User class"<<FairLogger::endl;}



    /**Fill Paramater*/

    virtual void FillParContainer() {LOG(WARNING)<<"FairField::FillParContainer Should be implemented in User class"<<FairLogger::endl;}
  protected:

    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    //TODO: Check why the htrack needs this
    ClassDef(FairField,4);

};




#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------


#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include "Rtypes.h"                     // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{

  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() {
      FairField* field=0;
      if(fCreator) { field= fCreator->createFairField(); }
      return field;
    };
    virtual void SetParm() {
      if(fCreator) { fCreator->SetParm(); }
    }

  protected:
    FairFieldFactory* fCreator;
    static FairFieldFactory*  fgRinstance;

    ClassDef(FairFieldFactory,1)
  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator= (const  FairFieldFactory&) {return *this;}

};
#endif //FAIRFIELDFACTORY_H







/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
* Runge-Kutte Track propagator
* @author M. Al-Turany
* @version 0.1
* @since 22.1.10
*/

#ifndef RKPropagator
#define RKPropagator

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Double_t, etc

class FairField;

class FairRKPropagator : public TObject
{

  private:
    FairRKPropagator(const FairRKPropagator&);            // Not implemented
    FairRKPropagator& operator=(const FairRKPropagator&); // Not implemented
    Double_t fMaxStep;
    FairField*              fMagField;
  public:
    void Step(Double_t Charge, Double_t* vecRKIn, Double_t* vecOut);
    Double_t OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
    FairRKPropagator(FairField* field);
    /**Propagate to closest approach of a point
    @CHARGE    Particle charge
    @STEP      maximum Step size
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vecOut    Output co-ords,direction cosines,momentum
    */
    void Propagat(Double_t Charge, Double_t* vecRKIn, Double_t* Pos);

    /**Propagate to closest approach of a plane
    @CHARGE    Particle charge
    @vecRKIn   Initial co-ords,direction cosines,momentum
    @vec1      vector on the plane
    @vec2      vector on the plane
    @vec3      point on the plane
    @vecOut    Output co-ords,direction cosines,momentum
    */

    void PropagatToPlane(Double_t Charge, Double_t* vecRKIn, Double_t* vec1, Double_t* vec2, Double_t* vec3, Double_t* vecOut);

    virtual ~FairRKPropagator();
    ClassDef(FairRKPropagator, 1);

};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "TObject.h"

#include <iostream>

class FairEventHeader;

enum Source_Type {kONLINE, kFILE};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void Reset() = 0;

    virtual Bool_t   ActivateObject(TObject**, const char*)  { return kFALSE; }
    virtual Bool_t   ActivateObjectAny(void **, const std::type_info &, const char*) { return kFALSE; }

    virtual Source_Type GetSourceType() = 0;

    virtual void SetParUnpackers() = 0;

    virtual Bool_t InitUnpackers() = 0;

    virtual Bool_t ReInitUnpackers() = 0;

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t=0) {return -1;}
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char*) {return;}
    virtual void   ReadBranchEvent(const char*, Int_t) {return;}
    virtual void FillEventHeader(FairEventHeader* feh);

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const     { return fRunId;  }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TFolder.h"
#include "TF1.h"
class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;

class FairFileSource : public FairSource
{
public:
    FairFileSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairFileSource(const TString RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairFileSource(const FairFileSource& file);
    virtual ~FairFileSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName);
    /**Read specific tree entry on one branch**/
    virtual void   ReadBranchEvent(const char* BrName, Int_t Entry);
    virtual void FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/
    void                AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void                AddFile(TString FileName);
    void                AddFriendsToChain();
    void                PrintFriendList();
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    void                CheckFriendChains();
    void                CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree*              GetInTree() {return fInChain->GetTree();}
    TChain*             GetInChain() {return fInChain;}
    TFile*              GetInFile() {return  fRootFile;}
    void                CloseInFile() { if(fRootFile) { fRootFile->Close(); }}
    /**Set the input tree when running on PROOF worker*/
    void                SetInTree (TTree*  tempTree);
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void                SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    //    virtual Bool_t   SetObject(TObject* obj, const char* ObjType);
    //    virtual void     SetObjectName(const char* ObjName, const char* ObjType);

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);
    virtual Bool_t   ActivateObjectAny(void **, const std::type_info &, const char*);

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void                SetCheckFileLayout(Bool_t enable) {fCheckFileLayout = enable;}

private:
    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** Current Entry number */
    Int_t                             fCurrentEntryNr;  //!
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /**Input Chain */
    TChain*                             fInChain;
    /**Input Tree */
    TTree*                              fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;
    
    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
     Bool_t                                 fCheckFileLayout; //!

    ClassDef(FairFileSource, 3)
};


#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairSource.h"
#include <list>    
#include "TChain.h"
#include "TFile.h"
#include "TF1.h"

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class FairLogger;
class FairRuntimeDb;
class TFolder;

class FairRootManager;

class FairMixedSource : public FairSource
{
public:
    FairMixedSource(TFile *f, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString* RootFileName, const char* Title="InputRootFile", UInt_t identifier=0);
    FairMixedSource(const TString RootFileName, const Int_t signalId, const char* Title="InputRootFile", UInt_t identifier=0);
  //  FairMixedSource(const FairMixedSource& file);
    virtual ~FairMixedSource();
    
    Bool_t              Init();
    Int_t               ReadEvent(UInt_t i=0);
    void                Close();
    void                Reset();

    virtual Source_Type GetSourceType() { return kFILE; }

    virtual void SetParUnpackers() {}

    virtual Bool_t InitUnpackers() { return kTRUE; }

    virtual Bool_t ReInitUnpackers() { return kTRUE; }

    /**Check the maximum event number we can run to*/
    virtual Int_t  CheckMaxEventNo(Int_t EvtEnd=0);
    /**Read the tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName);
    /** Read specific tree entry on one branch**/
    void             ReadBranchEvent(const char* BrName, Int_t Entry);

    void                FillEventHeader(FairEventHeader* feh);

    const TFile*        GetRootFile(){return fRootFile;}
    /** Add a friend file (input) by name)*/

    virtual Bool_t   ActivateObject(TObject** obj, const char* BrName);

    void             ReadBKEvent(UInt_t i=0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void                  SetSignalFile(TString name, UInt_t identifier );
    /**Set the input background file by name*/
    void                  SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void                  AddSignalFile(TString name, UInt_t identifier );
    void                  AddBackgroundFile(TString name);

    TChain*             GetBGChain() { return  fBackgroundChain;}
    TChain*             GetSignalChainNo(UInt_t i);

    Bool_t            OpenBackgroundChain();
    Bool_t            OpenSignalChain();

    /**Set the signal to background ratio in event units
    *@param background :  Number of background Events for one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
    *@param background :  Time of background Events before one signal
    *@param Signalid :    Signal file Id, used when adding (setting) the signal file
    */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void                SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void                SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime). The total repetition time is beamTime + gapTime */
    void                SetBeamTime(Double_t beamTime, Double_t gapTime);
    void                SetEventTime();
    Double_t		GetDeltaEventTime();
    void                SetFileHeader(FairFileHeader* f) {fFileHeader =f;}
    Double_t            GetEventTime();

    /**Add ROOT file to input, the file will be chained to already added files*/
    Bool_t              CompareBranchList(TFile* fileHandle, TString inputLevel);
    /**Set the input tree when running on PROOF worker*/
    TObjArray*          GetListOfFolders(){return fListFolder;}
    TFolder*            GetBranchDescriptionFolder(){return fCbmroot;}
    UInt_t              GetEntries(){return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void                SetEvtHeaderNew(Bool_t Status) {fEvtHeaderIsNew = Status;}
    Bool_t              IsEvtHeaderNew() {return fEvtHeaderIsNew;}

private:
    /**IO manager */
    FairRootManager*         fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString                           fInputTitle;
    /**ROOT file*/
    TFile*                            fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString>                fFriendFileList; //!
    std::list<TString>                fInputChainList;//!
    std::map<TString, TChain*>          fFriendTypeList;//!
    std::map<TString, std::list<TString>* > fCheckInputBranches; //!
    std::list<TString>                      fInputLevel; //!
    std::map<TString, std::multimap<TString, TArrayI> > fRunIdInfoAll; //!
    /** list of folders from all input (and friends) files*/
    TObjArray                           *fListFolder; //!
    /** RuntimeDb*/
    FairRuntimeDb*           fRtdb;
    /**folder structure of output*/
    TFolder*                            fCbmout;
    /**folder structure of input*/
    TFolder*                            fCbmroot;
    /***/
    UInt_t                              fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t                              fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t                              IsInitialized;

    /** MC Event header */
    FairMCEventHeader*                      fMCHeader; //!

    /**Event Header*/
    FairEventHeader*                        fEvtHeader; //!

    /**Output Event Header*/
    FairEventHeader*                        fOutHeader; //!

    /**File Header*/
    FairFileHeader*                        fFileHeader; //!

    /** This is true if the event time used, came from simulation*/
    Bool_t                                  fEventTimeInMCHeader; //!
    /**This flag is true if the event header was created in this session
    * otherwise it is false which means the header was created in a previous data
    * level and used here (e.g. in the digi)
    */
    Bool_t      fEvtHeaderIsNew; //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fCurrentEntryNo; //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t                                  fTimeforEntryNo; //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t                                  fNoOfBGEntries; //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t>                fCurrentEntry; //! 

    /** min time for one event (ns) */
    Double_t                                fEventTimeMin;  //!
    /** max time for one Event (ns) */
    Double_t                                fEventTimeMax;  //!
    /** Time of event since th start (ns) */
    Double_t                                fEventTime;     //!
    /** Time of particles in beam (ns) */
    Double_t                                fBeamTime; //!
    /** Time without particles in beam (gap) (ns) */
    Double_t                                fGapTime; //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t                                fEventMeanTime; //!
    /** used to generate random numbers for event time; */
    TF1*                                    fTimeProb;      //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t>              fSignalBGN;//! 
    /* /\**True for background window in entry units*\/ */
    Bool_t                                  fSBRatiobyN;  //! 
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t                                  fSBRatiobyT;  //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t                              fActualSignalIdentifier; //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t                              fNoOfSignals; //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>*                  fSignalChainList; //!
    /**Chain containing the background*/
    TChain*                              fBackgroundChain; //!
    std::map<UInt_t, TChain*>            fSignalTypeList;//!

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);
    
public:
    ClassDef(FairMixedSource, 0)
};


#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRONLINESOURCE_H
#define FAIRONLINESOURCE_H

#include "FairSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairOnlineSource : public FairSource
{
  public:
    FairOnlineSource();
    FairOnlineSource(const FairOnlineSource& source);
    virtual ~FairOnlineSource();

    inline void AddUnpacker(FairUnpack* unpacker) { fUnpackers->Add(unpacker); }
    inline const TObjArray* GetUnpackers() const { return fUnpackers; }

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

    virtual void SetParUnpackers();

    virtual Bool_t InitUnpackers();

    virtual Bool_t ReInitUnpackers();

    void Reset();

    virtual Source_Type GetSourceType() { return kONLINE; }

  protected:
    TObjArray* fUnpackers;

  private:
    FairOnlineSource& operator=(const FairOnlineSource&);

    ClassDef(FairOnlineSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                           FairLmdSource                           -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRLMDSOURCE_H
#define FAIRLMDSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"


class TList;


class FairLmdSource : public FairMbsSource
{
  public:
    FairLmdSource();
    FairLmdSource(const FairLmdSource& source);
    virtual ~FairLmdSource();

    void AddFile(TString fileName);
    void AddPath(TString dir, TString wildCard);
    inline Int_t GetCurrentFile() const { return fCurrentFile; }
    inline const TList* GetFileNames() const { return fFileNames; }

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

  protected:
    Bool_t OpenNextFile(TString fileName);

    Int_t fCurrentFile;
	Int_t fNEvent;
	Int_t fCurrentEvent;
    TList* fFileNames;
    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;
	s_filhe* fxInfoHeader;

    FairLmdSource& operator=(const FairLmdSource&);

    ClassDef(FairLmdSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                          FairRemoteSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRREMOTESOURCE_H
#define FAIRREMOTESOURCE_H

#include "FairMbsSource.h"


class TSocket;
class MRevBuffer;
class REvent;


class FairRemoteSource : public FairMbsSource
{
  public:
    FairRemoteSource(char* node);
    FairRemoteSource(const FairRemoteSource& source);
    virtual ~FairRemoteSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    inline const char* GetNode() const { return fNode; }

  private:
    char* fNode;
    TSocket* fSocket;
    MRevBuffer* fBuffer;
    REvent* fREvent;

    FairRemoteSource& operator=(const FairRemoteSource&);
    
  public:
    ClassDef(FairRemoteSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairMbsSource                         -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----              Copied from FairSource 01.11.2013 by F.Uhlig         -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSOURCE_H
#define FAIRMBSSOURCE_H

#include "FairOnlineSource.h"
#include "TObjArray.h"

#include "FairUnpack.h"


class FairMbsSource : public FairOnlineSource
{
  public:
    FairMbsSource();
    FairMbsSource(const FairMbsSource& source);
    virtual ~FairMbsSource();

    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t=0) = 0;
    virtual void Close() = 0;

  protected:
    Bool_t Unpack(Int_t* data, Int_t size,
                  Short_t type, Short_t subType,
                  Short_t procId, Short_t subCrate, Short_t control);

    ClassDef(FairMbsSource, 0)
};


#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairUnpack                            -----
// -----                    Created 12.04.2013 by D.Kresan                 -----
// -----------------------------------------------------------------------------

#ifndef FAIRUNPACK_H
#define FAIRUNPACK_H

#include "Rtypes.h"                     // for Int_t, Bool_t, etc
#include "TObject.h"


class FairUnpack : public TObject
{
  public:
    FairUnpack(Short_t type, Short_t subType,
               Short_t procId, Short_t subCrate, Short_t control);
    virtual ~FairUnpack();

    virtual Bool_t Init() = 0;
    virtual Bool_t ReInit() { return kTRUE; }
    virtual Bool_t DoUnpack(Int_t* data, Int_t size) = 0;
    virtual void   Reset() = 0;
    virtual void   SetParContainers() {  };

    inline Short_t GetType()    const { return fType;     }
    inline Short_t GetSubType() const { return fSubType;  }
    inline Short_t GetProcId()  const { return fProcId;   }
    inline Short_t GetSubCrate() const { return fSubCrate; }
    inline Short_t GetControl()  const { return fControl;  }

  private:
    Short_t fType;
    Short_t fSubType;
    Short_t fProcId;
    Short_t fSubCrate;
    Short_t fControl;

  protected:
    virtual void Register() = 0;

  public:
    ClassDef(FairUnpack, 0)
};


#endif



/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             * 
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *  
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//////////////////////////////////////////////////////////////////////
// Copyright:
//   GSI, Gesellschaft fuer Schwerionenforschung mbH
//   Planckstr. 1
//   D-64291 Darmstadt
//   Germany
// created 16. 2.1999 by Horst Goeringer
//////////////////////////////////////////////////////////////////////
// MRevBuffer.h
//   description of class MRevBuffer
//   ROOT client package for multithreaded remote event server (MBS)
//////////////////////////////////////////////////////////////////////
// 20. 8.1999, H.G.: MRevBuffer::RevGetI added
//  6. 3.2000, H.G.: new member function RevStatus
//////////////////////////////////////////////////////////////////////

#ifndef MRevBuffer_H
#define MRevBuffer_H

#include "TObject.h"                    // for TObject

#include "Rtypes.h"                     // for Int_t, ClassDef, etc

class TSocket;

class REvent : public TObject
{
  private:
    Int_t  iSize;              // event size (byte)
    Int_t  iNumb;              // event number
    Int_t*  piData;            // event parameter

    REvent(const REvent&);
    REvent& operator=(const REvent&);

  public:
    REvent();                  // constructor
    ~REvent();                 // destructor

    void ReFillHead(Int_t* pHead);   // unpack and fill event header
    void ReFillData(Int_t* pData);   // unpack and fill event data

    Int_t ReGetNumb();               // get event number
    Int_t ReGetSize();               // get event size
    Int_t ReGetData(Int_t ichan);    // get event parameter ichan
    Int_t* GetData() { return piData; }

    Int_t nSubEvt;
    Int_t subEvtSize[100];
    Short_t subEvtType[100];
    Short_t subEvtSubType[100];
    Short_t subEvtProcId[100];
    Short_t subEvtSubCrate[100];
    Short_t subEvtControl[100];
    Int_t* pSubEvt[100];

    ClassDef(REvent, 0)           // prototype for event
};

//////////////////////////////////////////////////////////////////////

class MRevBuffer : public TObject
{
  private:
    TSocket* pTSocket;     // ptr socket of channel to event server
    Int_t  iSocket;        // socket id of channel to event server
    Int_t  iBufNo1;        // first buffer no. received (test)
    Int_t  iBufNo2;        // last buffer no. received (test)
    Int_t  iDebug;         // verbosity level (test)
    Int_t  iSwap;          // > 0: swap event data
    Int_t  iStatus;        // current status of server

    Int_t  iBufSizeAlloc;  // allocated buffer size
    Int_t  iBufSize;       // size current buffer
    Int_t  iBufNo;         // current buffer no.
    Int_t  iFragBegin;     // > 0: last buffer ended with fragment
    Int_t  iFragConc;      // no. of concatenated fragments
    Int_t  iFragBeginIgn;  // no. of ignored fragment begins
    Int_t  iFragEndIgn;    // no. of ignored fragment ends

    Int_t  iHeadPar;       // no. of (4 byte) parms buffer header
    Int_t  iEvtMax;        // no. of events requested
    Int_t  iEvtNo;         // last event no. handled
    Int_t  iEvtRel;        // rel. event no. in buffer
    Int_t  iEvtBuf;        // no. of events in current buffer
    Int_t  iEvtPar;        // no. of parameters in event (incl. len)
    Int_t*  piBuf;         // ptr event buffer
    Int_t*  piNextEvt;     // ptr first element next event
    REvent* pEvt;          // ptr event class

    MRevBuffer(const MRevBuffer&);
    MRevBuffer& operator=(const MRevBuffer&);

  public:
    MRevBuffer( Int_t iMode); // constructor
    ~MRevBuffer();            // destructor

    TSocket* RevOpen( char* pNode, Int_t iPort, Int_t iEvent);
    // input: node name and port number server, req. no. of events
    // returns Socket ptr of server connection

    Int_t* RevGetI( TSocket* pSocket, Int_t iFlush);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)

    REvent* RevGet( TSocket* pSocket, Int_t iFlush, Int_t iSkip);
    // get next event (pointer) from buffer, input:
    // Socket ptr,
    // iFlush = 1: skip current buffer (not impl)
    // iSkip > 0: take only each iSkip event (not impl)

    Int_t RevStatus(Int_t iOut);
    // get status information (iOut = 1: also message to stdout)
    // = 0: last event request successfull
    // = 1: server not yet connected
    // = 2: server connected, but still no request for events
    // = 3: server connection okay, but currently no DAQ events
    // = 4: connection to server closed
    // = 5: connection to server closed after user break (CTL C)
    // = 6: connection to server closed after failure

    void RevBufWait(Int_t iWait);
    // wait for iWait seconds

    Int_t RevBufsize();
    // get size of current buffer (byte)

    void  RevClose( TSocket* pSocket );           // input Socket ptr

    ClassDef(MRevBuffer, 0)        // prototype for remote event buffer
};

#endif     // !MRevBuffer_H 
// -----------------------------------------------------------------------------
// ----- FairMbsStreamSource header file                                   -----
// -----                                                                   -----
// ----- created by C. Simon on 2014-09-12                                 -----
// -----                                                                   -----
// ----- based on FairLmdSource by D. Kresan                               -----
// -----                                                                   -----
// ----- revision 23363, 2013-12-26                                        -----
// -----------------------------------------------------------------------------

#ifndef FAIRMBSSTREAMSOURCE_H
#define FAIRMBSSTREAMSOURCE_H

extern "C"
{
#include "f_evt.h"
#include "s_filhe_swap.h"
#include "s_bufhe_swap.h"
}

#include "TString.h"

#include "FairMbsSource.h"

class FairMbsStreamSource : public FairMbsSource
{
  public:
    FairMbsStreamSource(TString tServerName);
    FairMbsStreamSource(const FairMbsStreamSource& source);
    virtual ~FairMbsStreamSource();

    virtual Bool_t Init();
    virtual Int_t ReadEvent(UInt_t=0);
    virtual void Close();

    const char* GetServerName() const {return fServerName.Data();};

  private:
    Bool_t ConnectToServer();

    TString fServerName;

    s_evt_channel* fxInputChannel;
    s_ve10_1* fxEvent;
    s_bufhe* fxBuffer;
    Int_t* fxEventData;
    s_ves10_1* fxSubEvent;

    FairMbsStreamSource& operator=(const FairMbsStreamSource&);


  public:
    ClassDef(FairMbsStreamSource, 0)
};


#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

G__BaseDict dictionary payload:1572:32: error: base class has incomplete type
class FairRunAnaProof : public FairRunAna
                        ~~~~~~~^~~~~~~~~~
/mnt/spirit/analysis/software/FairRoot.realMar18.v-17.10b/include/FairRunAna.h:35:7: note: definition of 'FairRunAna' is not complete until the closing '}'
class FairRunAna : public FairRun
      ^
